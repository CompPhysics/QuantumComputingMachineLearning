\documentclass[10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[version=4]{mhchem}
\usepackage{stmaryrd}
\usepackage{graphicx}
\usepackage[export]{adjustbox}
\graphicspath{ {./images/} }
\usepackage{bbold}
\usepackage{hyperref}
\hypersetup{colorlinks=true, linkcolor=blue, filecolor=magenta, urlcolor=cyan,}
\urlstyle{same}

\title{CSE 599d - Quantum Computing The Quantum Fourier Transform and Jordan's Algorithm }


\author{Dave Bacon\\
Department of Computer Science 8 Engineering, University of Washington}
\date{}


\begin{document}
\maketitle
After Simon's algorithm, the next big breakthrough in quantum algorithms occurred when Peter Shor discovered his algorithm for efficiently factoring numbers. This algorithm makes us of the quantum Fourier transform. In this lecture we will deviate to discuss the (quantum) discrete Fourier transform and see an application of this transform which was only recently (2005) realized.

\section*{I. DISCRETE FOURIER TRANSFORM}
There are many motivations for the discrete Fourier transform. Those of you in computer science have probably encountered them first in signal processing and perhaps further in cool theory results like switching lemmas. Those of you in physics have definitely encountered the continuous fourier transform, most likely first in quantum theory where we learn that the fourier transform goes between the momentum and position representations of a wave function.

Suppose that we have a vector $f$ of $N$ complex numbers, $f_{k}, k \in\{0,1, \ldots, N-1\}$. Then the discrete Fourier transform (DFT) is a map from these $N$ complex numbers to $N$ complex numbers, the Fourier transformed coefficients $\tilde{f}_{j}$, given by


\begin{equation*}
\tilde{f}_{j}=\frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} \omega^{-j k} f_{k} \tag{1}
\end{equation*}


where $\omega=\exp \left(\frac{2 \pi i}{N}\right)$. The inverse DFT is given by


\begin{equation*}
f_{j}=\frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} \omega^{j k} \tilde{f}_{k} \tag{2}
\end{equation*}


To see this consider how the basis vectors transform. If $f_{k}^{l}=\delta_{k, l}$, then


\begin{equation*}
\tilde{f}_{j}^{l}=\frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} \omega^{-j k} \delta_{k, l}=\frac{1}{\sqrt{N}} \omega^{-j l} \tag{3}
\end{equation*}


These DFTed vectors are orthonormal:


\begin{equation*}
\sum_{j=0}^{N-1} \tilde{f}^{l}{ }_{j}^{*} \tilde{f}_{j}^{m}=\frac{1}{N} \sum_{j=0}^{N-1} \omega^{j l} \omega^{-j m}=\frac{1}{N} \sum_{j=0}^{N-1} \omega^{j(l-m)} \tag{4}
\end{equation*}


This last sum can be evaluated as a geometric series, but beware of the $(l-m)=0$ term, and yields


\begin{equation*}
\sum_{j=0}^{N-1} \tilde{f}^{l}{ }_{j}^{*} \tilde{f}_{j}^{m}=\delta_{l, m} \tag{5}
\end{equation*}


From this we can check that the inverse DFT does indeed perform the inverse transform:


\begin{equation*}
f_{j}=\frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} \omega^{j k} \tilde{f}_{k}=\frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} \omega^{j k} \frac{1}{\sqrt{N}} \sum_{l=0}^{N-1} \omega^{-l k} f_{l}=\frac{1}{N} \sum_{k, l=0}^{N-1} \omega^{(j-l) k} f_{l}=\sum_{l=0}^{N-1} \delta_{j, l} f_{l}=f_{j} \tag{6}
\end{equation*}


An important property of the DFT is the convolution theorem. The circular convolution of two vectors $f$ and $g$ is given by


\begin{equation*}
(f * g)_{i}=\sum_{j=0}^{N-1} f_{j} g_{i-j} \tag{7}
\end{equation*}


where we define $g_{-m}=g_{N-m}$. The convolution theorem states that the DFT turns convolution into pointwise vector multiplication. In other words if the components of the DFT of $(f * g)$ are $\tilde{c}_{k}$, then $\tilde{c}_{k}=\tilde{f}_{k} \tilde{g}_{k}$. What use is the convolution theorem? Well this leads us nicely to our next topic, the fast Fourier transform.

\section*{II. FAST FOURIER TRANSFORM AND AN APPLICATION}
Naively how many math operations do we have to do to perform a discrete Fourier transform? Well for each component of the new vector we will need to perform $N$ multiplications and then we will need to add these components. Since we need to do this for each of the $N$ different component. Thus we see that $N^{2}$ complex multiplications and $N(N-1)$ complex additions are needed to compute the DFT. The goal of the fast Fourier transform is to perform the DFT using less basic math operations. There are may ways to do this. We will describe one particular method for $N=2^{n}$ and will put off discussion of the case where $N \neq 2^{n}$ until later. So assume $N=2^{n}$ from here until I say otherwise.

The Fast Fourier Transform (FFT) we will consider is based on observing the fact that the there are symmetries of the coefficients in the DFT,


\begin{align*}
\omega^{k+N / 2} & =-\omega^{k} \\
\omega^{k+N} & =\omega^{k} . \tag{8}
\end{align*}


Suppose we want to perform the DFT of the vector $f$. Split the components of $f$ up into smaller vectors of size $N / 2$, $e$ and $o$. The coefficients of $e$ are the components of $f$ which are even and the coefficients of $o$ are the components of $f$ which are odd. The order of the coefficients is retained. Then it is easy to see that


\begin{align*}
\tilde{f}_{j} & =\frac{1}{\sqrt{N}} \sum_{i=0}^{N-1} \omega^{-i j} f_{i}=\frac{1}{\sqrt{N}} \sum_{i=0}^{N / 2-1} \omega^{-2 i j} e_{i}+\sum_{i=0}^{N / 2-1} \omega^{-(2 i+1) j} o_{i} \\
& =\frac{1}{\sqrt{N}}\left(\sum_{i=0}^{N / 2-1} \omega_{N / 2}^{-i j} e_{i}+\omega_{N}^{-j} \sum_{i=0}^{N / 2-1} \omega_{N / 2}^{-i j} o_{i}\right) \tag{9}
\end{align*}


where $\omega_{N / 2}=\exp \left(\frac{2 \pi i}{N}\right)$ and we have denoted $\omega$ by $\omega_{N}$ for clarity. We have thus obtained the a formula for the DFT of $f$ in terms of the DFT of $e$ and $o$ :


\begin{equation*}
\tilde{f}_{j}=\tilde{e}_{j}+\omega_{N}^{-j} \tilde{o}_{j} \tag{10}
\end{equation*}


Now recall that $j$ runs from 0 to $N-1$ and the DFTs of $e$ and $f$ are periodic with period $N / 2$. Using this and the above symmetry we find that we can express our formula as

\[
\begin{array}{ll}
\sqrt{2} \tilde{f}_{j}=\tilde{e}_{j}+\omega_{N}^{-j} \tilde{o}_{j} & 0 \leq j \leq N / 2-1 \\
\sqrt{2} \tilde{f}_{j}=\tilde{e}_{j}-\omega_{N}^{-j} \tilde{o}_{j} & N / 2-2 \leq j \leq N-1 \tag{11}
\end{array}
\]

Suppose that we first compute the DFT over $e$ and $o$ and then uses them in this formula to compute the full DFT of $f$. How many complex multiplications do we need to perform? Well to compute $e$ and $o$ requires $2 \frac{N}{2}^{2}=\frac{N^{2}}{2}$ multiplications. We need another $N / 2$ to compute $\omega_{N}^{-j} \tilde{o}_{j}$. Forget about the square root of two, it can always be put in at the end as an extra $N$ multiplications. Thus we require $\frac{N^{2}}{2}+\frac{N}{2}$ complex multiplications to compute the DFT as opposed to $N^{2}$ in the the previous method. This is a reduction of about a factor of 2 for large $N$.

Further it is clear that for $N=2^{n}$ we can use the above trick all the way down to $N=2$. How many complex multiplications do we need to perform if we do this? Let $T_{n}$ denote the number of multiplications at the $N=2^{n}$ th level, such that $T_{1}=4$. Then


\begin{equation*}
T_{n}=2 T_{n-1}+2^{n-1} \tag{12}
\end{equation*}


which can be bounded by


\begin{equation*}
T_{n} \leq 2 T_{n-1}+2^{n} \tag{13}
\end{equation*}


which has solution $T_{n} \leq 2^{n} n$. In other words the running time is bounded by $N \log N$. Thus we see that in the FFT we can compute the DFT in a complexity of $N \log N$ operations. This is a nice little improvement. Of historical interest apparently Gauss knew the FFT algorithm.

Here is a very cool application of the FFT. Suppose that you have two polynomials with complex coefficients: $f(x)=a_{0}+a_{1} x+\cdots+a_{N-1} x^{N-1}$ and $g(x)=b_{0}+b_{1} x+\cdots+b_{N-1} x^{N-1}$. If you multiply these two polynomials\\
together you get a new polynomial $f(x) g(x)=\sum_{i, j=0}^{N-1} a_{i} b_{j} x^{i+j}=\sum_{k=0}^{2(N-1)} c_{k} x^{k}$. The new coefficients for this polynomial are a function of the two polynomials:


\begin{equation*}
c_{k}=\sum_{l=0}^{N-1} a_{l} b_{k-l} \tag{14}
\end{equation*}


where the sum is over all valid polynomial terms (i.e. when $k-l$ is negative, there is no term in the sum.) One sees that computing $c_{k}$ requires $N^{2}$ multiplications.

But wait, the expression for $c_{k}$ looks a lot like convolution. Indeed suppose that we form a $2 N$ dimensional vector $a=\left(a_{0}, \ldots, a_{N-1}, 0, \ldots, 0\right)$ and $b=\left(b_{0}, \ldots, b_{N-1}, 0, \ldots, 0\right)$ from our original data. The vector $c$ which will represent the coefficients of the new polynomial are then given by


\begin{equation*}
c_{k}=\sum_{l=0}^{2 N-1} a_{l} b_{k-l} \bmod 2 N \tag{15}
\end{equation*}


Now we don't need to condition this sum on their being valid terms. Now this is explicitly convolution! Thus we can compute the coefficients $c_{k}$ by the following algorithm. Compute the DFT of the vectors $a$ and $b$. Pointwise multiply these two vectors. Then inverse DFT this new vector. The result will be $c_{k}$ by the convolution theorem. If we use the FFT algorithm for this procedure, then we will require $O(N \log N)$ multiplications. This is pretty cool: by using the FFT we can multiply polynomials faster than our naive grade school method for multiplying polynomials. It is good to see that our grad school self can do things our grade school self cannot do. Some of you will even know that you can use the FFT to multiply integers $N$ integers with a cost of $O\left(N \log ^{2} N\right)$ or used recursively: $O(N \log N \log \log N \log \log \log N \cdots)$.

\section*{III. QUANTUM FOURIER TRANSFORM CIRCUITS}
Now lets turn to the Quantum Fourier transform (QFT). We've already seen the QFT for $N=2$. It is the Hadamard transform:

\[
H=\frac{1}{\sqrt{2}}\left[\begin{array}{cc}
1 & 1  \tag{16}\\
1 & -1
\end{array}\right]
\]

Why is this the QFT for $N=2$ ? Well suppose have the single qubit state $a_{0}|0\rangle+a_{1}|1\rangle$. If we apply the Hadamard operation to this state we obtain the new state


\begin{equation*}
\frac{1}{\sqrt{2}}\left(a_{0}+a_{1}\right)|0\rangle+\frac{1}{\sqrt{2}}\left(a_{0}-a_{1}\right)|1\rangle=\tilde{a}_{0}|0\rangle+\tilde{a}_{1}|1\rangle . \tag{17}
\end{equation*}


In other words the Hadamard gate performs the DFT for $N=2$ on the amplitudes of the state! Notice that this is very different that computing the DFT for $N=2$ : remember the amplitudes are not numbers which are accessible to us mere mortals, they just represent our description of the quantum system.

So what is the full quantum Fourier transform? It is the transform which takes the amplitudes of a $N$ dimensional state and computes the Fourier transform on these amplitudes (which are then the new amplitudes in the computational basis.) In other words, the QFT enacts the transform


\begin{equation*}
\sum_{x=0}^{N-1} a_{x}|x\rangle \rightarrow \sum_{x=0}^{N-1} \tilde{a}_{x}|x\rangle=\sum_{x=0}^{N-1} \frac{1}{\sqrt{N}} \sum_{y=0}^{N-1} \omega_{N}^{-x y} a_{y}|x\rangle \tag{18}
\end{equation*}


It is easy to see that this implies that the QFT performs the following transform on basis states:


\begin{equation*}
|x\rangle \rightarrow \frac{1}{\sqrt{N}} \sum_{y=0}^{N-1} \omega_{N}^{-x y}|y\rangle \tag{19}
\end{equation*}


Thus the QFT is given by the matrix


\begin{equation*}
U_{Q F T}=\frac{1}{\sqrt{N}} \sum_{x=0}^{N-1} \sum_{y=0}^{N-1} \omega_{N}^{-y x}|y\rangle\langle x| \tag{20}
\end{equation*}


This matrix is unitary. Let's check this:


\begin{align*}
U_{Q F T} U_{Q F T}^{\dagger} & =\frac{1}{N} \sum_{x=0}^{N-1} \sum_{y=0}^{N-1} \omega_{N}^{y x}|x\rangle\left\langle y\left|\sum_{x^{\prime}=0}^{N-1} \sum_{y^{\prime}=0}^{N-1} \omega_{N}^{-y^{\prime} x^{\prime}}\right| y^{\prime}\right\rangle\left\langle x^{\prime}\right| \\
& =\frac{1}{N} \sum_{x, y, x^{\prime}, y^{\prime}=0}^{N-1} \omega_{N}^{y x-y^{\prime} x^{\prime}} \delta_{y, y^{\prime}}|x\rangle\left\langle x^{\prime}\left|=\frac{1}{N} \sum_{x, y, x^{\prime}=0}^{N-1} \omega_{N}^{y\left(x-x^{\prime}\right)}\right| x\right\rangle\left\langle x^{\prime}\right| \\
& =\sum_{x, x^{\prime}=0}^{N-1} \delta_{x, x^{\prime}}|x\rangle\left\langle x^{\prime}\right|=I \tag{21}
\end{align*}


The QFT is a very important transform in quantum computing. It can be used for all sorts of cool tasks, including, as we shall see in Shor's algorithm. But before we can use it for quantum computing tasks, we should try to see if we can efficiently implement the QFT with a quantum circuit. Indeed we can and the reason we can is intimately related to the fast Fourier transform.

Let's derive a circuit for the QFT when $N=2^{n}$. The QFT performs the transform


\begin{equation*}
|x\rangle \rightarrow \frac{1}{\sqrt{2^{n}}} \sum_{y=0}^{2^{n}-1} \omega_{N}^{-x y}|y\rangle \tag{22}
\end{equation*}


Then we can expand out this sum


\begin{equation*}
|x\rangle \rightarrow \frac{1}{\sqrt{2^{n}}} \sum_{y_{1}, y_{2}, \ldots, y_{n} \in\{0,1\}} \omega_{N}^{-x \sum_{k=1}^{n} 2^{n-k} y_{k}}\left|y_{1}, y_{2}, \ldots, y_{n}\right\rangle \tag{23}
\end{equation*}


Expanding the exponential of a sum to a product of exponentials and collecting these terms in from the appropriate terms we can express this as


\begin{equation*}
|x\rangle \rightarrow \frac{1}{\sqrt{2^{n}}} \sum_{y_{1}, y_{2}, \ldots, y_{n} \in\{0,1\}} \bigotimes_{k=1}^{n} \omega_{N}^{-x 2^{n-k} y_{k}}\left|y_{k}\right\rangle \tag{24}
\end{equation*}


We can rearrange the sum and products as


\begin{equation*}
|x\rangle \rightarrow \frac{1}{\sqrt{2^{n}}} \bigotimes_{k=1}^{n}\left[\sum_{y_{k} \in\{0,1\}} \omega_{N}^{-x 2^{n-k} y_{k}}\left|y_{k}\right\rangle\right] \tag{25}
\end{equation*}


Expanding this sum yields


\begin{equation*}
|x\rangle \rightarrow \frac{1}{\sqrt{2^{n}}} \bigotimes_{k=1}^{n}\left[|0\rangle+\omega_{N}^{-x 2^{n-k}}|1\rangle\right] \tag{26}
\end{equation*}


But now notice that $\omega_{N}^{-x 2^{n-k}}$ is not dependent on the higer order bits of $x$. It is convenient to adopt the following expression for a binary fraction:


\begin{equation*}
0 . x_{l} x_{l+1} \ldots x_{n}=\frac{x_{l}}{2}+\frac{x_{l+1}}{4}+\cdots+\frac{x_{n}}{2^{n-l+1}} \tag{27}
\end{equation*}


Then we can see that


\begin{equation*}
|x\rangle \rightarrow \frac{1}{\sqrt{2^{n}}}\left[|0\rangle+e^{-2 \pi i 0 . x_{n}}|1\rangle\right] \otimes\left[|0\rangle+e^{-2 \pi i 0 . x_{n-1} x_{n}}|1\rangle\right] \otimes \cdots \otimes\left[|0\rangle+e^{-2 \pi i 0 . x_{1} x_{2} \cdots x_{n}}|1\rangle\right] \tag{28}
\end{equation*}


This is a very useful form of the QFT for $N=2^{n}$. Why? Because we see that only the last qubit depends on the the values of all the other input qubits and each further bit depends less and less on the input qubits. Further we note that $e^{-2 \pi i 0 . a}$ is either +1 or -1 , which reminds us of the Hadamard transform.

So how do we use this to derive a circuit for the QFT over $N=2^{n}$ ?

Take the first qubit of $\left|x_{1}, \ldots, x_{n}\right\rangle$ and apply a Hadamard transform. This produces the transform


\begin{equation*}
|x\rangle \rightarrow \frac{1}{\sqrt{2}}\left[|0\rangle+e^{-2 \pi i 0 \cdot x_{1}}|1\rangle\right] \otimes\left|x_{2}, x_{3}, \ldots, x_{n}\right\rangle \tag{29}
\end{equation*}


Now define the rotation gate

\[
R_{k}=\left[\begin{array}{cc}
1 & 0  \tag{30}\\
0 & \exp \left(\frac{-2 \pi i}{2^{k}}\right)
\end{array}\right]
\]

If we now apply controlled $R_{2}, R_{3}$, etc. gates controlled on the appropriate bits this enacts the transform


\begin{equation*}
|x\rangle \rightarrow \frac{1}{\sqrt{2}}\left[|0\rangle+e^{-2 \pi i 0 . x_{1} x_{2} \ldots x_{n}}|1\rangle\right] \otimes\left|x_{2}, x_{3}, \ldots, x_{n}\right\rangle \tag{31}
\end{equation*}


Thus we have reproduced the last term in the QFTed state. Of course now we can proceed to the second qubit, perform a Hadamard, and the appropriate controlled $R_{k}$ gates and get the second to last qubit. Thus when we are finished we will have the transform


\begin{equation*}
|x\rangle \rightarrow \frac{1}{\sqrt{2^{n}}}\left[|0\rangle+e^{-2 \pi i 0 . x_{1} x_{2} \cdots x_{n}}|1\rangle\right] \otimes\left[|0\rangle+e^{-2 \pi i 0 . x_{1} x_{2} \cdots x_{n-1}}|1\rangle\right] \otimes \cdots \otimes\left[|0\rangle+e^{-2 \pi i 0 . x_{n}}|1\rangle\right] \tag{32}
\end{equation*}


Reversing the order of these qubits will then produce the QFT!

The circuit we have constructed on $n$ qubits is

\begin{center}
\includegraphics[max width=\textwidth]{2024_03_18_c1d427fa6b85efa365f1g-5}
\end{center}

This circuit is polynomial size in $n$. Actually we can count the number of quantum gates in it: $\sum_{i=1}^{n} i=\frac{n(n+1)}{2}$ Hadamards and controlled $R_{k}$ gates plus $\left\lfloor\frac{n}{2}\right\rfloor$ swap gates. What was it that allowed us to construct an efficient circuit? Well if you look at the factorization we used, you will see that we have basically used the same trick that we used for the FFT! But now, since we are working on amplitudes and not operating on the the complex vectors themselves, we get an algorithm which scales nicely in the number of qubits. It is important to realize that the QFT cannot be used like the FFT on data. Thus there is a tendency to want to port quantum computers over to signal processing. Currently there are some preliminary ideas about how to do this, but the naive way you might expect this to work does not work.

\section*{IV. JORDAN'S NUMERICAL GRADIENT ALGORITHM}
There is a very neat application of the QFT which was only recently realized. It is motivated by the BernsteinVazirani problem. Recall that in the nonrecursive Bernstein-Vazirani problem we given a function $f_{s}(x)=x \cdot s$ and we desired to find $s$. Notice that in some since, $s$ is the (discrete) gradient of the function (which in this case is linear.) Now we know that central to this was the Hadamard, which we have seen is the QFT for $N=2$. So can we use the QFT over $N$ to learn something about the gradient of a more general function? In 2004, Jordan showed that this was possible (while he was a graduate student! This should give hope to all graduate student around the world. Indeed, it should even give hope to postdocs and faculty members as well.)

Suppose that we are given a black box which computes a function $f: \mathbb{R}^{d} \rightarrow \mathbb{R}$ on some pre-specified domain. We will scale this domain to $[0,1)^{d}$ and assume that we have the function computed to some finite precision of bits $n$. Now suppose that we want to calculate an estimate of the gradiant of this function $\nabla f=\left(\frac{\partial f}{\partial x_{1}}, \frac{\partial f}{\partial x_{2}}, \ldots, \frac{\partial f}{\partial x_{d}}\right)$ without loss of generality at the origin. Now classically when we query $f$ we only obtain one value of $f$. A natural way to calculate an estimate of the gradient of $f$ is to evaluate $f$ at the origin, and then $f$ along the $d$ different directions, i.e. $f(0, \ldots, 0, l, 0, \ldots, 0)$, and, evaluate the differences. For small enough $l$ this will approximate the gradient using $d+1$\\
queries. A more symmetric method is to query the function at $+l / 2$ and $-l / 2$ and take the differences. Thus we can easily see that to evaluate an estimate of the gradiant we need some $\Omega(d)$ queries. (Really we should be defining the class of functions which we can estimate, and being careful about accuracy, etc., but we will skip over these details.)

But can we do better using a quantum algorithm? Suppose that we have access to the function $f$ by the unitary oracle:


\begin{equation*}
U_{f}=\sum_{x_{1}, \ldots, x_{d}, y \in\{0,1\}^{n}}\left|x_{1}, \ldots, x_{d}\right\rangle\left\langle x_{1}, \ldots, x_{d}|\otimes| y+f\left(-\frac{l}{2}+l \frac{x_{1}}{2^{n}}, \ldots,-\frac{l}{2}+l \frac{x_{n}}{2^{n}}\right) \bmod 2^{n}\right\rangle\langle y| \tag{34}
\end{equation*}


where the function's input has been appropriately scaled to a region of size $l$. Now we do what we did in the BernsteinVazirani problem. First we perform phase kickback. We do this by feeding into the $|y\rangle$ register of this unitary the state


\begin{equation*}
|\tilde{1}\rangle=\sum_{x=0}^{2^{n}-1} \exp \left(\frac{2 \pi i x}{2^{n}}\right)|x\rangle \tag{35}
\end{equation*}


along with superpositions over all possible $|x\rangle$ inputs. The state $|\tilde{1}\rangle$ can be created by performing a QFT on $|1\rangle$. The resulting state will be


\begin{equation*}
\sum_{x_{1}, \ldots, x_{d} \in\{0,1\}} \exp \left(\frac{2 \pi i f\left(-\frac{l}{2}+l \frac{x_{1}}{2^{n}}, \ldots,-\frac{l}{2}+l \frac{x_{d}}{2^{n}}\right)}{2^{n}}\right)\left|x_{1}, \ldots, x_{d}\right\rangle \otimes|\tilde{1}\rangle \tag{36}
\end{equation*}


For small enough $l$, this is just


\begin{equation*}
\sum_{x_{1}, \ldots, x_{d} \in\{0,1\}} \exp \left(\frac{2 \pi i\left[f(0, \ldots, 0)+\frac{\partial f}{\partial x_{1}} l\left(2^{-n} x_{1}-\frac{1}{2}\right)+\cdots+\frac{\partial f}{\partial x_{d}} l\left(2^{-n} x_{d}-\frac{1}{2}\right)\right]}{2^{n}}\right)\left|x_{1}, \ldots, x_{n}\right\rangle \otimes|\tilde{1}\rangle \tag{37}
\end{equation*}


If we now perfrom QFTs individually on each of these $d$ registers we will obtain (with high probability, under some reasonable assumptions)


\begin{equation*}
\left|\frac{\partial f}{\partial x_{1}} \frac{l}{2^{n}}, \ldots, \frac{\partial f}{\partial x_{d}} \frac{l}{2^{n}}\right\rangle \otimes|\tilde{1}\rangle \tag{38}
\end{equation*}


Thus we see that we have obtained the gradient of the function using a single quantum query! Now of course we need to be careful about analyzing this algorithm correctly, and if you are interested in seeing the details of such a calculation you can find it at \href{http://arxiv.org/abs/quant-ph/0405146}{http://arxiv.org/abs/quant-ph/0405146}.

\section*{Acknowledgments}
The diagrams in these notes were typeset using Q-circuit a latex utility written by graduate student extraordinaires Steve Flammia and Bryan Eastin.


\end{document}