TITLE: April 1-4, 2024: Quantum Computing, Quantum Machine Learning and Quantum Information Theories
AUTHOR: Morten Hjorth-Jensen {copyright, 1999-present|CC BY-NC} at Department of Physics, University of Oslo & Department of Physics and Astronomy and Facility for Rare Isotope Beams, Michigan State University
DATE: today



===== Plans for the week of April 1-4 =====

!bblock 
o Quantum Fourier transforms, basic mathematical expressions
o Reading recommendation Hundt, Quantum Computing for Programmers, sections 6.1-6.4 on QFT.
#o "Whiteboard notes":"https://github.com/CompPhysics/QuantumComputingMachineLearning/blob/gh-pages/doc/HandWrittenNotes/2024/NotesMarch20.pdf"
!eblock


!split
===== Possible paths for project 2 =====

* Implement QFTs  and study the phase estimation algorithm and eventually Shor's algorithm for factorization of numbers.
* Study other algorithms
  o Deutsch-Jozsa algorithm: Determine if a function is constant or balance using the fewest number of queries.
  o SImon's algorithm: Determine if a function (Oracle) is one-to-one or two-to-one
  o Grover's algorithm: Search unstructured list of data fast
  o Shor's algorithm : Factorize integers efficiently
* Study the solution of quantum mechanical eigenvalue problems with systems from atomic/molecular physics and quantum chemistry
* Quantum machine learning projects
* Other paths
For project 2, in order to be time efficient, you can use software like Qiskit, Pennylane, qBraid and/or other




!split
===== Simple example =====

As an example we can have a set of complex numbers
$\{x_0,\dots,x_{N-1}\}$ with fixed length $N$, we can Fourier
transform this as
!bt
\[
y_k = \frac{1}{\sqrt{N}} \sum_{j=0}^{N-1} x_j \exp{i(2\pi jk)/N},
\]
!et

leading to a new set of complex numbers $\{ y_0,\dots,y_{N-1}\}$. 




!split
===== Discrete Fourier Transformations =====

Consider two sets of complex numbers $x_k$ and $y_k$ with
$k=0,1,\dots,n-1$ entries. The discrete Fourier transform is defined
as
!bt
\[
y_k = \frac{1}{\sqrt{n-1}} \sum_{j=0}^{n-1} \exp{(\frac{2\pi\imath jk}{n})} x_j.
\]
!et
As an example, assume $x_0=1$ and $x_1=1$. We can then use the above expression to find $y_0$ and $y_1$.

With the above formula we get then
!bt
\[
y_0 = \frac{1}{\sqrt{2}} \left( \exp{(\frac{2\pi\imath 0\times 1}{2})} \times 1+\exp{(\frac{2\pi\imath 0\times 1}{2})}\times 2\right)=\frac{1}{\sqrt{2}}(1+2)=\frac{3}{\sqrt{2}},
\]
!et
and
!bt
\[
y_1 = \frac{1}{\sqrt{2}} \left( \exp{(\frac{2\pi\imath 0\times 1}{2})} \times 1+\exp{(\frac{2\pi\imath 1\times 1}{2})}\times 2\right)=\frac{1}{\sqrt{2}}(1+2\exp{(\pi\imath)})=-\frac{1}{\sqrt{2}},
\]
!et


!split
===== More details on Discrete Fourier transforms =====

Suppose that we have a vector $f$ of $N$ complex numbers, $f_{k}, k
\in\{0,1, \ldots, N-1\}$. Then the discrete Fourier transform (DFT) is
a map from these $N$ complex numbers to $N$ complex numbers, the
Fourier transformed coefficients $\tilde{f}_{j}$, given by

!bt
\begin{equation*}
\tilde{f}_{j}=\frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} \omega^{-j k} f_{k}
\end{equation*}
!et
where $\omega=\exp \left(\frac{2 \pi i}{N}\right)$.

!split
===== Invert DFT =====
The inverse DFT is given by

!bt
\begin{equation*}
f_{j}=\frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} \omega^{j k} \tilde{f}_{k}
\end{equation*}
!et

To see this consider how the basis vectors transform. If $f_{k}^{l}=\delta_{k, l}$, then


!bt
\begin{equation*}
\tilde{f}_{j}^{l}=\frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} \omega^{-j k} \delta_{k, l}=\frac{1}{\sqrt{N}} \omega^{-j l}
\end{equation*}
!et

!split
===== Orthonormality ===== 
These DFT vectors are orthonormal:

!bt
\begin{equation*}
\sum_{j=0}^{N-1} \tilde{f}^{l}{ }_{j}^{*} \tilde{f}_{j}^{m}=\frac{1}{N} \sum_{j=0}^{N-1} \omega^{j l} \omega^{-j m}=\frac{1}{N} \sum_{j=0}^{N-1} \omega^{j(l-m)} 
\end{equation*}
!et

This last sum can be evaluated as a geometric series, but beware of the $(l-m)=0$ term, and yields

!bt
\begin{equation*}
\sum_{j=0}^{N-1} \tilde{f}^{l}{ }_{j}^{*} \tilde{f}_{j}^{m}=\delta_{l, m}
\end{equation*}
!et

From this we can check that the inverse DFT does indeed perform the inverse transform:

!bt
\begin{equation*}
f_{j}=\frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} \omega^{j k} \tilde{f}_{k}=\frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} \omega^{j k} \frac{1}{\sqrt{N}} \sum_{l=0}^{N-1} \omega^{-l k} f_{l}=\frac{1}{N} \sum_{k, l=0}^{N-1} \omega^{(j-l) k} f_{l}=\sum_{l=0}^{N-1} \delta_{j, l} f_{l}=f_{j} 
\end{equation*}
!et



!split
===== Quantum Fourier transform =====

We now turn to the quantum Fourier transform. It is the same
transformation as described above, however we define it in terms of
the unitary operation

!bt
\[
    \vert \psi'\rangle \leftarrow \hat{F}\vert \psi\rangle, \quad \hat{F}^\dagger \hat{F} = I
\]
!et


!split
===== Orthonormal basis =====

In terms of an orthonormal basis $\vert 0 \rangle,\vert 1\rangle,\dots,\vert 0 \rangle$ this linear operator has the following action

!bt
\[
\vert j \rangle \rightarrow \sum_{k=0}^{N-1} \exp{i(2\pi jk/N)}\vert k 
\]
!et

 or on an arbitrary state

!bt
\[
\sum_{j=0}^{N-1} x_j \vert j \rangle \rightarrow \sum_{k=0}^{N-1} y_k\vert k \rangle
\]
!et

equivalent to the equation for discrete Fourier transform on a set of complex numbers.
 
!split
===== Using computational basis =====

Next we assume an $n$-qubit system, where we take $N=s^n$ in the computational basis 
!bt
\[
\vert 0 \rangle,\dots,\vert 2^n -1\rangle.
\]
!et

We make use of the binary representation $j = j_1 2^{n-1} + j_2
2^{n-2} + \dots + j_n 2^0$ , and take note of the notation $0.j_l
j_{l+1} \dots j_m$ representing the binary fraction $\frac{j_l}{2^1} +
\frac{j_{l+1}}{2^{2}} + \dots + \frac{j_m}{2^{m-l+1}}$. With this we
define the product representation of the quantum Fourier transform

!bt
\[
\vert j_1,\dots,j_n\rangle  \rightarrow 
\frac{
\left(\vert 0 \rangle + \exp{i(2\pi 0.j_n)}\right)
\left(\vert 0 \rangle + \exp{i(2\pi 0.j_{j-1}j_n)}\right)
\dots
\left(\vert 0 \rangle + \exp{i(2\pi 0.j_1j_2\dots j_n)}\right)
}{2^{n/2}}
\]
!et

!split
===== Components =====

From the product representation we can derive a circuit for the
quantum Fourier transform. This will make use of the following two
single-qubit gates
!bt
\[
    H = \frac{1}{\sqrt{2}}
    \begin{bmatrix}
        1 & 1 \\
        1 & -1
    \end{bmatrix}
\]
!et
!bt
\[
    R_k =
    \begin{bmatrix}
        1 & 0 \\
        0 & e^{2\pi i/2^{k}}
    \end{bmatrix}
\]
!et

!split
===== Using the Hadamard gate =====
The Hadamard
gate on a single qubit creates an equal superposition of its basis
states, assuming it is not already in a superposition, such that
 
!bt
\[
H\vert 0 \rangle = \frac{1}{\sqrt{2}} \left(\vert 0 \rangle + \vert 1\rangle\right), \quad H\vert 1\rangle = \frac{1}{\sqrt{2}} \left(\vert 0 \rangle - \vert 1\rangle\right)
\]
!et 
The $R_k$ gate simply adds a phase if the qubit it acts on is in the state $\vert 1\rangle$
!bt
\[
    R_k\vert 0 \rangle = \vert 0 \rangle, \quad R_k\vert 1\rangle = e^{2\pi i/2^{k}}\vert 1\rangle
\]
!et

Since all this gates are unitary, the quantum Fourier transfrom is also unitary.

!split
===== Algorithm =====

Assume we have a quantum register of $n$ qubits in the state $\vert j_1 j_2 \dots j_n\rangle$.
Applying the Hadamard gate to the first qubit
produces the state

!bt
\[
H\vert j_1 j_2 \dots j_n\rangle = \frac{\left(\vert 0 \rangle + e^{2\pi i 0.j_1}\vert 1\rangle\right)}{2^{1/2}} \vert j_2 \dots j_n\rangle.
\]
!et

!split
===== Binary fraction =====

Here we have made use of the binary fraction to represent the action of the Hadamard gate 
!bt
\[
\exp{2\pi i 0.j_1} = -1,
\]
!et
if $j_1 = 1$ and $+1$ if $j_1 = 0$.


!split
===== Controlled rotation gate =====

Furthermore we can apply the controlled-$R_k$ gate, with all the other qubits $j_k$ for $k>1$ as control qubits to produce the state

!bt
\[
\frac{\left(\vert 0 \rangle + e^{2\pi i 0.j_1j_2\dots j_n}\vert 1\rangle\right)}{2^{1/2}} \vert j_2 \dots j_n\rangle
\]
!et

Next we do the same procedure on qubit $2$ producing the state

!bt
\[
\frac{\left(\vert 0 \rangle + e^{2\pi i 0.j_1j_2\dots j_n}\vert 1\rangle\right)\left(\vert 0 \rangle + e^{2\pi i 0.j_2\dots j_n}\vert 1\rangle\right)}{2^{2/2}} \vert j_2 \dots j_n\rangle
\]
!et

!split
===== Applying to all qubits =====

Doing this for all $n$ qubits yields state

!bt
\[
\frac{\left(\vert 0 \rangle + e^{2\pi i 0.j_1j_2\dots j_n}\vert 1\rangle\right)\left(\vert 0 \rangle + e^{2\pi i 0.j_2\dots j_n}\vert 1\rangle\right)\dots \left(\vert 0 \rangle + e^{2\pi i 0.j_n}\vert 1\rangle\right)}{2^{n/2}} \vert j_2 \dots j_n\rangle
\]
!et
At the end we use swap gates to reverse the order of the qubits

!bt
\[
\frac{\left(\vert 0 \rangle + e^{2\pi i 0.j_n}\vert 1\rangle\right)\left(\vert 0 \rangle + e^{2\pi i 0.j_{n-1}j_n}\vert 1\rangle\right)\dots\left(\vert 0 \rangle + e^{2\pi i 0.j_1j_2\dots j_n}\vert 1\rangle\right) }{2^{n/2}} \vert j_2 \dots j_n\rangle
\]
!et
This is just the product representation from earlier, obviously our desired output.




!split
===== Quantum Fourier transform =====

Now lets turn to the Quantum Fourier transform (QFT). We've already
seen the QFT for $N=2$. It is the Hadamard transform:
!bt
\[
H=\frac{1}{\sqrt{2}}\left[\begin{array}{cc}
1 & 1  \\
1 & -1
\end{array}\right]
\]
!et

!split
===== QFT for $N=2$ =====

Why is this the QFT for $N=2$ ? Well suppose have the single qubit
state $a_{0}|0\rangle+a_{1}|1\rangle$. If we apply the Hadamard
operation to this state we obtain the new state

!bt
\begin{equation*}
\frac{1}{\sqrt{2}}\left(a_{0}+a_{1}\right)|0\rangle+\frac{1}{\sqrt{2}}\left(a_{0}-a_{1}\right)|1\rangle=\tilde{a}_{0}|0\rangle+\tilde{a}_{1}|1\rangle . 
\end{equation*}
!et

In other words the Hadamard gate performs the DFT for $N=2$ on the
amplitudes of the state! Notice that this is very different that
computing the DFT for $N=2$ : remember the amplitudes are not numbers
which are accessible to us mere mortals, they just represent our
description of the quantum system.


!split
===== Full QFT =====

So what is the full quantum Fourier transform? It is the transform
which takes the amplitudes of a $N$ dimensional state and computes the
Fourier transform on these amplitudes (which are then the new
amplitudes in the computational basis.) In other words, the QFT enacts
the transform

!bt
\begin{equation*}
\sum_{x=0}^{N-1} a_{x}|x\rangle \rightarrow \sum_{x=0}^{N-1} \tilde{a}_{x}|x\rangle=\sum_{x=0}^{N-1} \frac{1}{\sqrt{N}} \sum_{y=0}^{N-1} \omega_{N}^{-x y} a_{y}|x\rangle 
\end{equation*}
!et

!split
===== Explicit transform =====
It is easy to see that this implies that the QFT performs the following transform on basis states:

!bt
\begin{equation*}
|x\rangle \rightarrow \frac{1}{\sqrt{N}} \sum_{y=0}^{N-1} \omega_{N}^{-x y}|y\rangle
\end{equation*}
!et

Thus the QFT is given by the matrix

!bt
\begin{equation*}
U_{Q F T}=\frac{1}{\sqrt{N}} \sum_{x=0}^{N-1} \sum_{y=0}^{N-1} \omega_{N}^{-y x}|y\rangle\langle x| 
\end{equation*}
!et

!split
===== Unitarity =====
The last  matrix is unitary. Let's check this:

!bt
\begin{align*}
U_{Q F T} U_{Q F T}^{\dagger} & =\frac{1}{N} \sum_{x=0}^{N-1} \sum_{y=0}^{N-1} \omega_{N}^{y x}|x\rangle\left\langle y\left|\sum_{x^{\prime}=0}^{N-1} \sum_{y^{\prime}=0}^{N-1} \omega_{N}^{-y^{\prime} x^{\prime}}\right| y^{\prime}\right\rangle\left\langle x^{\prime}\right| \\
& =\frac{1}{N} \sum_{x, y, x^{\prime}, y^{\prime}=0}^{N-1} \omega_{N}^{y x-y^{\prime} x^{\prime}} \delta_{y, y^{\prime}}|x\rangle\left\langle x^{\prime}\left|=\frac{1}{N} \sum_{x, y, x^{\prime}=0}^{N-1} \omega_{N}^{y\left(x-x^{\prime}\right)}\right| x\right\rangle\left\langle x^{\prime}\right| \\
& =\sum_{x, x^{\prime}=0}^{N-1} \delta_{x, x^{\prime}}|x\rangle\left\langle x^{\prime}\right|=I 
\end{align*}
!et

!split
===== Importance of QFT =====

The QFT is a very important transform in quantum computing. It can be
used for all sorts of cool tasks, including, as we shall see in Shor's
algorithm. But before we can use it for quantum computing tasks, we
should try to see if we can efficiently implement the QFT with a
quantum circuit. Indeed we can and the reason we can is intimately
related to the fast Fourier transform.


!split
===== Circuit QFT =====

Let's derive a circuit for the QFT when $N=2^{n}$. The QFT performs the transform

!bt
\begin{equation*}
|x\rangle \rightarrow \frac{1}{\sqrt{2^{n}}} \sum_{y=0}^{2^{n}-1} \omega_{N}^{-x y}|y\rangle 
\end{equation*}
!et

Then we can expand out this sum

!bt
\begin{equation*}
|x\rangle \rightarrow \frac{1}{\sqrt{2^{n}}} \sum_{y_{1}, y_{2}, \ldots, y_{n} \in\{0,1\}} \omega_{N}^{-x \sum_{k=1}^{n} 2^{n-k} y_{k}}\left|y_{1}, y_{2}, \ldots, y_{n}\right\rangle 
\end{equation*}
!et

!split
===== Expanding the exponential =====

Expanding the exponential of a sum to a product of exponentials and
collecting these terms in from the appropriate terms we can express
this as

!bt
\begin{equation*}
|x\rangle \rightarrow \frac{1}{\sqrt{2^{n}}} \sum_{y_{1}, y_{2}, \ldots, y_{n} \in\{0,1\}} \bigotimes_{k=1}^{n} \omega_{N}^{-x 2^{n-k} y_{k}}\left|y_{k}\right\rangle 
\end{equation*}
!et


!split
===== Rearranging =====

We can rearrange the sum and products as

!bt
\begin{equation*}
|x\rangle \rightarrow \frac{1}{\sqrt{2^{n}}} \bigotimes_{k=1}^{n}\left[\sum_{y_{k} \in\{0,1\}} \omega_{N}^{-x 2^{n-k} y_{k}}\left|y_{k}\right\rangle\right] 
\end{equation*}
!et

Expanding this sum yields

!bt
\begin{equation*}
|x\rangle \rightarrow \frac{1}{\sqrt{2^{n}}} \bigotimes_{k=1}^{n}\left[|0\rangle+\omega_{N}^{-x 2^{n-k}}|1\rangle\right]
\end{equation*}
!et

!split
===== Notation for binary fraction =====

But now notice that $\omega_{N}^{-x 2^{n-k}}$ is not dependent on the
higer order bits of $x$. It is convenient to adopt the following
expression for a binary fraction:

!bt
\begin{equation*}
0 . x_{l} x_{l+1} \ldots x_{n}=\frac{x_{l}}{2}+\frac{x_{l+1}}{4}+\cdots+\frac{x_{n}}{2^{n-l+1}}
\end{equation*}
!et

!split
===== More notations =====
Then we can see that

!bt
\begin{equation*}
|x\rangle \rightarrow \frac{1}{\sqrt{2^{n}}}\left[|0\rangle+e^{-2 \pi i 0 . x_{n}}|1\rangle\right] \otimes\left[|0\rangle+e^{-2 \pi i 0 . x_{n-1} x_{n}}|1\rangle\right] \otimes \cdots \otimes\left[|0\rangle+e^{-2 \pi i 0 . x_{1} x_{2} \cdots x_{n}}|1\rangle\right] 
\end{equation*}
!et

This is a very useful form of the QFT for $N=2^{n}$. Why? Because we
see that only the last qubit depends on the the values of all the
other input qubits and each further bit depends less and less on the
input qubits. Further we note that $e^{-2 \pi i 0 . a}$ is either +1
or -1 , which reminds us of the Hadamard transform.

!split
===== Deriving a circuit =====

So how do we use this to derive a circuit for the QFT over $N=2^{n}$ ?

Take the first qubit of $\left|x_{1}, \ldots, x_{n}\right\rangle$ and
apply a Hadamard transform. This produces the transform

!bt
\begin{equation*}
|x\rangle \rightarrow \frac{1}{\sqrt{2}}\left[|0\rangle+e^{-2 \pi i 0 \cdot x_{1}}|1\rangle\right] \otimes\left|x_{2}, x_{3}, \ldots, x_{n}\right\rangle 
\end{equation*}
!et

!split
===== Rotation gate =====
Now define the rotation gate

!bt
\[
R_{k}=\left[\begin{array}{cc}
1 & 0  \tag{30}\\
0 & \exp \left(\frac{-2 \pi i}{2^{k}}\right)
\end{array}\right]
\]
!et
If we now apply controlled $R_{2}, R_{3}$, etc. gates controlled on
the appropriate bits this enacts the transform

!bt
\begin{equation*}
|x\rangle \rightarrow \frac{1}{\sqrt{2}}\left[|0\rangle+e^{-2 \pi i 0 . x_{1} x_{2} \ldots x_{n}}|1\rangle\right] \otimes\left|x_{2}, x_{3}, \ldots, x_{n}\right\rangle 
\end{equation*}
!et

!split
===== Proceeding =====

Thus we have reproduced the last term in the QFTed state. Of course
now we can proceed to the second qubit, perform a Hadamard, and the
appropriate controlled $R_{k}$ gates and get the second to last
qubit. Thus when we are finished we will have the transform

!bt
\begin{equation*}
|x\rangle \rightarrow \frac{1}{\sqrt{2^{n}}}\left[|0\rangle+e^{-2 \pi i 0 . x_{1} x_{2} \cdots x_{n}}|1\rangle\right] \otimes\left[|0\rangle+e^{-2 \pi i 0 . x_{1} x_{2} \cdots x_{n-1}}|1\rangle\right] \otimes \cdots \otimes\left[|0\rangle+e^{-2 \pi i 0 . x_{n}}|1\rangle\right]
\end{equation*}
!et

Reversing the order of these qubits will then produce the QFT!

#The circuit we have constructed on $n$ qubits is


#\includegraphics[max width=\textwidth]{2024_03_18_c1d427fa6b85efa365f1g-5}


!split
===== Plans for the week of April 8-12 =====

o Finalize our discussion of QFTs
o Set up calculations of QFTs
o Implementing the phase estimation algorithm for finding eigenvalues



The discrete Fourier transform takes as input a complex vector
!bt
\begin{align*}
x = 
\begin{pmatrix}
x_0 \\ 
x_1 \\ 
x_2 \\
\vdots \\ 
x_{N-2} \\
x_{N-1}
\end{pmatrix}.
\end{align*}
!et
Each entry of the output vector \(y\) is given by

!bt
\begin{align}
y_k = \frac{1}{\sqrt{N}} \sum_{j=0}^{N-1} x_je^{2 \pi ijk/N}.
\end{align}
!et

The output is a complex vector

!bt
\begin{align*}
y = 
\frac{1}{\sqrt{N}}
\begin{pmatrix}
\sum_{j=0}^{N-1} x_je^{2\pi ij0/N} \\
\sum_{j=0}^{N-1} x_je^{2\pi ij1/N} \\
\sum_{j=0}^{N-1} x_je^{2\pi ij2/N} \\
\vdots \\
\sum_{j=0}^{N-1} x_je^{2\pi ij(N-2)/N} \\
\sum_{j=0}^{N-1} x_je^{2\pi ij(N-1)/N}
\end{pmatrix}
\end{align*}
!et


The Quantum Fourier Transform (QFT) has mathematically the same equation as starting point
but the notation is generally different. We generally compute the
quantum Fourier transform on a set of orthonormal basis state vectors
\(|0\rangle, |1\rangle, ..., |N-1\rangle\). The linear operator defining
the transform is given by the action on basis states

!bt
\begin{align}
|j\rangle \mapsto \frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} e^{2\pi ijk/N}|k\rangle.
\end{align}
!et
This can be written on arbitrary states,
!bt
\begin{align}
\sum_{j=0}^{N-1}x_j|j\rangle \mapsto \sum_{k=0}^{N-1} y_k|k\rangle
\end{align}
!et
where each amplitude \(y_k\) is the discrete Fourier transform of
\(x_j\). The quantum Fourier transform is unitary. Taking \(N = 2^n\),
for \(n\) qubits gives us the orthonormal (computational) basis

!bt
\begin{align}
|0\rangle, |1\rangle, ..., |2^{n}-1\rangle.
\end{align}
!et


Each of the computational basis states can be represented in binary
!bt
\begin{align}
j = j_1j_2 \cdots j_n
\end{align}
!et
where each \(j_k\) is either \(0\) or \(1\), and the corresponding
binary vector is \(|j_1j_2 \cdots j_n\rangle\).

The quantum Fourier
transform on one of these \(n\)-qubit vectors can be written as,

!bt
\begin{align}
|j_1j_2 \cdots j_n \rangle = \frac{\left(|0\rangle +e^{2\pi i0.j_n}|1\rangle\right) \otimes \left(|0\rangle +e^{2\pi i0.j_{n-1}j_n}|1\rangle\right) \otimes \cdots \otimes \left(|0\rangle +e^{2\pi i0.j_1j_2 \cdots j_n}|1\rangle\right)}{2^{n/2}}
\end{align}
!et

In the above, we use the notation

!bt
\begin{align}
0.j_lj_{l+1} \cdots j_n = \frac{j+l}{2} + \frac{j_{l+1}}{2^2} + \cdots + \frac{j_n}{2^{m-l+1}}
\end{align}
!et

First a two qubit system and write code for it as well.

Let's have a look at an example on a four qubit system. The basis states are,
!bt
\begin{align}
|j_1j_2j_3j_4 \rangle
\end{align}
!et
where \(j_k\) is either \(0\) or \(1\). We have,

!bt
\begin{align}
0.j_3 &= \frac{j_3}{2} \\
0.j_2j_3 &= \frac{j_2}{2} + \frac{j_3}{4} \\
0.j_1j_2j_3 &= \frac{j_1}{2} + \frac{j_2}{4} + \frac{j_3}{8} \\
0.j_0j_1j_2j_3 &= \frac{j_0}{2} + \frac{j_1}{4} + \frac{j_2}{8} + \frac{j_3}{16} \\
\end{align}
!et

The quantum Fourier transform acts as follows:

!bt
\begin{align}
|j_1j_2j_3j_4 \rangle \mapsto \frac{1}{\sqrt{2^{4/2}}}
\left(|0\rangle + e^{2 \pi i 0.j4}|1\rangle \right) \otimes 
\left(|0\rangle + e^{2 \pi i 0.j_3j4}|1\rangle \right) \otimes 
\left(|0\rangle + e^{2 \pi i 0.j_2j_3j4}|1\rangle \right) \otimes 
\left(|0\rangle + e^{2 \pi i 0.j_1j_2j_3j4}|1\rangle \right) 
\end{align}
!et

To compose a quantum circuit that calculates the quantum Fourier
transform we use the operators

!bt
\begin{align}
R_k = 
\begin{pmatrix}
1 & 0 \\
0 & e^{2\pi i/2^k}
\end{pmatrix}.
\end{align}
!et

The circuit computing the QFT on four qubits is given by,

In this example, the \(R_k\) gates are:
!bt
\begin{align}
R_1 = \begin{pmatrix}
1 & 0 \\
0 & e^{2 \pi i /2^0}
\end{pmatrix} = 
\begin{pmatrix}
1 & 0 \\
0 & 1
\end{pmatrix}, \quad 
R_2 = \begin{pmatrix}
1 & 0 \\
0 & e^{2 \pi i /2^2}
\end{pmatrix}, \quad 
R_3 = \begin{pmatrix}
1 & 0 \\
0 & e^{2 \pi i /2^3}
\end{pmatrix}, \quad 
R_4 = \begin{pmatrix}
1 & 0 \\
0 & e^{2 \pi i /2^4}
\end{pmatrix}.
\end{align}
!bt


\begin{quantikz}
\lstick{\ket{j_1}} \qw & \gate{H} & \gate{R_2} & \gate{R_3} & \gate{R_4} & \qw        & \qw      & \qw        & \qw      & \qw         & \qw & \qw \\
\lstick{\ket{j_2}} \qw & \qw      & \ctrl{-1}  & \qw        & \qw        & \gate{H} & \gate{R_2} & \gate{R_3} & \qw      & \qw         & \qw & \qw \\       
\lstick{\ket{j_3}} \qw & \qw      & \qw        & \ctrl{-2}  & \qw        & \qw      & \ctrl{-1}  & \qw        & \gate{H} & \gate{R_2}  & \qw & \qw \\
\lstick{\ket{j_4}} \qw & \qw      & \qw        & \qw        & \ctrl{-3}  & \qw      & \qw        & \ctrl{-2}  & \qw      & \ctrl{-1}   & \gate{H} & \qw
\end{quantikz}

    Since the \(R_1\) gate is simply the identity, it usually doesn't show
up in code or circuit diagrams as it does nothing to any of the qubits.
In general, we call the gate \(R_k\) for \(k=1, 2, 3, 4\) a
\(U_1\)-gate. The \(U_1\) gates are always of the form

!bt
\begin{align}
\begin{pmatrix}
1 & 0 \\
0 & e^{i \lambda}
\end{pmatrix}
\end{align}
!et
where \(\lambda\) is generally some angle \(\lambda = 2\pi/n\). For us
the angle is of the form \(\lambda = 2\pi/2^{k-1}\), where again,
\(k = 1, 2, 3, 4\) is the index of the gates \(R_k\). Now, in the
Quantum Fourier Transform we will need the controlled-\(U_1\) gates,

!bt
\begin{align}
|0\rangle \langle 0| \otimes I + |1\rangle \langle 1| \otimes U_1 =  
\begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 \\
0 & 0 & 1 & 0 \\
0 & 0 & 0 & e^{i \lambda}
\end{pmatrix}. 
\end{align}
!et

This of course operates on a two-qubit system, so modifying it for a
four-qubit system means the matrix will be a little different. The term
\(|0\rangle \langle 0| \otimes I\) always operates on the control qubit,
and the term \(|1\rangle \langle 1| \otimes U_1\) always operates on the
target qubit. As an example in a four qubit system, we might have the
first qubit be the target qubit, and the fourth qubit the control qubit.
In this case we would have an operator:

!bt
\begin{align}
\left(|0\rangle \langle 0| \otimes U_1 \otimes I \otimes I\right) + \left(|1\rangle \langle 1| \otimes I \otimes I \otimes I\right)
\end{align}
!et
This would apply the \(U_1\) gate to the first qubit, with the control
gate on the fourth qubit, and the identity gates on the second and third
qubit. The more general circuit for \(n\) qubits has layers that are
similar.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Draw the quantum circuit that computes the quantum Fourier transform
  on two qubits.
\item
  Use Python to define the following gate:
\end{enumerate}

\begin{align}
CS = \begin{pmatrix}
S & 0 \\
0 & X 
\end{pmatrix} = 
\begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & e^{2 \pi i/2^2} & 0 & 0 \\
0 & 0 & 0 & 1 \\
0 & 0 & 1 & 0
\end{pmatrix} = 
\begin{pmatrix}
1 & 0 & 0 & 0 \\
0 & i & 0 & 0 \\
0 & 0 & 0 & 1 \\
0 & 0 & 1 & 0
\end{pmatrix}
\end{align}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Use Python to define the four basis states \(|00\rangle\),
  \(|01\rangle\), \(|10\rangle\), and \(|11\rangle\) as four dimensional
  unit vectors. For example,
\end{enumerate}

\begin{align}
|00\rangle = 
\begin{pmatrix}
1 \\
0 \\
0 \\
0
\end{pmatrix}
\end{align}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  Define the gate \(H \otimes I\) and \(I \otimes H\) in Python, where
  \(H\) is the Hadamard gate.
\item
  Use the gates and basis states above to compute the quantum Fourier
  transform on the four basis states.
\item
  Draw the quantum circuit that computes the quantum Fourier transform
  on three qubits.
\end{enumerate}

    In general, we can write the quantum Fourier transform as a matrix
operator,

\begin{align}
F_N = \frac{1}{\sqrt{N}}
\begin{pmatrix}
1 & 1 & 1 & 1 & \cdots & 1 \\
1 & \omega & \omega^2 & \omega^3 & \cdots & \omega^{N-1} \\
1 & \omega^2 & \omega^4 & \omega^6 & \cdots & \omega^{2(N-1)} \\
1 & \omega^3 & \omega^6 & \omega^9 & \cdots & \omega^{3(N-1)} \\
\vdots & \vdots & \vdots & \vdots & \ddots & \vdots \\
1 & \omega^{N-1} & \omega^{2(N-1)} & \omega^{3(N-1)} & \cdots & \omega^{(N-1)(N-1)}
\end{pmatrix}
\end{align}

where \(\omega = e^{2 \pi i/N}\). As an example, we can write the two
qubit QFT as

\begin{align}
F_4 = \frac{1}{2}
\begin{pmatrix}
1 & 1 & 1 & 1 \\
1 & i & -1 & -i \\
1 & -1 & 1 & -1 \\
1 & -i & -1 & i
\end{pmatrix}
\end{align}

    We can define the four basis states
\(|00\rangle, |01\rangle, |10\rangle, |00\rangle\) and \(F_4\) in
Python:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{2}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{u} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{matrix}\PY{p}{(}\PY{p}{[}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,}
               \PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{]}\PY{p}{)}

\PY{n}{d} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{matrix}\PY{p}{(}\PY{p}{[}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}
               \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{]}\PY{p}{)}

\PY{n}{dd} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{kron}\PY{p}{(}\PY{n}{d}\PY{p}{,}\PY{n}{d}\PY{p}{)}
\PY{n}{du} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{kron}\PY{p}{(}\PY{n}{d}\PY{p}{,}\PY{n}{u}\PY{p}{)}
\PY{n}{ud} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{kron}\PY{p}{(}\PY{n}{u}\PY{p}{,}\PY{n}{d}\PY{p}{)}
\PY{n}{uu} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{kron}\PY{p}{(}\PY{n}{u}\PY{p}{,}\PY{n}{u}\PY{p}{)}

\PY{n}{F} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{matrix}\PY{p}{(}\PY{p}{[}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,}
               \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{n}{j}\PY{p}{,}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{n}{j}\PY{p}{]}\PY{p}{,}
               \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,}
               \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{n}{j}\PY{p}{,}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{n}{j}\PY{p}{]}\PY{p}{]}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{3}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n+nb}{print}\PY{p}{(}\PY{n}{F}\PY{o}{*}\PY{n}{dd}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
[[ 1.+0.j]
 [ 0.-1.j]
 [-1.+0.j]
 [ 0.+1.j]]
    \end{Verbatim}

    \begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{6}
\tightlist
\item
  Compute \(F_4(|01\rangle)\).
\item
  Compute \(F_4(|10\rangle)\).
\item
  Compute \(F_4(|00\rangle)\).
\item
  Write down the three qubit quantum Fourier transform \(F_8\) in matrix
  form.
\end{enumerate}

    \subsection{The Quantum Fourier Transform in
Qiskit}\label{the-quantum-fourier-transform-in-qiskit}

    \subsubsection{Imports and Dependencies}\label{imports-and-dependencies}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{4}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{pip} \PY{n}{install} \PY{n}{qiskit}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Requirement already satisfied: qiskit in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (0.13.0)
Requirement already satisfied: qiskit-aqua==0.6.1 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from qiskit)
(0.6.1)
Requirement already satisfied: qiskit-ibmq-provider==0.3.3 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from qiskit)
(0.3.3)
Requirement already satisfied: qiskit-terra==0.10.0 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from qiskit)
(0.10.0)
Requirement already satisfied: qiskit-aer==0.3.2 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from qiskit)
(0.3.2)
Requirement already satisfied: qiskit-ignis==0.2.0 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from qiskit)
(0.2.0)
Requirement already satisfied: psutil>=5 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from qiskit-
aqua==0.6.1->qiskit) (5.6.3)
Requirement already satisfied: numpy>=1.13 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from qiskit-
aqua==0.6.1->qiskit) (1.18.0)
Requirement already satisfied: jsonschema>=2.6 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from qiskit-
aqua==0.6.1->qiskit) (3.0.1)
Requirement already satisfied: docplex in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from qiskit-
aqua==0.6.1->qiskit) (2.11.176)
Requirement already satisfied: quandl in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from qiskit-
aqua==0.6.1->qiskit) (3.4.8)
Requirement already satisfied: dlx in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from qiskit-
aqua==0.6.1->qiskit) (1.0.4)
Requirement already satisfied: sympy>=1.3 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from qiskit-
aqua==0.6.1->qiskit) (1.4)
Requirement already satisfied: networkx>=2.2 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from qiskit-
aqua==0.6.1->qiskit) (2.3)
Requirement already satisfied: setuptools>=40.1.0 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from qiskit-
aqua==0.6.1->qiskit) (41.0.1)
Requirement already satisfied: fastdtw in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from qiskit-
aqua==0.6.1->qiskit) (0.3.4)
Requirement already satisfied: scikit-learn>=0.20.0 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from qiskit-
aqua==0.6.1->qiskit) (0.22)
Requirement already satisfied: cvxopt in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from qiskit-
aqua==0.6.1->qiskit) (1.2.3)
Requirement already satisfied: h5py in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from qiskit-
aqua==0.6.1->qiskit) (2.9.0)
Requirement already satisfied: pyscf; sys\_platform != "win32" in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from qiskit-
aqua==0.6.1->qiskit) (1.6.5)
Requirement already satisfied: scipy>=1.0 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from qiskit-
aqua==0.6.1->qiskit) (1.4.1)
Requirement already satisfied: websockets<8,>=7 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from qiskit-ibmq-
provider==0.3.3->qiskit) (7.0)
Requirement already satisfied: nest-asyncio==1.0.0 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from qiskit-ibmq-
provider==0.3.3->qiskit) (1.0.0)
Requirement already satisfied: requests>=2.19 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from qiskit-ibmq-
provider==0.3.3->qiskit) (2.22.0)
Requirement already satisfied: requests-ntlm>=1.1.0 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from qiskit-ibmq-
provider==0.3.3->qiskit) (1.1.0)
Requirement already satisfied: marshmallow<4,>=3 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from qiskit-
terra==0.10.0->qiskit) (3.3.0)
Requirement already satisfied: ply>=3.10 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from qiskit-
terra==0.10.0->qiskit) (3.11)
Requirement already satisfied: marshmallow-polyfield<6,>=5.7 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from qiskit-
terra==0.10.0->qiskit) (5.7)
Requirement already satisfied: attrs>=17.4.0 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from
jsonschema>=2.6->qiskit-aqua==0.6.1->qiskit) (19.1.0)
Requirement already satisfied: pyrsistent>=0.14.0 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from
jsonschema>=2.6->qiskit-aqua==0.6.1->qiskit) (0.14.11)
Requirement already satisfied: six>=1.11.0 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from
jsonschema>=2.6->qiskit-aqua==0.6.1->qiskit) (1.12.0)
Requirement already satisfied: docloud>=1.0.375 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from
docplex->qiskit-aqua==0.6.1->qiskit) (1.0.375)
Requirement already satisfied: more-itertools<=5.0.0 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from
quandl->qiskit-aqua==0.6.1->qiskit) (5.0.0)
Requirement already satisfied: pandas>=0.14 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from
quandl->qiskit-aqua==0.6.1->qiskit) (0.24.2)
Requirement already satisfied: pyasn1 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from
quandl->qiskit-aqua==0.6.1->qiskit) (0.4.8)
Requirement already satisfied: inflection>=0.3.1 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from
quandl->qiskit-aqua==0.6.1->qiskit) (0.3.1)
Requirement already satisfied: pyOpenSSL in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from
quandl->qiskit-aqua==0.6.1->qiskit) (19.0.0)
Requirement already satisfied: python-dateutil in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from
quandl->qiskit-aqua==0.6.1->qiskit) (2.8.0)
Requirement already satisfied: ndg-httpsclient in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from
quandl->qiskit-aqua==0.6.1->qiskit) (0.5.1)
Requirement already satisfied: mpmath>=0.19 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from
sympy>=1.3->qiskit-aqua==0.6.1->qiskit) (1.1.0)
Requirement already satisfied: decorator>=4.3.0 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from
networkx>=2.2->qiskit-aqua==0.6.1->qiskit) (4.4.0)
Requirement already satisfied: joblib>=0.11 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from scikit-
learn>=0.20.0->qiskit-aqua==0.6.1->qiskit) (0.13.2)
Requirement already satisfied: idna<2.9,>=2.5 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from
requests>=2.19->qiskit-ibmq-provider==0.3.3->qiskit) (2.8)
Requirement already satisfied: certifi>=2017.4.17 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from
requests>=2.19->qiskit-ibmq-provider==0.3.3->qiskit) (2020.4.5.1)
Requirement already satisfied: chardet<3.1.0,>=3.0.2 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from
requests>=2.19->qiskit-ibmq-provider==0.3.3->qiskit) (3.0.4)
Requirement already satisfied: urllib3!=1.25.0,!=1.25.1,<1.26,>=1.21.1 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from
requests>=2.19->qiskit-ibmq-provider==0.3.3->qiskit) (1.24.2)
Requirement already satisfied: ntlm-auth>=1.0.2 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from requests-
ntlm>=1.1.0->qiskit-ibmq-provider==0.3.3->qiskit) (1.4.0)
Requirement already satisfied: cryptography>=1.3 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from requests-
ntlm>=1.1.0->qiskit-ibmq-provider==0.3.3->qiskit) (2.7)
Requirement already satisfied: pytz>=2011k in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from
pandas>=0.14->quandl->qiskit-aqua==0.6.1->qiskit) (2019.1)
Requirement already satisfied: cffi!=1.11.3,>=1.8 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from
cryptography>=1.3->requests-ntlm>=1.1.0->qiskit-ibmq-provider==0.3.3->qiskit)
(1.12.3)
Requirement already satisfied: asn1crypto>=0.21.0 in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from
cryptography>=1.3->requests-ntlm>=1.1.0->qiskit-ibmq-provider==0.3.3->qiskit)
(0.24.0)
Requirement already satisfied: pycparser in
/Users/amelieschreiber/anaconda3/lib/python3.7/site-packages (from
cffi!=1.11.3,>=1.8->cryptography>=1.3->requests-ntlm>=1.1.0->qiskit-ibmq-
provider==0.3.3->qiskit) (2.19)
Note: you may need to restart the kernel to use updated packages.
    \end{Verbatim}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{5}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{matplotlib}\PY{n+nn}{.}\PY{n+nn}{pyplot} \PY{k}{as} \PY{n+nn}{plt}
\PY{o}{\PYZpc{}}\PY{k}{matplotlib} inline
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}
\PY{k+kn}{from} \PY{n+nn}{math} \PY{k+kn}{import} \PY{n}{pi}
\PY{k+kn}{from} \PY{n+nn}{qiskit} \PY{k+kn}{import} \PY{o}{*}
\end{Verbatim}
\end{tcolorbox}

    First, let's define a quantum register.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{6}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{q} \PY{o}{=} \PY{n}{QuantumRegister}\PY{p}{(}\PY{l+m+mi}{4}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Now, we can define the quantum circuit with four qubits for the Quantum
Fourier Transform. We include barriers between sequences of gates
according to the target qubit for the controlled-\(U_1\) gates given by
the four matrices

\begin{align}
R_1 = \begin{pmatrix}
1 & 0 \\
0 & e^{2 \pi i /2^0}
\end{pmatrix} = 
\begin{pmatrix}
1 & 0 \\
0 & 1
\end{pmatrix}, \quad 
R_2 = \begin{pmatrix}
1 & 0 \\
0 & e^{2 \pi i /2^2}
\end{pmatrix}, \quad 
R_3 = \begin{pmatrix}
1 & 0 \\
0 & e^{2 \pi i /2^3}
\end{pmatrix}, \quad 
R_4 = \begin{pmatrix}
1 & 0 \\
0 & e^{2 \pi i /2^4}
\end{pmatrix}.
\end{align}

    So, for example, have a barrier between the first sequence of gates
\(H, R_2, R_3, R_4\) and the second sequence of gates \(H, R_2, R_3\).
Without the barriers, the gates sometimes print out in a different order
(try it) which can make reading the circuit diagram printout a little
more confusing. Again, since the \(R_1\) gate is simply the identity, it
usually doesn't show up in code or circuit diagrams as it does nothing
to any of the qubits.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{7}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{qc} \PY{o}{=} \PY{n}{QuantumCircuit}\PY{p}{(}\PY{n}{q}\PY{p}{)}
\PY{c+c1}{\PYZsh{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}
\PY{n}{qc}\PY{o}{.}\PY{n}{h}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{)}
\PY{n}{qc}\PY{o}{.}\PY{n}{cu1}\PY{p}{(}\PY{n}{pi}\PY{o}{/}\PY{l+m+mi}{2}\PY{p}{,}\PY{n}{q}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,}\PY{n}{q}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)}
\PY{n}{qc}\PY{o}{.}\PY{n}{cu1}\PY{p}{(}\PY{n}{pi}\PY{o}{/}\PY{l+m+mi}{4}\PY{p}{,}\PY{n}{q}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,}\PY{n}{q}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)}
\PY{n}{qc}\PY{o}{.}\PY{n}{cu1}\PY{p}{(}\PY{n}{pi}\PY{o}{/}\PY{l+m+mi}{8}\PY{p}{,}\PY{n}{q}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]}\PY{p}{,}\PY{n}{q}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)}
\PY{c+c1}{\PYZsh{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}
\PY{n}{qc}\PY{o}{.}\PY{n}{barrier}\PY{p}{(}\PY{p}{)}
\PY{n}{qc}\PY{o}{.}\PY{n}{h}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{)}
\PY{n}{qc}\PY{o}{.}\PY{n}{cu1}\PY{p}{(}\PY{n}{pi}\PY{o}{/}\PY{l+m+mi}{2}\PY{p}{,}\PY{n}{q}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,}\PY{n}{q}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}
\PY{n}{qc}\PY{o}{.}\PY{n}{cu1}\PY{p}{(}\PY{n}{pi}\PY{o}{/}\PY{l+m+mi}{4}\PY{p}{,}\PY{n}{q}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]}\PY{p}{,}\PY{n}{q}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}
\PY{c+c1}{\PYZsh{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}
\PY{n}{qc}\PY{o}{.}\PY{n}{barrier}\PY{p}{(}\PY{p}{)}
\PY{n}{qc}\PY{o}{.}\PY{n}{h}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{)}
\PY{n}{qc}\PY{o}{.}\PY{n}{cu1}\PY{p}{(}\PY{n}{pi}\PY{o}{/}\PY{l+m+mi}{2}\PY{p}{,}\PY{n}{q}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]}\PY{p}{,}\PY{n}{q}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{)}
\PY{c+c1}{\PYZsh{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}
\PY{n}{qc}\PY{o}{.}\PY{n}{barrier}\PY{p}{(}\PY{p}{)}
\PY{n}{qc}\PY{o}{.}\PY{n}{h}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{)}
\PY{c+c1}{\PYZsh{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}
\PY{n}{qc}\PY{o}{.}\PY{n}{draw}\PY{p}{(}\PY{n}{output}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{mpl}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}
 
            
\prompt{Out}{outcolor}{7}{}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_31_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    

    Now, we can define a device (or backend) to run the circuit on, create a
quantum program for execution, and store the result of the job we
executed.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{8}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Import Aer}
\PY{k+kn}{from} \PY{n+nn}{qiskit} \PY{k+kn}{import} \PY{n}{Aer}

\PY{c+c1}{\PYZsh{} Run the quantum circuit on a statevector simulator backend}
\PY{n}{backend} \PY{o}{=} \PY{n}{Aer}\PY{o}{.}\PY{n}{get\PYZus{}backend}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{statevector\PYZus{}simulator}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{9}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Create a Quantum Program for execution}
\PY{n}{job} \PY{o}{=} \PY{n}{execute}\PY{p}{(}\PY{n}{qc}\PY{p}{,} \PY{n}{backend}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{10}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{result} \PY{o}{=} \PY{n}{job}\PY{o}{.}\PY{n}{result}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Now, we can print the state vector that results from running this
circuit.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{11}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{outputstate} \PY{o}{=} \PY{n}{result}\PY{o}{.}\PY{n}{get\PYZus{}statevector}\PY{p}{(}\PY{n}{qc}\PY{p}{,} \PY{n}{decimals}\PY{o}{=}\PY{l+m+mi}{3}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{outputstate}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
[0.25+0.j 0.25+0.j 0.25+0.j 0.25+0.j 0.25+0.j 0.25+0.j 0.25+0.j 0.25+0.j
 0.25+0.j 0.25+0.j 0.25+0.j 0.25+0.j 0.25+0.j 0.25+0.j 0.25+0.j 0.25+0.j]
    \end{Verbatim}

    This is a \(2^4=16\) dimensional vector, which is expected since we are
working with a four-qubit quantum circuit.

    \subsubsection{Exercises}\label{exercises}

    \begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Define a QuantumRegister in QISKit with three qubits.
\item
  Define the Quantum Fourier Transform circuit for this three qubit
  system and draw the output circuit. Be sure to use barriers in the
  appropriate places. You will only need two controlled-\(U_1\) gates.
  They correspond to the following gates,
\end{enumerate}

\begin{align}
R_2 = \begin{pmatrix}
1 & 0 \\
0 & e^{2 \pi i /2^2}
\end{pmatrix}, \quad 
R_3 = \begin{pmatrix}
1 & 0 \\
0 & e^{2 \pi i /2^3}
\end{pmatrix}
\end{align}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Define a device (or backend) to run this circuit on using Aer, create
  a job, store the result, and print the state vector that results from
  running this circuit.
\end{enumerate}

    \subsection{Applications}\label{applications}

    The Quantum Fourier Transform, which is essentially a discrete Fourier
transform, has many applications. One thing to note is that quantum
computers can implement the Quantum Fourier Transform using \(O(n^2)\)
gates. The best classical algorithms for implementing a disctrete
Fourier transform on \(2^n\) elements are algorithms like the
\textbf{\href{https://en.wikipedia.org/wiki/Fast_Fourier_transform}{Fast
Fourier Transform}}, which computes the disctrete Fourier transform on
\(2^n\) elements in \(O(n2^n)>>O(n^2)\) logic gates, much greater than
the \(O(n^2)\) gates for a quantum computer computing the QFT. So, we
use exponentially more gates on a classical computer. Finding
applications of this exponential speedup then should be considered
highly important.

    \subsubsection{Phase Estimation}\label{phase-estimation}

    Phase estimation is described by Nielson and Chuang (pg. 245) as
follows.

\begin{quote}
``Let \(|u\rangle\) be an eigenstate of some unitary operator \(U\),
with eigenvalue \(e^{2\pi i \phi}\). Starting from the initial state
\(|0\rangle^{\otimes t}|u\rangle\), and given the ability to efficiently
perform \(U^{2^k}\) for some integer \(k\), this algorithm can be used
to efficiently obtain state \(|\tilde{\phi}\rangle |u\rangle\), where
\(\tilde{\phi}\) accurately approximates \(\phi\) to
\(t-\lceil \log(2+\frac{1}{2\epsilon}) \rceil\) bits with probability at
least \(1 - \epsilon\).''
\end{quote}

    The schematic for the phase estimation circuit is:

    \begin{figure}
\centering
\includegraphics{phase_estimation_1.png}
\caption{phase\_estimation\_1.png}
\end{figure}

    \begin{quantikz}
\lstick{$\ket{0}^{\otimes t}$} & \gate{H^j} \qwbundle{t} & \ctrl{1} & \gate{FT^{\dagger}} & \meter{} & \\
\lstick{$\ket{u}^{\otimes m}$} & \qw \qwbundle{m}        & \gate{U^{2^j}} & \qw       & \qw  & \qw \ket{u}
\end{quantikz}

    The gate \(FT^{\dagger}\) is the inverse Quantum Fourier Transform. The
top wire represents \(t\)-qubits and is actually a bundle of
\(t\)-wires, with qubits in the initial state \(|0\rangle\). The bottom
wire is again a bundle of \(m\)-wires on \(m\)-qubits in state
\(|u\rangle\), the eigenstate of the unitary operator \(U\) with
eigenvalue \(e^{2 \pi i \phi}\). The operator \(H^j = H^{\otimes t}\) is
meant to indicate a series (or tensor product) of Hadamard gates on the
first \(j = 1, 2, ..., t\) qubits, and the controlled-\(U^j\) gate is
meant to indicate the application of successive controlled-\(U^j\) gates
for \(2^j = 2^0, 2^1, 2^2, ..., 2^{t-1}\). This notation might be a bit
confusing so let's look at an example with \(t=3\) qubits on the first
register, and the same number on the second register. The first part of
the circuit, prior to the Quantum Fourier Transform is as follws:

    \begin{figure}
\centering
\includegraphics{phase_est_3_qubits.png}
\caption{phase\_est\_3\_qubits.png}
\end{figure}

    \begin{quantikz}
\lstick{$\ket{0}$} & \gate{H} & \qw        & \qw      & \ctrl{3} & \qw \ket{0} + e^{2 \pi i (2^2 \phi)}\ket{1}\\
\lstick{$\ket{0}$} & \gate{H} & \qw        & \ctrl{2} & \qw      & \qw \ket{0} + e^{2 \pi i (2^1 \phi)}\ket{1}\\
\lstick{$\ket{0}$} & \gate{H} & \ctrl{1}   & \qw      & \qw      & \qw \ket{0} + e^{2 \pi i (2^0 \phi)}\ket{1} \\
\lstick{$\ket{u}$} & \qw  \qwbundle[alternate]{} & \gate{U^{2^0}} \qwbundle[
alternate]{} & \gate{U^{2^1}} \qwbundle[
alternate]{} & \gate{U^{2^2}} \qwbundle[
alternate]{} & \qwbundle[
alternate]{} \ket{u}
\end{quantikz}

    The superposition states on the right hand side must also be multiplied
by a normalization factor of \(1/2^{3/2}\). The next part of the circuit
applies the \emph{inverse} Quantum Fourier Transform \(FT^{\dagger}\) to
the first three qubits. This circuit will work for phase estimation
using a unitary operator \(U\) that is \(2^3 \times 2^3 = 8 \times 8\).
We can devise a somewhat simpler example for a smaller controlled \(U\)
by choosing

\begin{align}
U_1 = 
\begin{pmatrix}
1 & 0 \\
0 & e^{i \lambda}
\end{pmatrix}
\end{align}

Let's have a look at how to construct the first part of this circuit in
QISKit for this choice of \(U\). First, let's define a four-qubit
quantum register, with a three-bit classical register, and apply a
Hadamard gate to the first three qubits, followed by a barrier.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{12}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{qr} \PY{o}{=} \PY{n}{QuantumRegister}\PY{p}{(}\PY{l+m+mi}{4}\PY{p}{)}
\PY{n}{cr} \PY{o}{=} \PY{n}{ClassicalRegister}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{13}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{qc2} \PY{o}{=} \PY{n}{QuantumCircuit}\PY{p}{(}\PY{n}{qr}\PY{p}{,} \PY{n}{cr}\PY{p}{)}
\PY{c+c1}{\PYZsh{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}
\PY{n}{qc2}\PY{o}{.}\PY{n}{h}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{)}
\PY{n}{qc2}\PY{o}{.}\PY{n}{h}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{)}
\PY{n}{qc2}\PY{o}{.}\PY{n}{h}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{)}
\PY{n}{qc2}\PY{o}{.}\PY{n}{barrier}\PY{p}{(}\PY{p}{)}
\PY{c+c1}{\PYZsh{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}
\PY{n}{qc2}\PY{o}{.}\PY{n}{draw}\PY{p}{(}\PY{n}{output}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{mpl}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}
 
            
\prompt{Out}{outcolor}{13}{}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_53_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    

    Now, we need to apply the controlled-\(U_1\) gate a total of
\(2^3-1 = 7\) times to the fourth qubit, with the control qubit going
sequentially upward along the third, second, and first qubit. Each time
we step up a qubit, we apply the controlled-\(U_1\) gate twice as many
times. Let's choose a value of \(\lambda = \pi/2\).

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{14}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{qc2}\PY{o}{.}\PY{n}{cu1}\PY{p}{(}\PY{n}{pi}\PY{o}{/}\PY{l+m+mi}{2}\PY{p}{,}\PY{n}{qr}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,}\PY{n}{qr}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]}\PY{p}{)}
\PY{n}{qc2}\PY{o}{.}\PY{n}{cu1}\PY{p}{(}\PY{n}{pi}\PY{o}{/}\PY{l+m+mi}{2}\PY{p}{,}\PY{n}{qr}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,}\PY{n}{qr}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]}\PY{p}{)}
\PY{n}{qc2}\PY{o}{.}\PY{n}{cu1}\PY{p}{(}\PY{n}{pi}\PY{o}{/}\PY{l+m+mi}{2}\PY{p}{,}\PY{n}{qr}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,}\PY{n}{qr}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]}\PY{p}{)}
\PY{n}{qc2}\PY{o}{.}\PY{n}{cu1}\PY{p}{(}\PY{n}{pi}\PY{o}{/}\PY{l+m+mi}{2}\PY{p}{,}\PY{n}{qr}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}\PY{n}{qr}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]}\PY{p}{)}
\PY{n}{qc2}\PY{o}{.}\PY{n}{cu1}\PY{p}{(}\PY{n}{pi}\PY{o}{/}\PY{l+m+mi}{2}\PY{p}{,}\PY{n}{qr}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}\PY{n}{qr}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]}\PY{p}{)}
\PY{n}{qc2}\PY{o}{.}\PY{n}{cu1}\PY{p}{(}\PY{n}{pi}\PY{o}{/}\PY{l+m+mi}{2}\PY{p}{,}\PY{n}{qr}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}\PY{n}{qr}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]}\PY{p}{)}
\PY{n}{qc2}\PY{o}{.}\PY{n}{cu1}\PY{p}{(}\PY{n}{pi}\PY{o}{/}\PY{l+m+mi}{2}\PY{p}{,}\PY{n}{qr}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}\PY{n}{qr}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]}\PY{p}{)}
\PY{n}{qc2}\PY{o}{.}\PY{n}{barrier}\PY{p}{(}\PY{p}{)}
\PY{n}{qc2}\PY{o}{.}\PY{n}{draw}\PY{p}{(}\PY{n}{output}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{mpl}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}
 
            
\prompt{Out}{outcolor}{14}{}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_55_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    

    As we can see, we applied the controlled-\(U_1\) gate \(2^0 = 1\) time
with the control qubit equal to the thrid qubit. We then applied the
controlled-\(U_1\) gate \(2^1 = 2\) times to with the control qubit
equal to the second qubit. Finally, we applied it \(2^2 = 4\) times with
the control qubit equal to the first qubit. The next part of the
algorithm is to apply the \emph{inverse} Quantum Fourier transform to
the first three qubits. Let's build this circuit separately and then we
can simple adjoin it to our circuit \texttt{qc2} above. First, let's
import \texttt{math}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{15}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{math}
\end{Verbatim}
\end{tcolorbox}

    Next, we define a \texttt{QuantumCircuit()} with the same four-qubit
quantum register and three-qubit classical register as the circuit
\texttt{qc2}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{16}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{qc3} \PY{o}{=} \PY{n}{QuantumCircuit}\PY{p}{(}\PY{n}{qr}\PY{p}{,} \PY{n}{cr}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Now, we are going to define a function that performs the \emph{inverse}
Quantum Fourier Transform for a given circuit \texttt{circ} and for the
first n-qubits in \texttt{circ}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{17}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{qft\PYZus{}dagger}\PY{p}{(}\PY{n}{circ}\PY{p}{,} \PY{n}{n}\PY{p}{)}\PY{p}{:}
\PY{+w}{    }\PY{l+s+sd}{\PYZdq{}\PYZdq{}\PYZdq{}n\PYZhy{}qubit QFTdagger the first n qubits in circ\PYZdq{}\PYZdq{}\PYZdq{}}
    \PY{c+c1}{\PYZsh{} Don\PYZsq{}t forget the Swaps!}
    \PY{k}{for} \PY{n}{qubit} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{n}\PY{o}{/}\PY{o}{/}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{:}
        \PY{n}{circ}\PY{o}{.}\PY{n}{swap}\PY{p}{(}\PY{n}{qubit}\PY{p}{,} \PY{n}{n}\PY{o}{\PYZhy{}}\PY{n}{qubit}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)}
    \PY{k}{for} \PY{n}{j} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{n}\PY{p}{)}\PY{p}{:}
        \PY{k}{for} \PY{n}{m} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{j}\PY{p}{)}\PY{p}{:}
            \PY{n}{circ}\PY{o}{.}\PY{n}{cu1}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{n}{math}\PY{o}{.}\PY{n}{pi}\PY{o}{/}\PY{n+nb}{float}\PY{p}{(}\PY{l+m+mi}{2}\PY{o}{*}\PY{o}{*}\PY{p}{(}\PY{n}{j}\PY{o}{\PYZhy{}}\PY{n}{m}\PY{p}{)}\PY{p}{)}\PY{p}{,} \PY{n}{m}\PY{p}{,} \PY{n}{j}\PY{p}{)}
        \PY{n}{circ}\PY{o}{.}\PY{n}{h}\PY{p}{(}\PY{n}{j}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Okay, now we apply this function to our circuit \texttt{qc3} defined
above on the first \(n=3\) qubits.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{18}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{qc3}\PY{o}{.}\PY{n}{barrier}\PY{p}{(}\PY{p}{)}
\PY{c+c1}{\PYZsh{} Apply inverse QFT}
\PY{n}{qft\PYZus{}dagger}\PY{p}{(}\PY{n}{qc3}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
\PY{c+c1}{\PYZsh{} Measure}
\PY{n}{qc3}\PY{o}{.}\PY{n}{barrier}\PY{p}{(}\PY{p}{)}
\PY{k}{for} \PY{n}{n} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{)}\PY{p}{:}
    \PY{n}{qc3}\PY{o}{.}\PY{n}{measure}\PY{p}{(}\PY{n}{n}\PY{p}{,}\PY{n}{n}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Now, let's draw our circuit.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{19}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{qc3}\PY{o}{.}\PY{n}{draw}\PY{p}{(}\PY{n}{output}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{mpl}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}
 
            
\prompt{Out}{outcolor}{19}{}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_65_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    

    Okay, finally let's adjoin \texttt{qc3} to the end of \texttt{qc2} and
then draw the resulting circuit.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{20}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{circuit} \PY{o}{=} \PY{n}{qc2}\PY{o}{+}\PY{n}{qc3}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{21}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{circuit}\PY{o}{.}\PY{n}{draw}\PY{p}{(}\PY{n}{output}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{mpl}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}
 
            
\prompt{Out}{outcolor}{21}{}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_68_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    

    \subsubsection{Exercises}\label{exercises}

Now, for our circuit \texttt{circuit} which was \texttt{qc2+qc3} we
chose an eigenstate \(|u\rangle = |0\rangle\) for the controlled-\(U_1\)
gate. However, we could have also chosen the eigenvector \(|1\rangle\),
with has eigenvalue \(e^{i \lambda}\) with out choice of
\(\lambda = \pi/2\).

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Reconstruct the circuit above for phase estimation, but for
  \(|u\rangle = |1\rangle\). To do this, you will need to flip the
  spin-up state \(|0\rangle\) into the spin-down state \(|1\rangle\).
  Which gate operation will you need to apply in order to initialize the
  fourth qubit to be in state \(|1\rangle\)?
\item
  Recall, for \(t\) qubits we can estimate the value \(\phi\) for the
  eigenvalue \(e^{2 \pi i \phi}\) with accuracy
  \(t-\lceil \log(2+\frac{1}{2\epsilon}) \rceil\). Compute the accuracy
  we achieve with the above circuit (\(t=3\)).
\item
  Compute the accuracy if we have \(t=4\) qubits. For an example of the
  accuracy improvement for different choices of \(U\) see the
  \href{https://qiskit.org/textbook/ch-algorithms/quantum-phase-estimation.html}{Qiskit
  documentation}.
\end{enumerate}

    \subsubsection{Order-Finding and
Factoring}\label{order-finding-and-factoring}

    The phase estimation algorithm can be used to solve two important
problems, \textbf{order-finding} and \textbf{factoring}. Efficient
implementations of these two applications can be used to break RSA
public-key cryptography. These two applications, according to Nielson
and Chuange (pg. 226), provide evidence that quantum computers may be
inherently more powerful than classical computers and they give reason
to doubt the strong Church-Turing thesis.

To understand order-finding we need some basic number theory. Let \(x\)
and \(N\) be positive integers with no common factors. We define the
\textbf{order of \(x\) modulo \(N\)} to be the smallest positive integer
\(r\) such that

\begin{align}
x^r = 1 (\textbf{mod} \ N).
\end{align}

    Finding the order \(r\) of two given integers \(x\) and \(N\) is
believed to be hard. In particular, there is no known algorithm that can
solve the problem with a polynomial amount of resources in the \(O(L)\)
bits needed to specify the problem. Here, \(L = \lceil \log(N) \rceil\)
is the number of bits used to specify the integer \(N\). Now, the
quantum algorithm used to for order-finding is the phase estimation
algorithm applied to the unitary operator

\begin{align}
U|y\rangle = |xy (\textbf{mod} \ N)\rangle, 
\end{align}

where \(y \in \{0,1\}^L\). The eigenstates of the operator \(U\) are,

\begin{align}
|u_s\rangle = \frac{1}{\sqrt{r}} \sum_{k=0}^{r-1}e^{(-2\pi i sk)/r}|x^k (\textbf{mod} \ N)\rangle. 
\end{align}

    The eigenvalues can be found via the following calculation,

\begin{align}
U|u_s\rangle &= \frac{1}{\sqrt{r}} \sum_{k=0}^{r-1}e^{(-2\pi i sk)/r}|x^{k+1} (\textbf{mod} \ N)\rangle \\
&= e^{2 \pi is/r}|u_s\rangle.
\end{align}

Here \(0 \leq s \leq r-1\). The quantum circuit for the order-finding
algorithm is as follows:

    \begin{figure}
\centering
\includegraphics{order_finding_circuit.png}
\caption{order\_finding\_circuit.png}
\end{figure}

    \begin{quantikz}
\lstick{$\ket{0}^{\otimes t}$} & \gate{H^{\otimes t}}\qwbundle{t} & \ctrl{1}           & \gate{FT^{\dagger}} & \meter{}\\
\lstick{$\ket{1}^{\otimes L}$} & \qw \qwbundle{L}                 & \gate{x^j (mod N)} & \qw                 & \qw 
\end{quantikz}

    This circuit can also be used for factoring. The gate \(FT^{\dagger}\)
is the inverse Quantum Fourier Transform.

    \subsection{\texorpdfstring{Creating Python Functions to Compute Phase
Estimation, QFT, and
QFT\(^{\dagger}\)}{Creating Python Functions to Compute Phase Estimation, QFT, and QFT\^{}\{\textbackslash dagger\}}}\label{creating-python-functions-to-compute-phase-estimation-qft-and-qftdagger}

    In this section we are going to construct three functions that operate
on quantum circuits. First, we are going to construct a Python function
to prepare the phase estimation algorithm. Next, we'll construct a
function that performs the Quantum Fourier Transform. Finally, we will
build a function that performs the Inverse Quantum Fourier Transform.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{22}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{qiskit} \PY{k+kn}{import} \PY{o}{*}
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}
\PY{k+kn}{import} \PY{n+nn}{math}
\end{Verbatim}
\end{tcolorbox}

    \subsubsection{Phase Estimation}\label{phase-estimation}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{23}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{phase\PYZus{}est}\PY{p}{(}\PY{n}{circuit}\PY{p}{,} \PY{n}{theta}\PY{p}{)}\PY{p}{:}
    \PY{n}{n} \PY{o}{=} \PY{n+nb}{len}\PY{p}{(}\PY{n}{circuit}\PY{o}{.}\PY{n}{qubits}\PY{p}{)}
    \PY{k}{for} \PY{n}{qubit} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{n}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{:}
        \PY{n}{circuit}\PY{o}{.}\PY{n}{h}\PY{p}{(}\PY{n}{qubit}\PY{p}{)}
    \PY{n}{repetitions} \PY{o}{=} \PY{l+m+mi}{1}
    \PY{k}{for} \PY{n}{counting\PYZus{}qubit} \PY{o+ow}{in} \PY{n+nb}{reversed}\PY{p}{(}\PY{n+nb}{range}\PY{p}{(}\PY{n}{n}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{)}\PY{p}{:}
        \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{repetitions}\PY{p}{)}\PY{p}{:}
            \PY{n}{circuit}\PY{o}{.}\PY{n}{cu1}\PY{p}{(}\PY{n}{theta}\PY{p}{,} \PY{n}{counting\PYZus{}qubit}\PY{p}{,} \PY{n}{n}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{;}
        \PY{n}{repetitions} \PY{o}{*}\PY{o}{=} \PY{l+m+mi}{2}
\end{Verbatim}
\end{tcolorbox}

    Let's test it out on a five qubit circuit.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{24}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{qc} \PY{o}{=} \PY{n}{QuantumCircuit}\PY{p}{(}\PY{l+m+mi}{5}\PY{p}{)}
\PY{n}{phase\PYZus{}est}\PY{p}{(}\PY{n}{qc}\PY{p}{,} \PY{n}{math}\PY{o}{.}\PY{n}{pi}\PY{o}{/}\PY{l+m+mi}{4}\PY{p}{)}
\PY{n}{qc}\PY{o}{.}\PY{n}{draw}\PY{p}{(}\PY{n}{output}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{mpl}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}
 
            
\prompt{Out}{outcolor}{24}{}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_83_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    

    \subsubsection{Quantum Fourier
Transform}\label{quantum-fourier-transform}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{25}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{qft}\PY{p}{(}\PY{n}{circuit}\PY{p}{)}\PY{p}{:}
\PY{+w}{    }\PY{l+s+sd}{\PYZdq{}\PYZdq{}\PYZdq{}n\PYZhy{}qubit Quantum Fourier Transform\PYZdq{}\PYZdq{}\PYZdq{}}
    \PY{n}{n} \PY{o}{=} \PY{n+nb}{len}\PY{p}{(}\PY{n}{circuit}\PY{o}{.}\PY{n}{qubits}\PY{p}{)}
    \PY{k}{for} \PY{n}{j} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{n}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{:}
        \PY{n}{circuit}\PY{o}{.}\PY{n}{barrier}\PY{p}{(}\PY{p}{)}
        \PY{n}{circuit}\PY{o}{.}\PY{n}{h}\PY{p}{(}\PY{n}{j}\PY{p}{)}
        \PY{k}{for} \PY{n}{m} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{n}\PY{o}{\PYZhy{}}\PY{n}{j}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{:}
            \PY{n}{circuit}\PY{o}{.}\PY{n}{cu1}\PY{p}{(}\PY{n}{math}\PY{o}{.}\PY{n}{pi}\PY{o}{/}\PY{n+nb}{float}\PY{p}{(}\PY{l+m+mi}{2}\PY{o}{*}\PY{o}{*}\PY{p}{(}\PY{n}{m}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{)}\PY{p}{,} \PY{n}{j}\PY{o}{+}\PY{n}{m}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{j}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Let's test this function out on another five qubit circuit.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{26}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{qc2} \PY{o}{=} \PY{n}{QuantumCircuit}\PY{p}{(}\PY{l+m+mi}{5}\PY{p}{)}
\PY{n}{qft}\PY{p}{(}\PY{n}{qc2}\PY{p}{)}
\PY{n}{qc2}\PY{o}{.}\PY{n}{draw}\PY{p}{(}\PY{n}{output}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{mpl}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}
 
            
\prompt{Out}{outcolor}{26}{}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_87_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    

    \subsubsection{Inverse Quantum Fourier
Transform}\label{inverse-quantum-fourier-transform}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{27}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{qft\PYZus{}dagger}\PY{p}{(}\PY{n}{circuit}\PY{p}{)}\PY{p}{:}
\PY{+w}{    }\PY{l+s+sd}{\PYZdq{}\PYZdq{}\PYZdq{}n\PYZhy{}qubit QFTdagger the first n qubits in circ\PYZdq{}\PYZdq{}\PYZdq{}}
    \PY{n}{n} \PY{o}{=} \PY{n+nb}{len}\PY{p}{(}\PY{n}{circuit}\PY{o}{.}\PY{n}{qubits}\PY{p}{)}
    \PY{c+c1}{\PYZsh{} Don\PYZsq{}t forget the Swaps!}
    \PY{k}{for} \PY{n}{qubit} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{n}\PY{o}{/}\PY{o}{/}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{:}
        \PY{n}{circuit}\PY{o}{.}\PY{n}{swap}\PY{p}{(}\PY{n}{qubit}\PY{p}{,} \PY{n}{n}\PY{o}{\PYZhy{}}\PY{n}{qubit}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)}
    \PY{k}{for} \PY{n}{j} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{n}\PY{p}{)}\PY{p}{:}
        \PY{k}{for} \PY{n}{m} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{j}\PY{p}{)}\PY{p}{:}
            \PY{n}{circuit}\PY{o}{.}\PY{n}{cu1}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{n}{math}\PY{o}{.}\PY{n}{pi}\PY{o}{/}\PY{n+nb}{float}\PY{p}{(}\PY{l+m+mi}{2}\PY{o}{*}\PY{o}{*}\PY{p}{(}\PY{n}{j}\PY{o}{\PYZhy{}}\PY{n}{m}\PY{p}{)}\PY{p}{)}\PY{p}{,} \PY{n}{m}\PY{p}{,} \PY{n}{j}\PY{p}{)}
        \PY{n}{circuit}\PY{o}{.}\PY{n}{h}\PY{p}{(}\PY{n}{j}\PY{p}{)}
        \PY{n}{circuit}\PY{o}{.}\PY{n}{barrier}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    Let's test it on a five qubit circuit.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{28}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{qc3} \PY{o}{=} \PY{n}{QuantumCircuit}\PY{p}{(}\PY{l+m+mi}{5}\PY{p}{)}
\PY{n}{qft\PYZus{}dagger}\PY{p}{(}\PY{n}{qc3}\PY{p}{)}
\PY{n}{qc3}\PY{o}{.}\PY{n}{draw}\PY{p}{(}\PY{n}{output}\PY{o}{=}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{mpl}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}
 
            
\prompt{Out}{outcolor}{28}{}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_91_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    

    \subsubsection{Exercises}\label{exercises}

    \begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a four qubit quantum circuit named \texttt{qc1}. Use the
  \texttt{qft} function on \texttt{qc1}.
\item
  Create a four qubit quantum circuit named \texttt{qc2}. Use the
  \texttt{qft\_dagger} function on \texttt{qc2}.
\item
  Create a circuit \texttt{circ1\ =\ qc1+qc2} that performs the QFT and
  inverse QFT.
\item
  Run \texttt{circ1} on the \texttt{statevector\_simulator} in QISKit
  and print the state vector. Does this state vector make sense?
\item
  Construct a circuit \texttt{qc3} on four qubits and apply the
  \texttt{phase\_est} function to it.
\item
  Now create a second circuit \texttt{qc4} on four qubits and run the
  inverse QFT on it.
\item
  Create a circuit \texttt{qc3+qc4} and print the state vector resulting
  from running this circuit on the \texttt{statevector\_simulator}
  backend.
\end{enumerate}


    % Add a bibliography block to the postdoc
    
    
    
\end{document}
