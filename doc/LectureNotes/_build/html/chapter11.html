
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>15. Solving Differential Equations with Deep Learning &#8212; Applied Data Analysis and Machine Learning</title>
    
  <link href="_static/css/theme.css" rel="stylesheet">
  <link href="_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/sphinx-book-theme.d59cb220de22ca1c485ebbdc042f0030.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="16. Convolutional Neural Networks" href="chapter12.html" />
    <link rel="prev" title="14. Building a Feed Forward Neural Network" href="chapter10.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Applied Data Analysis and Machine Learning</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="intro.html">
   Applied Data Analysis and Machine Learning
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  About the course
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="schedule.html">
   Teaching schedule with links to material
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="teachers.html">
   Teachers and Grading
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="textbooks.html">
   Textbooks
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Review of Statistics with Resampling Techniques and Linear Algebra
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="statistics.html">
   1. Elements of Probability Theory and Statistical Data Analysis
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="linalg.html">
   2. Linear Algebra, Handling of Arrays and more Python Features
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  From Regression to Support Vector Machines
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="chapter1.html">
   3. Linear Regression
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="chapter2.html">
   4. Ridge and Lasso Regression
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="chapter3.html">
   5. Resampling Methods
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="chapter4.html">
   6. Logistic Regression
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="chapteroptimization.html">
   7. Optimization, the central part of any Machine Learning algortithm
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="chapter5.html">
   8. Support Vector Machines, overarching aims
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Decision Trees, Ensemble Methods and Boosting
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="chapter6.html">
   9. Decision trees, overarching aims
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="chapter7.html">
   10. Ensemble Methods: From a Single Tree to Many Trees and Extreme Boosting, Meet the Jungle of Methods
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Dimensionality Reduction
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="chapter8.html">
   11. Basic ideas of the Principal Component Analysis (PCA)
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="clustering.html">
   12. Clustering and Unsupervised Learning
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Deep Learning Methods
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="chapter9.html">
   13. Neural networks
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="chapter10.html">
   14. Building a Feed Forward Neural Network
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   15. Solving Differential Equations  with Deep Learning
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="chapter12.html">
   16. Convolutional Neural Networks
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="chapter13.html">
   17. Recurrent neural networks: Overarching view
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="_sources/chapter11.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
                onclick="printPdf(this)" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show noprint">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#example-exponential-decay">
   15.1. Example: Exponential decay
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#reformulating-the-problem">
   15.2. Reformulating the problem
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#gradient-descent">
   15.3. Gradient descent
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#the-code-for-solving-the-ode">
   15.4. The code for solving the ODE
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#the-network-with-one-input-layer-specified-number-of-hidden-layers-and-one-output-layer">
   15.5. The network with one input layer, specified number of hidden layers, and one output layer
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#example-population-growth">
     15.5.1. Example: Population growth
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#using-forward-euler-to-solve-the-ode">
   15.6. Using forward Euler to solve the ODE
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#solving-the-one-dimensional-poisson-equation">
   15.7. Solving the one dimensional Poisson equation
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#comparing-with-a-numerical-scheme">
     15.7.1. Comparing with a numerical scheme
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#partial-differential-equations">
   15.8. Partial Differential Equations
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#type-of-problem">
     15.8.1. Type of problem
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#network-requirements">
     15.8.2. Network requirements
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#example-the-diffusion-equation">
   15.9. Example: The diffusion equation
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#setting-up-the-network-using-autograd-the-full-program">
     15.9.1. Setting up the network using Autograd; The full program
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#solving-the-wave-equation-with-neural-networks">
   15.10. Solving the wave equation with Neural Networks
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#resources-on-differential-equations-and-deep-learning">
   15.11. Resources on differential equations and deep learning
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Solving Differential Equations  with Deep Learning</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#example-exponential-decay">
   15.1. Example: Exponential decay
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#reformulating-the-problem">
   15.2. Reformulating the problem
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#gradient-descent">
   15.3. Gradient descent
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#the-code-for-solving-the-ode">
   15.4. The code for solving the ODE
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#the-network-with-one-input-layer-specified-number-of-hidden-layers-and-one-output-layer">
   15.5. The network with one input layer, specified number of hidden layers, and one output layer
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#example-population-growth">
     15.5.1. Example: Population growth
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#using-forward-euler-to-solve-the-ode">
   15.6. Using forward Euler to solve the ODE
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#solving-the-one-dimensional-poisson-equation">
   15.7. Solving the one dimensional Poisson equation
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#comparing-with-a-numerical-scheme">
     15.7.1. Comparing with a numerical scheme
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#partial-differential-equations">
   15.8. Partial Differential Equations
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#type-of-problem">
     15.8.1. Type of problem
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#network-requirements">
     15.8.2. Network requirements
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#example-the-diffusion-equation">
   15.9. Example: The diffusion equation
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#setting-up-the-network-using-autograd-the-full-program">
     15.9.1. Setting up the network using Autograd; The full program
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#solving-the-wave-equation-with-neural-networks">
   15.10. Solving the wave equation with Neural Networks
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#resources-on-differential-equations-and-deep-learning">
   15.11. Resources on differential equations and deep learning
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            
              <div>
                
  <!-- HTML file automatically generated from DocOnce source (https://github.com/doconce/doconce/)
doconce format html chapter11.do.txt  --><div class="tex2jax_ignore mathjax_ignore section" id="solving-differential-equations-with-deep-learning">
<h1><span class="section-number">15. </span>Solving Differential Equations  with Deep Learning<a class="headerlink" href="#solving-differential-equations-with-deep-learning" title="Permalink to this headline">¶</a></h1>
<p>The Universal Approximation Theorem states that a neural network can
approximate any function at a single hidden layer along with one input
and output layer to any given precision.</p>
<p>An ordinary differential equation (ODE) is an equation involving functions having one variable.</p>
<p>In general, an ordinary differential equation looks like</p>
<!-- Equation labels as ordinary links -->
<div id="ode"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation} \label{ode} \tag{1}
f\left(x, \, g(x), \, g'(x), \, g''(x), \, \dots \, , \, g^{(n)}(x)\right) = 0
\end{equation}
\]</div>
<p>where <span class="math notranslate nohighlight">\(g(x)\)</span> is the function to find, and <span class="math notranslate nohighlight">\(g^{(n)}(x)\)</span> is the <span class="math notranslate nohighlight">\(n\)</span>-th derivative of <span class="math notranslate nohighlight">\(g(x)\)</span>.</p>
<p>The <span class="math notranslate nohighlight">\(f\left(x, g(x), g'(x), g''(x), \, \dots \, , g^{(n)}(x)\right)\)</span> is just a way to write that there is an expression involving <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(g(x), \ g'(x), \ g''(x), \, \dots \, , \text{ and } g^{(n)}(x)\)</span> on the left side of the equality sign in (<a class="reference external" href="#ode">1</a>).
The highest order of derivative, that is the value of <span class="math notranslate nohighlight">\(n\)</span>, determines to the order of the equation.
The equation is referred to as a <span class="math notranslate nohighlight">\(n\)</span>-th order ODE.
Along with (<a class="reference external" href="#ode">1</a>), some additional conditions of the function <span class="math notranslate nohighlight">\(g(x)\)</span> are typically given
for the solution to be unique.</p>
<p>Let the trial solution <span class="math notranslate nohighlight">\(g_t(x)\)</span> be</p>
<!-- Equation labels as ordinary links -->
<div id="_auto1"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
	g_t(x) = h_1(x) + h_2(x,N(x,P))
\label{_auto1} \tag{2}
\end{equation}
\]</div>
<p>where <span class="math notranslate nohighlight">\(h_1(x)\)</span> is a function that makes <span class="math notranslate nohighlight">\(g_t(x)\)</span> satisfy a given set
of conditions, <span class="math notranslate nohighlight">\(N(x,P)\)</span> a neural network with weights and biases
described by <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(h_2(x, N(x,P))\)</span> some expression involving the
neural network.  The role of the function <span class="math notranslate nohighlight">\(h_2(x, N(x,P))\)</span>, is to
ensure that the output from <span class="math notranslate nohighlight">\(N(x,P)\)</span> is zero when <span class="math notranslate nohighlight">\(g_t(x)\)</span> is
evaluated at the values of <span class="math notranslate nohighlight">\(x\)</span> where the given conditions must be
satisfied.  The function <span class="math notranslate nohighlight">\(h_1(x)\)</span> should alone make <span class="math notranslate nohighlight">\(g_t(x)\)</span> satisfy
the conditions.</p>
<p>But what about the network <span class="math notranslate nohighlight">\(N(x,P)\)</span>?</p>
<p>As described previously, an optimization method could be used to minimize the parameters of a neural network, that being its weights and biases, through backward propagation.</p>
<p>For the minimization to be defined, we need to have a cost function at hand to minimize.</p>
<p>It is given that <span class="math notranslate nohighlight">\(f\left(x, \, g(x), \, g'(x), \, g''(x), \, \dots \, , \, g^{(n)}(x)\right)\)</span> should be equal to zero in (<a class="reference external" href="#ode">1</a>).
We can choose to consider the mean squared error as the cost function for an input <span class="math notranslate nohighlight">\(x\)</span>.
Since we are looking at one input, the cost function is just <span class="math notranslate nohighlight">\(f\)</span> squared.
The cost function <span class="math notranslate nohighlight">\(c\left(x, P \right)\)</span> can therefore be expressed as</p>
<div class="math notranslate nohighlight">
\[
C\left(x, P\right) = \big(f\left(x, \, g(x), \, g'(x), \, g''(x), \, \dots \, , \, g^{(n)}(x)\right)\big)^2
\]</div>
<p>If <span class="math notranslate nohighlight">\(N\)</span> inputs are given as a vector <span class="math notranslate nohighlight">\(\boldsymbol{x}\)</span> with elements <span class="math notranslate nohighlight">\(x_i\)</span> for <span class="math notranslate nohighlight">\(i = 1,\dots,N\)</span>,
the cost function becomes</p>
<!-- Equation labels as ordinary links -->
<div id="cost"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation} \label{cost} \tag{3}
	C\left(\boldsymbol{x}, P\right) = \frac{1}{N} \sum_{i=1}^N \big(f\left(x_i, \, g(x_i), \, g'(x_i), \, g''(x_i), \, \dots \, , \, g^{(n)}(x_i)\right)\big)^2
\end{equation}
\]</div>
<p>The neural net should then find the parameters <span class="math notranslate nohighlight">\(P\)</span> that minimizes the cost function in
(<a class="reference external" href="#cost">3</a>) for a set of <span class="math notranslate nohighlight">\(N\)</span> training samples <span class="math notranslate nohighlight">\(x_i\)</span>.</p>
<p>To perform the minimization using gradient descent, the gradient of <span class="math notranslate nohighlight">\(C\left(\boldsymbol{x}, P\right)\)</span> is needed.
It might happen so that finding an analytical expression of the gradient of <span class="math notranslate nohighlight">\(C(\boldsymbol{x}, P)\)</span> from (<a class="reference external" href="#cost">3</a>) gets too messy, depending on which cost function one desires to use.</p>
<p>Luckily, there exists libraries that makes the job for us through automatic differentiation.
Automatic differentiation is a method of finding the derivatives numerically with very high precision.</p>
<div class="section" id="example-exponential-decay">
<h2><span class="section-number">15.1. </span>Example: Exponential decay<a class="headerlink" href="#example-exponential-decay" title="Permalink to this headline">¶</a></h2>
<p>An exponential decay of a quantity <span class="math notranslate nohighlight">\(g(x)\)</span> is described by the equation</p>
<!-- Equation labels as ordinary links -->
<div id="solve_expdec"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation} \label{solve_expdec} \tag{4}
  g'(x) = -\gamma g(x)
\end{equation}
\]</div>
<p>with <span class="math notranslate nohighlight">\(g(0) = g_0\)</span> for some chosen initial value <span class="math notranslate nohighlight">\(g_0\)</span>.</p>
<p>The analytical solution of (<a class="reference external" href="#solve_expdec">4</a>) is</p>
<!-- Equation labels as ordinary links -->
<div id="_auto2"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
  g(x) = g_0 \exp\left(-\gamma x\right)
\label{_auto2} \tag{5}
\end{equation}
\]</div>
<p>Having an analytical solution at hand, it is possible to use it to compare how well a neural network finds a solution of (<a class="reference external" href="#solve_expdec">4</a>).</p>
<p>The program will use a neural network to solve</p>
<!-- Equation labels as ordinary links -->
<div id="solveode"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation} \label{solveode} \tag{6}
g'(x) = -\gamma g(x)
\end{equation}
\]</div>
<p>where <span class="math notranslate nohighlight">\(g(0) = g_0\)</span> with <span class="math notranslate nohighlight">\(\gamma\)</span> and <span class="math notranslate nohighlight">\(g_0\)</span> being some chosen values.</p>
<p>In this example, <span class="math notranslate nohighlight">\(\gamma = 2\)</span> and <span class="math notranslate nohighlight">\(g_0 = 10\)</span>.</p>
<p>To begin with, a trial solution <span class="math notranslate nohighlight">\(g_t(t)\)</span> must be chosen. A general trial solution for ordinary differential equations could be</p>
<div class="math notranslate nohighlight">
\[
g_t(x, P) = h_1(x) + h_2(x, N(x, P))
\]</div>
<p>with <span class="math notranslate nohighlight">\(h_1(x)\)</span> ensuring that <span class="math notranslate nohighlight">\(g_t(x)\)</span> satisfies some conditions and <span class="math notranslate nohighlight">\(h_2(x,N(x, P))\)</span> an expression involving <span class="math notranslate nohighlight">\(x\)</span> and the output from the neural network <span class="math notranslate nohighlight">\(N(x,P)\)</span> with <span class="math notranslate nohighlight">\(P \)</span> being the collection of the weights and biases for each layer. For now, it is assumed that the network consists of one input layer, one hidden layer, and one output layer.</p>
<p>In this network, there are no weights and bias at the input layer, so <span class="math notranslate nohighlight">\(P = \{ P_{\text{hidden}},  P_{\text{output}} \}\)</span>.
If there are <span class="math notranslate nohighlight">\(N_{\text{hidden} }\)</span> neurons in the hidden layer, then <span class="math notranslate nohighlight">\(P_{\text{hidden}}\)</span> is a <span class="math notranslate nohighlight">\(N_{\text{hidden} } \times (1 + N_{\text{input}})\)</span> matrix, given that there are <span class="math notranslate nohighlight">\(N_{\text{input}}\)</span> neurons in the input layer.</p>
<p>The first column in <span class="math notranslate nohighlight">\(P_{\text{hidden} }\)</span> represents the bias for each neuron in the hidden layer and the second column represents the weights for each neuron in the hidden layer from the input layer.
If there are <span class="math notranslate nohighlight">\(N_{\text{output} }\)</span> neurons in the output layer, then <span class="math notranslate nohighlight">\(P_{\text{output}} \)</span> is a <span class="math notranslate nohighlight">\(N_{\text{output} } \times (1 + N_{\text{hidden} })\)</span> matrix.</p>
<p>Its first column represents the bias of each neuron and the remaining columns represents the weights to each neuron.</p>
<p>It is given that <span class="math notranslate nohighlight">\(g(0) = g_0\)</span>. The trial solution must fulfill this condition to be a proper solution of (<a class="reference external" href="#solveode">6</a>). A possible way to ensure that <span class="math notranslate nohighlight">\(g_t(0, P) = g_0\)</span>, is to let <span class="math notranslate nohighlight">\(F(N(x,P)) = x \cdot N(x,P)\)</span> and <span class="math notranslate nohighlight">\(A(x) = g_0\)</span>. This gives the following trial solution:</p>
<!-- Equation labels as ordinary links -->
<div id="trial"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation} \label{trial} \tag{7}
g_t(x, P) = g_0 + x \cdot N(x, P)
\end{equation}
\]</div>
</div>
<div class="section" id="reformulating-the-problem">
<h2><span class="section-number">15.2. </span>Reformulating the problem<a class="headerlink" href="#reformulating-the-problem" title="Permalink to this headline">¶</a></h2>
<p>We wish that our neural network manages to minimize a given cost function.</p>
<p>A reformulation of out equation, (<a class="reference external" href="#solveode">6</a>), must therefore be done,
such that it describes the problem a neural network can solve for.</p>
<p>The neural network must find the set of weights and biases <span class="math notranslate nohighlight">\(P\)</span> such that the trial solution in (<a class="reference external" href="#trial">7</a>) satisfies (<a class="reference external" href="#solveode">6</a>).</p>
<p>The trial solution</p>
<div class="math notranslate nohighlight">
\[
g_t(x, P) = g_0 + x \cdot N(x, P)
\]</div>
<p>has been chosen such that it already solves the condition <span class="math notranslate nohighlight">\(g(0) = g_0\)</span>. What remains, is to find <span class="math notranslate nohighlight">\(P\)</span> such that</p>
<!-- Equation labels as ordinary links -->
<div id="nnmin"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation} \label{nnmin} \tag{8}
g_t'(x, P) = - \gamma g_t(x, P)
\end{equation}
\]</div>
<p>is fulfilled as <em>best as possible</em>.</p>
<p>The left hand side and right hand side of (<a class="reference external" href="#nnmin">8</a>) must be computed separately, and then the neural network must choose weights and biases, contained in <span class="math notranslate nohighlight">\(P\)</span>, such that the sides are equal as best as possible.
This means that the absolute or squared difference between the sides must be as close to zero, ideally equal to zero.
In this case, the difference squared shows to be an appropriate measurement of how erroneous the trial solution is with respect to <span class="math notranslate nohighlight">\(P\)</span> of the neural network.</p>
<p>This gives the following cost function our neural network must solve for:</p>
<div class="math notranslate nohighlight">
\[
\min_{P}\Big\{ \big(g_t'(x, P) - ( -\gamma g_t(x, P) \big)^2 \Big\}
\]</div>
<p>(the notation <span class="math notranslate nohighlight">\(\min_{P}\{ f(x, P) \}\)</span> means that we desire to find <span class="math notranslate nohighlight">\(P\)</span> that yields the minimum of <span class="math notranslate nohighlight">\(f(x, P)\)</span>)</p>
<p>or, in terms of weights and biases for the hidden and output layer in our network:</p>
<div class="math notranslate nohighlight">
\[
\min_{P_{\text{hidden} }, \ P_{\text{output} }}\Big\{ \big(g_t'(x, \{ P_{\text{hidden} }, P_{\text{output} }\}) - ( -\gamma g_t(x, \{ P_{\text{hidden} }, P_{\text{output} }\}) \big)^2 \Big\}
\]</div>
<p>for an input value <span class="math notranslate nohighlight">\(x\)</span>.</p>
<p>If the neural network evaluates <span class="math notranslate nohighlight">\(g_t(x, P)\)</span> at more values for <span class="math notranslate nohighlight">\(x\)</span>, say <span class="math notranslate nohighlight">\(N\)</span> values <span class="math notranslate nohighlight">\(x_i\)</span> for <span class="math notranslate nohighlight">\(i = 1, \dots, N\)</span>, then the <em>total</em> error to minimize becomes</p>
<!-- Equation labels as ordinary links -->
<div id="min"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation} \label{min} \tag{9}
\min_{P}\Big\{\frac{1}{N} \sum_{i=1}^N  \big(g_t'(x_i, P) - ( -\gamma g_t(x_i, P) \big)^2 \Big\}
\end{equation}
\]</div>
<p>Letting <span class="math notranslate nohighlight">\(\boldsymbol{x}\)</span> be a vector with elements <span class="math notranslate nohighlight">\(x_i\)</span> and <span class="math notranslate nohighlight">\(C(\boldsymbol{x}, P) = \frac{1}{N} \sum_i  \big(g_t'(x_i, P) - ( -\gamma g_t(x_i, P) \big)^2\)</span> denote the cost function, the minimization problem that our network must solve, becomes</p>
<div class="math notranslate nohighlight">
\[
\min_{P} C(\boldsymbol{x}, P)
\]</div>
<p>In terms of <span class="math notranslate nohighlight">\(P_{\text{hidden} }\)</span> and <span class="math notranslate nohighlight">\(P_{\text{output} }\)</span>, this could also be expressed as</p>
<div class="math notranslate nohighlight">
\[
\min_{P_{\text{hidden} }, \ P_{\text{output} }} C(\boldsymbol{x}, \{P_{\text{hidden} }, P_{\text{output} }\})
\]</div>
<p>For simplicity, it is assumed that the input is an array <span class="math notranslate nohighlight">\(\boldsymbol{x} = (x_1, \dots, x_N)\)</span> with <span class="math notranslate nohighlight">\(N\)</span> elements. It is at these points the neural network should find <span class="math notranslate nohighlight">\(P\)</span> such that it fulfills (<a class="reference external" href="#min">9</a>).</p>
<p>First, the neural network must feed forward the inputs.
This means that <span class="math notranslate nohighlight">\(\boldsymbol{x}s\)</span> must be passed through an input layer, a hidden layer and a output layer. The input layer in this case, does not need to process the data any further.
The input layer will consist of <span class="math notranslate nohighlight">\(N_{\text{input} }\)</span> neurons, passing its element to each neuron in the hidden layer.  The number of neurons in the hidden layer will be <span class="math notranslate nohighlight">\(N_{\text{hidden} }\)</span>.</p>
<p>For the <span class="math notranslate nohighlight">\(i\)</span>-th in the hidden layer with weight <span class="math notranslate nohighlight">\(w_i^{\text{hidden} }\)</span> and bias <span class="math notranslate nohighlight">\(b_i^{\text{hidden} }\)</span>, the weighting from the <span class="math notranslate nohighlight">\(j\)</span>-th neuron at the input layer is:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
z_{i,j}^{\text{hidden}} &amp;= b_i^{\text{hidden}} + w_i^{\text{hidden}}x_j \\
&amp;=
\begin{pmatrix}
b_i^{\text{hidden}} &amp; w_i^{\text{hidden}}
\end{pmatrix}
\begin{pmatrix}
1 \\
x_j
\end{pmatrix}
\end{aligned}
\end{split}\]</div>
<p>The result after weighting the inputs at the <span class="math notranslate nohighlight">\(i\)</span>-th hidden neuron can be written as a vector:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\boldsymbol{z}_{i}^{\text{hidden}} &amp;= \Big( b_i^{\text{hidden}} + w_i^{\text{hidden}}x_1 , \ b_i^{\text{hidden}} + w_i^{\text{hidden}} x_2, \ \dots \, , \ b_i^{\text{hidden}} + w_i^{\text{hidden}} x_N\Big)  \\
&amp;=
\begin{pmatrix}
 b_i^{\text{hidden}}  &amp; w_i^{\text{hidden}}
\end{pmatrix}
\begin{pmatrix}
1  &amp; 1 &amp; \dots &amp; 1 \\
x_1 &amp; x_2 &amp; \dots &amp; x_N
\end{pmatrix} \\
&amp;= \boldsymbol{p}_{i, \text{hidden}}^T X
\end{aligned}
\end{split}\]</div>
<p>The vector <span class="math notranslate nohighlight">\(\boldsymbol{p}_{i, \text{hidden}}^T\)</span> constitutes each row in <span class="math notranslate nohighlight">\(P_{\text{hidden} }\)</span>, which contains the weights for the neural network to minimize according to (<a class="reference external" href="#min">9</a>).</p>
<p>After having found <span class="math notranslate nohighlight">\(\boldsymbol{z}_{i}^{\text{hidden}} \)</span> for every <span class="math notranslate nohighlight">\(i\)</span>-th neuron within the hidden layer, the vector will be sent to an activation function <span class="math notranslate nohighlight">\(a_i(\boldsymbol{z})\)</span>.</p>
<p>In this example, the sigmoid function has been chosen to be the activation function for each hidden neuron:</p>
<div class="math notranslate nohighlight">
\[
f(z) = \frac{1}{1 + \exp{(-z)}}
\]</div>
<p>It is possible to use other activations functions for the hidden layer also.</p>
<p>The output <span class="math notranslate nohighlight">\(\boldsymbol{x}_i^{\text{hidden}}\)</span> from each <span class="math notranslate nohighlight">\(i\)</span>-th hidden neuron is:</p>
<div class="math notranslate nohighlight">
\[
\boldsymbol{x}_i^{\text{hidden} } = f\big(  \boldsymbol{z}_{i}^{\text{hidden}} \big)
\]</div>
<p>The outputs <span class="math notranslate nohighlight">\(\boldsymbol{x}_i^{\text{hidden} } \)</span> are then sent to the output layer.</p>
<p>The output layer consists of one neuron in this case, and combines the
output from each of the neurons in the hidden layers. The output layer
combines the results from the hidden layer using some weights <span class="math notranslate nohighlight">\(w_i^{\text{output}}\)</span>
and biases <span class="math notranslate nohighlight">\(b_i^{\text{output}}\)</span>. In this case,
it is assumes that the number of neurons in the output layer is one.</p>
<p>The procedure of weighting the output neuron <span class="math notranslate nohighlight">\(j\)</span> in the hidden layer to the <span class="math notranslate nohighlight">\(i\)</span>-th neuron in the output layer is similar as for the hidden layer described previously.</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
z_{1,j}^{\text{output}} &amp; =
\begin{pmatrix}
b_1^{\text{output}} &amp; \boldsymbol{w}_1^{\text{output}}
\end{pmatrix}
\begin{pmatrix}
1 \\
\boldsymbol{x}_j^{\text{hidden}}
\end{pmatrix}
\end{aligned}
\end{split}\]</div>
<p>Expressing <span class="math notranslate nohighlight">\(z_{1,j}^{\text{output}}\)</span> as a vector gives the following way of weighting the inputs from the hidden layer:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\boldsymbol{z}_{1}^{\text{output}} =
\begin{pmatrix}
b_1^{\text{output}} &amp; \boldsymbol{w}_1^{\text{output}}
\end{pmatrix}
\begin{pmatrix}
1  &amp; 1 &amp; \dots &amp; 1 \\
\boldsymbol{x}_1^{\text{hidden}} &amp; \boldsymbol{x}_2^{\text{hidden}} &amp; \dots &amp; \boldsymbol{x}_N^{\text{hidden}}
\end{pmatrix}
\end{split}\]</div>
<p>In this case we seek a continuous range of values since we are approximating a function. This means that after computing <span class="math notranslate nohighlight">\(\boldsymbol{z}_{1}^{\text{output}}\)</span> the neural network has finished its feed forward step, and <span class="math notranslate nohighlight">\(\boldsymbol{z}_{1}^{\text{output}}\)</span> is the final output of the network.</p>
<p>The next step is to decide how the parameters should be changed such that they minimize the cost function.</p>
<p>The chosen cost function for this problem is</p>
<div class="math notranslate nohighlight">
\[
C(\boldsymbol{x}, P) = \frac{1}{N} \sum_i  \big(g_t'(x_i, P) - ( -\gamma g_t(x_i, P) \big)^2
\]</div>
<p>In order to minimize the cost function, an optimization method must be chosen.</p>
<p>Here, gradient descent with a constant step size has been chosen.</p>
</div>
<div class="section" id="gradient-descent">
<h2><span class="section-number">15.3. </span>Gradient descent<a class="headerlink" href="#gradient-descent" title="Permalink to this headline">¶</a></h2>
<p>The idea of the gradient descent algorithm is to update parameters in
a direction where the cost function decreases goes to a minimum.</p>
<p>In general, the update of some parameters <span class="math notranslate nohighlight">\(\boldsymbol{\omega}\)</span> given a cost
function defined by some weights <span class="math notranslate nohighlight">\(\boldsymbol{\omega}\)</span>, <span class="math notranslate nohighlight">\(C(\boldsymbol{x},
\boldsymbol{\omega})\)</span>, goes as follows:</p>
<div class="math notranslate nohighlight">
\[
\boldsymbol{\omega}_{\text{new} } = \boldsymbol{\omega} - \lambda \nabla_{\boldsymbol{\omega}} C(\boldsymbol{x}, \boldsymbol{\omega})
\]</div>
<p>for a number of iterations or until <span class="math notranslate nohighlight">\( \big|\big| \boldsymbol{\omega}_{\text{new} } - \boldsymbol{\omega} \big|\big|\)</span> becomes smaller than some given tolerance.</p>
<p>The value of <span class="math notranslate nohighlight">\(\lambda\)</span> decides how large steps the algorithm must take
in the direction of <span class="math notranslate nohighlight">\( \nabla_{\boldsymbol{\omega}} C(\boldsymbol{x}, \boldsymbol{\omega})\)</span>.
The notation <span class="math notranslate nohighlight">\(\nabla_{\boldsymbol{\omega}}\)</span> express the gradient with respect
to the elements in <span class="math notranslate nohighlight">\(\boldsymbol{\omega}\)</span>.</p>
<p>In our case, we have to minimize the cost function <span class="math notranslate nohighlight">\(C(\boldsymbol{x}, P)\)</span> with
respect to the two sets of weights and biases, that is for the hidden
layer <span class="math notranslate nohighlight">\(P_{\text{hidden} }\)</span> and for the output layer <span class="math notranslate nohighlight">\(P_{\text{output}
}\)</span> .</p>
<p>This means that <span class="math notranslate nohighlight">\(P_{\text{hidden} }\)</span> and <span class="math notranslate nohighlight">\(P_{\text{output} }\)</span> is updated by</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
P_{\text{hidden},\text{new}} &amp;= P_{\text{hidden}} - \lambda \nabla_{P_{\text{hidden}}} C(\boldsymbol{x}, P)  \\
P_{\text{output},\text{new}} &amp;= P_{\text{output}} - \lambda \nabla_{P_{\text{output}}} C(\boldsymbol{x}, P)
\end{aligned}
\end{split}\]</div>
</div>
<div class="section" id="the-code-for-solving-the-ode">
<h2><span class="section-number">15.4. </span>The code for solving the ODE<a class="headerlink" href="#the-code-for-solving-the-ode" title="Permalink to this headline">¶</a></h2>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">matplotlib</span> inline

<span class="kn">import</span> <span class="nn">autograd.numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">autograd</span> <span class="kn">import</span> <span class="n">grad</span><span class="p">,</span> <span class="n">elementwise_grad</span>
<span class="kn">import</span> <span class="nn">autograd.numpy.random</span> <span class="k">as</span> <span class="nn">npr</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="k">def</span> <span class="nf">sigmoid</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">z</span><span class="p">))</span>

<span class="c1"># Assuming one input, hidden, and output layer</span>
<span class="k">def</span> <span class="nf">neural_network</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>

    <span class="c1"># Find the weights (including and biases) for the hidden and output layer.</span>
    <span class="c1"># Assume that params is a list of parameters for each layer.</span>
    <span class="c1"># The biases are the first element for each array in params,</span>
    <span class="c1"># and the weights are the remaning elements in each array in params.</span>

    <span class="n">w_hidden</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">w_output</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Assumes input x being an one-dimensional array</span>
    <span class="n">num_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_values</span><span class="p">)</span>

    <span class="c1"># Assume that the input layer does nothing to the input x</span>
    <span class="n">x_input</span> <span class="o">=</span> <span class="n">x</span>

    <span class="c1">## Hidden layer:</span>

    <span class="c1"># Add a row of ones to include bias</span>
    <span class="n">x_input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">num_values</span><span class="p">)),</span> <span class="n">x_input</span> <span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">z_hidden</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">w_hidden</span><span class="p">,</span> <span class="n">x_input</span><span class="p">)</span>
    <span class="n">x_hidden</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">z_hidden</span><span class="p">)</span>

    <span class="c1">## Output layer:</span>

    <span class="c1"># Include bias:</span>
    <span class="n">x_hidden</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">num_values</span><span class="p">)),</span> <span class="n">x_hidden</span> <span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">z_output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">w_output</span><span class="p">,</span> <span class="n">x_hidden</span><span class="p">)</span>
    <span class="n">x_output</span> <span class="o">=</span> <span class="n">z_output</span>

    <span class="k">return</span> <span class="n">x_output</span>

<span class="c1"># The trial solution using the deep neural network:</span>
<span class="k">def</span> <span class="nf">g_trial</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">params</span><span class="p">,</span> <span class="n">g0</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">g0</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">neural_network</span><span class="p">(</span><span class="n">params</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># The right side of the ODE:</span>
<span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">g_trial</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="mi">2</span><span class="p">):</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">gamma</span><span class="o">*</span><span class="n">g_trial</span>

<span class="c1"># The cost function:</span>
<span class="k">def</span> <span class="nf">cost_function</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>

    <span class="c1"># Evaluate the trial function with the current parameters P</span>
    <span class="n">g_t</span> <span class="o">=</span> <span class="n">g_trial</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">P</span><span class="p">)</span>

    <span class="c1"># Find the derivative w.r.t x of the neural network</span>
    <span class="n">d_net_out</span> <span class="o">=</span> <span class="n">elementwise_grad</span><span class="p">(</span><span class="n">neural_network</span><span class="p">,</span><span class="mi">1</span><span class="p">)(</span><span class="n">P</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># Find the derivative w.r.t x of the trial function</span>
    <span class="n">d_g_t</span> <span class="o">=</span> <span class="n">elementwise_grad</span><span class="p">(</span><span class="n">g_trial</span><span class="p">,</span><span class="mi">0</span><span class="p">)(</span><span class="n">x</span><span class="p">,</span><span class="n">P</span><span class="p">)</span>

    <span class="c1"># The right side of the ODE</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">g_t</span><span class="p">)</span>

    <span class="n">err_sqr</span> <span class="o">=</span> <span class="p">(</span><span class="n">d_g_t</span> <span class="o">-</span> <span class="n">func</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">cost_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">err_sqr</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cost_sum</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">err_sqr</span><span class="p">)</span>

<span class="c1"># Solve the exponential decay ODE using neural network with one input, hidden, and output layer</span>
<span class="k">def</span> <span class="nf">solve_ode_neural_network</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">num_neurons_hidden</span><span class="p">,</span> <span class="n">num_iter</span><span class="p">,</span> <span class="n">lmb</span><span class="p">):</span>
    <span class="c1">## Set up initial weights and biases</span>

    <span class="c1"># For the hidden layer</span>
    <span class="n">p0</span> <span class="o">=</span> <span class="n">npr</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">num_neurons_hidden</span><span class="p">,</span> <span class="mi">2</span> <span class="p">)</span>

    <span class="c1"># For the output layer</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">npr</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_neurons_hidden</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span> <span class="c1"># +1 since bias is included</span>

    <span class="n">P</span> <span class="o">=</span> <span class="p">[</span><span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">]</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Initial cost: </span><span class="si">%g</span><span class="s1">&#39;</span><span class="o">%</span><span class="k">cost_function</span>(P, x))

    <span class="c1">## Start finding the optimal weights using gradient descent</span>

    <span class="c1"># Find the Python function that represents the gradient of the cost function</span>
    <span class="c1"># w.r.t the 0-th input argument -- that is the weights and biases in the hidden and output layer</span>
    <span class="n">cost_function_grad</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="n">cost_function</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Let the update be done num_iter times</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_iter</span><span class="p">):</span>
        <span class="c1"># Evaluate the gradient at the current weights and biases in P.</span>
        <span class="c1"># The cost_grad consist now of two arrays;</span>
        <span class="c1"># one for the gradient w.r.t P_hidden and</span>
        <span class="c1"># one for the gradient w.r.t P_output</span>
        <span class="n">cost_grad</span> <span class="o">=</span>  <span class="n">cost_function_grad</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

        <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">lmb</span> <span class="o">*</span> <span class="n">cost_grad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">lmb</span> <span class="o">*</span> <span class="n">cost_grad</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Final cost: </span><span class="si">%g</span><span class="s1">&#39;</span><span class="o">%</span><span class="k">cost_function</span>(P, x))

    <span class="k">return</span> <span class="n">P</span>

<span class="k">def</span> <span class="nf">g_analytic</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">g0</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">g0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">gamma</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Solve the given problem</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1"># Set seed such that the weight are initialized</span>
    <span class="c1"># with same weights and biases for every run.</span>
    <span class="n">npr</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>

    <span class="c1">## Decide the vales of arguments to the function to solve</span>
    <span class="n">N</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>

    <span class="c1">## Set up the initial parameters</span>
    <span class="n">num_hidden_neurons</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">num_iter</span> <span class="o">=</span> <span class="mi">10000</span>
    <span class="n">lmb</span> <span class="o">=</span> <span class="mf">0.001</span>

    <span class="c1"># Use the network</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">solve_ode_neural_network</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">num_hidden_neurons</span><span class="p">,</span> <span class="n">num_iter</span><span class="p">,</span> <span class="n">lmb</span><span class="p">)</span>

    <span class="c1"># Print the deviation from the trial solution and true solution</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">g_trial</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">P</span><span class="p">)</span>
    <span class="n">res_analytical</span> <span class="o">=</span> <span class="n">g_analytic</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Max absolute difference: </span><span class="si">%g</span><span class="s1">&#39;</span><span class="o">%</span><span class="k">np</span>.max(np.abs(res - res_analytical)))

    <span class="c1"># Plot the results</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Performance of neural network solving an ODE compared to the analytical solution&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">res_analytical</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;analytical&#39;</span><span class="p">,</span><span class="s1">&#39;nn&#39;</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;g(x)&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Initial cost: 367.01
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Final cost: 0.0666807
Max absolute difference: 0.0437499
</pre></div>
</div>
<img alt="_images/chapter11_50_2.png" src="_images/chapter11_50_2.png" />
</div>
</div>
</div>
<div class="section" id="the-network-with-one-input-layer-specified-number-of-hidden-layers-and-one-output-layer">
<h2><span class="section-number">15.5. </span>The network with one input layer, specified number of hidden layers, and one output layer<a class="headerlink" href="#the-network-with-one-input-layer-specified-number-of-hidden-layers-and-one-output-layer" title="Permalink to this headline">¶</a></h2>
<p>It is also possible to extend the construction of our network into a more general one, allowing the network to contain more than one hidden layers.</p>
<p>The number of neurons within each hidden layer are given as a list of integers in the program below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">autograd.numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">autograd</span> <span class="kn">import</span> <span class="n">grad</span><span class="p">,</span> <span class="n">elementwise_grad</span>
<span class="kn">import</span> <span class="nn">autograd.numpy.random</span> <span class="k">as</span> <span class="nn">npr</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="k">def</span> <span class="nf">sigmoid</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">z</span><span class="p">))</span>

<span class="c1"># The neural network with one input layer and one output layer,</span>
<span class="c1"># but with number of hidden layers specified by the user.</span>
<span class="k">def</span> <span class="nf">deep_neural_network</span><span class="p">(</span><span class="n">deep_params</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="c1"># N_hidden is the number of hidden layers</span>

    <span class="n">N_hidden</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">deep_params</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># -1 since params consists of</span>
                                        <span class="c1"># parameters to all the hidden</span>
                                        <span class="c1"># layers AND the output layer.</span>

    <span class="c1"># Assumes input x being an one-dimensional array</span>
    <span class="n">num_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_values</span><span class="p">)</span>

    <span class="c1"># Assume that the input layer does nothing to the input x</span>
    <span class="n">x_input</span> <span class="o">=</span> <span class="n">x</span>

    <span class="c1"># Due to multiple hidden layers, define a variable referencing to the</span>
    <span class="c1"># output of the previous layer:</span>
    <span class="n">x_prev</span> <span class="o">=</span> <span class="n">x_input</span>

    <span class="c1">## Hidden layers:</span>

    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_hidden</span><span class="p">):</span>
        <span class="c1"># From the list of parameters P; find the correct weigths and bias for this layer</span>
        <span class="n">w_hidden</span> <span class="o">=</span> <span class="n">deep_params</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>

        <span class="c1"># Add a row of ones to include bias</span>
        <span class="n">x_prev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">num_values</span><span class="p">)),</span> <span class="n">x_prev</span> <span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">z_hidden</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">w_hidden</span><span class="p">,</span> <span class="n">x_prev</span><span class="p">)</span>
        <span class="n">x_hidden</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">z_hidden</span><span class="p">)</span>

        <span class="c1"># Update x_prev such that next layer can use the output from this layer</span>
        <span class="n">x_prev</span> <span class="o">=</span> <span class="n">x_hidden</span>

    <span class="c1">## Output layer:</span>

    <span class="c1"># Get the weights and bias for this layer</span>
    <span class="n">w_output</span> <span class="o">=</span> <span class="n">deep_params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Include bias:</span>
    <span class="n">x_prev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">num_values</span><span class="p">)),</span> <span class="n">x_prev</span><span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">z_output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">w_output</span><span class="p">,</span> <span class="n">x_prev</span><span class="p">)</span>
    <span class="n">x_output</span> <span class="o">=</span> <span class="n">z_output</span>

    <span class="k">return</span> <span class="n">x_output</span>

<span class="c1"># The trial solution using the deep neural network:</span>
<span class="k">def</span> <span class="nf">g_trial_deep</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">params</span><span class="p">,</span> <span class="n">g0</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">g0</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">deep_neural_network</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

<span class="c1"># The right side of the ODE:</span>
<span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">g_trial</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="mi">2</span><span class="p">):</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">gamma</span><span class="o">*</span><span class="n">g_trial</span>

<span class="c1"># The same cost function as before, but calls deep_neural_network instead.</span>
<span class="k">def</span> <span class="nf">cost_function_deep</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>

    <span class="c1"># Evaluate the trial function with the current parameters P</span>
    <span class="n">g_t</span> <span class="o">=</span> <span class="n">g_trial_deep</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">P</span><span class="p">)</span>

    <span class="c1"># Find the derivative w.r.t x of the neural network</span>
    <span class="n">d_net_out</span> <span class="o">=</span> <span class="n">elementwise_grad</span><span class="p">(</span><span class="n">deep_neural_network</span><span class="p">,</span><span class="mi">1</span><span class="p">)(</span><span class="n">P</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># Find the derivative w.r.t x of the trial function</span>
    <span class="n">d_g_t</span> <span class="o">=</span> <span class="n">elementwise_grad</span><span class="p">(</span><span class="n">g_trial_deep</span><span class="p">,</span><span class="mi">0</span><span class="p">)(</span><span class="n">x</span><span class="p">,</span><span class="n">P</span><span class="p">)</span>

    <span class="c1"># The right side of the ODE</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">g_t</span><span class="p">)</span>

    <span class="n">err_sqr</span> <span class="o">=</span> <span class="p">(</span><span class="n">d_g_t</span> <span class="o">-</span> <span class="n">func</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">cost_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">err_sqr</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cost_sum</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">err_sqr</span><span class="p">)</span>

<span class="c1"># Solve the exponential decay ODE using neural network with one input and one output layer,</span>
<span class="c1"># but with specified number of hidden layers from the user.</span>
<span class="k">def</span> <span class="nf">solve_ode_deep_neural_network</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">num_neurons</span><span class="p">,</span> <span class="n">num_iter</span><span class="p">,</span> <span class="n">lmb</span><span class="p">):</span>
    <span class="c1"># num_hidden_neurons is now a list of number of neurons within each hidden layer</span>

    <span class="c1"># The number of elements in the list num_hidden_neurons thus represents</span>
    <span class="c1"># the number of hidden layers.</span>

    <span class="c1"># Find the number of hidden layers:</span>
    <span class="n">N_hidden</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">num_neurons</span><span class="p">)</span>

    <span class="c1">## Set up initial weights and biases</span>

    <span class="c1"># Initialize the list of parameters:</span>
    <span class="n">P</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">N_hidden</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># + 1 to include the output layer</span>

    <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">npr</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">num_neurons</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span> <span class="p">)</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">N_hidden</span><span class="p">):</span>
        <span class="n">P</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">npr</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">num_neurons</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="n">num_neurons</span><span class="p">[</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># +1 to include bias</span>

    <span class="c1"># For the output layer</span>
    <span class="n">P</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">npr</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_neurons</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span> <span class="c1"># +1 since bias is included</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Initial cost: </span><span class="si">%g</span><span class="s1">&#39;</span><span class="o">%</span><span class="k">cost_function_deep</span>(P, x))

    <span class="c1">## Start finding the optimal weights using gradient descent</span>

    <span class="c1"># Find the Python function that represents the gradient of the cost function</span>
    <span class="c1"># w.r.t the 0-th input argument -- that is the weights and biases in the hidden and output layer</span>
    <span class="n">cost_function_deep_grad</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="n">cost_function_deep</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Let the update be done num_iter times</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_iter</span><span class="p">):</span>
        <span class="c1"># Evaluate the gradient at the current weights and biases in P.</span>
        <span class="c1"># The cost_grad consist now of N_hidden + 1 arrays; the gradient w.r.t the weights and biases</span>
        <span class="c1"># in the hidden layers and output layers evaluated at x.</span>
        <span class="n">cost_deep_grad</span> <span class="o">=</span>  <span class="n">cost_function_deep_grad</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_hidden</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">P</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">-</span> <span class="n">lmb</span> <span class="o">*</span> <span class="n">cost_deep_grad</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Final cost: </span><span class="si">%g</span><span class="s1">&#39;</span><span class="o">%</span><span class="k">cost_function_deep</span>(P, x))

    <span class="k">return</span> <span class="n">P</span>

<span class="k">def</span> <span class="nf">g_analytic</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">g0</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">g0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">gamma</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Solve the given problem</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">npr</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>

    <span class="c1">## Decide the vales of arguments to the function to solve</span>
    <span class="n">N</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>

    <span class="c1">## Set up the initial parameters</span>
    <span class="n">num_hidden_neurons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
    <span class="n">num_iter</span> <span class="o">=</span> <span class="mi">10000</span>
    <span class="n">lmb</span> <span class="o">=</span> <span class="mf">0.001</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">solve_ode_deep_neural_network</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">num_hidden_neurons</span><span class="p">,</span> <span class="n">num_iter</span><span class="p">,</span> <span class="n">lmb</span><span class="p">)</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">g_trial_deep</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">P</span><span class="p">)</span>
    <span class="n">res_analytical</span> <span class="o">=</span> <span class="n">g_analytic</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Performance of a deep neural network solving an ODE compared to the analytical solution&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">res_analytical</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;analytical&#39;</span><span class="p">,</span><span class="s1">&#39;dnn&#39;</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;g(x)&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Initial cost: 324.246
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>/Users/mhjensen/miniforge3/envs/myenv/lib/python3.9/site-packages/numpy/core/fromnumeric.py:3208: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify &#39;dtype=object&#39; when creating the ndarray.
  return asarray(a).size
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Final cost: 0.119936
</pre></div>
</div>
<img alt="_images/chapter11_52_3.png" src="_images/chapter11_52_3.png" />
</div>
</div>
<div class="section" id="example-population-growth">
<h3><span class="section-number">15.5.1. </span>Example: Population growth<a class="headerlink" href="#example-population-growth" title="Permalink to this headline">¶</a></h3>
<p>A logistic model of population growth assumes that a population converges toward an equilibrium.
The population growth can be modeled by</p>
<!-- Equation labels as ordinary links -->
<div id="log"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation} \label{log} \tag{10}
	g'(t) = \alpha g(t)(A - g(t))
\end{equation}
\]</div>
<p>where <span class="math notranslate nohighlight">\(g(t)\)</span> is the population density at time <span class="math notranslate nohighlight">\(t\)</span>, <span class="math notranslate nohighlight">\(\alpha &gt; 0\)</span> the growth rate and <span class="math notranslate nohighlight">\(A &gt; 0\)</span> is the maximum population number in the environment.
Also, at <span class="math notranslate nohighlight">\(t = 0\)</span> the population has the size <span class="math notranslate nohighlight">\(g(0) = g_0\)</span>, where <span class="math notranslate nohighlight">\(g_0\)</span> is some chosen constant.</p>
<p>In this example, similar network as for the exponential decay using Autograd has been used to solve the equation. However, as the implementation might suffer from e.g numerical instability
and high execution time (this might be more apparent in the examples solving PDEs),
using a library like  TensorFlow is recommended.
Here, we stay with a more simple approach and implement for comparison, the simple forward Euler method.</p>
<p>Here, we will model a population <span class="math notranslate nohighlight">\(g(t)\)</span> in an environment having carrying capacity <span class="math notranslate nohighlight">\(A\)</span>.
The population follows the model</p>
<!-- Equation labels as ordinary links -->
<div id="solveode_population"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation} \label{solveode_population} \tag{11}
g'(t) = \alpha g(t)(A - g(t))
\end{equation}
\]</div>
<p>where <span class="math notranslate nohighlight">\(g(0) = g_0\)</span>.</p>
<p>In this example, we let <span class="math notranslate nohighlight">\(\alpha = 2\)</span>, <span class="math notranslate nohighlight">\(A = 1\)</span>, and <span class="math notranslate nohighlight">\(g_0 = 1.2\)</span>.</p>
<p>We will get a slightly different trial solution, as the boundary conditions are different
compared to the case for exponential decay.</p>
<p>A possible trial solution satisfying the condition <span class="math notranslate nohighlight">\(g(0) = g_0\)</span> could be</p>
<div class="math notranslate nohighlight">
\[
h_1(t) = g_0 + t \cdot N(t,P)
\]</div>
<p>with <span class="math notranslate nohighlight">\(N(t,P)\)</span> being the output from the neural network with weights and biases for each layer collected in the set <span class="math notranslate nohighlight">\(P\)</span>.</p>
<p>The analytical solution is</p>
<div class="math notranslate nohighlight">
\[
g(t) = \frac{Ag_0}{g_0 + (A - g_0)\exp(-\alpha A t)}
\]</div>
<p>The network will be the similar as for the exponential decay example, but with some small modifications for our problem.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">autograd.numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">autograd</span> <span class="kn">import</span> <span class="n">grad</span><span class="p">,</span> <span class="n">elementwise_grad</span>
<span class="kn">import</span> <span class="nn">autograd.numpy.random</span> <span class="k">as</span> <span class="nn">npr</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="k">def</span> <span class="nf">sigmoid</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">z</span><span class="p">))</span>

<span class="c1"># Function to get the parameters.</span>
<span class="c1"># Done such that one can easily change the paramaters after one&#39;s liking.</span>
<span class="k">def</span> <span class="nf">get_parameters</span><span class="p">():</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">A</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">g0</span> <span class="o">=</span> <span class="mf">1.2</span>
    <span class="k">return</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">g0</span>

<span class="k">def</span> <span class="nf">deep_neural_network</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="c1"># N_hidden is the number of hidden layers</span>
    <span class="n">N_hidden</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># -1 since params consist of parameters to all the hidden layers AND the output layer</span>

    <span class="c1"># Assumes input x being an one-dimensional array</span>
    <span class="n">num_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_values</span><span class="p">)</span>

    <span class="c1"># Assume that the input layer does nothing to the input x</span>
    <span class="n">x_input</span> <span class="o">=</span> <span class="n">x</span>

    <span class="c1"># Due to multiple hidden layers, define a variable referencing to the</span>
    <span class="c1"># output of the previous layer:</span>
    <span class="n">x_prev</span> <span class="o">=</span> <span class="n">x_input</span>

    <span class="c1">## Hidden layers:</span>

    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_hidden</span><span class="p">):</span>
        <span class="c1"># From the list of parameters P; find the correct weigths and bias for this layer</span>
        <span class="n">w_hidden</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>

        <span class="c1"># Add a row of ones to include bias</span>
        <span class="n">x_prev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">num_values</span><span class="p">)),</span> <span class="n">x_prev</span> <span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">z_hidden</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">w_hidden</span><span class="p">,</span> <span class="n">x_prev</span><span class="p">)</span>
        <span class="n">x_hidden</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">z_hidden</span><span class="p">)</span>

        <span class="c1"># Update x_prev such that next layer can use the output from this layer</span>
        <span class="n">x_prev</span> <span class="o">=</span> <span class="n">x_hidden</span>

    <span class="c1">## Output layer:</span>

    <span class="c1"># Get the weights and bias for this layer</span>
    <span class="n">w_output</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Include bias:</span>
    <span class="n">x_prev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">num_values</span><span class="p">)),</span> <span class="n">x_prev</span><span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">z_output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">w_output</span><span class="p">,</span> <span class="n">x_prev</span><span class="p">)</span>
    <span class="n">x_output</span> <span class="o">=</span> <span class="n">z_output</span>

    <span class="k">return</span> <span class="n">x_output</span>


<span class="k">def</span> <span class="nf">cost_function_deep</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>

    <span class="c1"># Evaluate the trial function with the current parameters P</span>
    <span class="n">g_t</span> <span class="o">=</span> <span class="n">g_trial_deep</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">P</span><span class="p">)</span>

    <span class="c1"># Find the derivative w.r.t x of the trial function</span>
    <span class="n">d_g_t</span> <span class="o">=</span> <span class="n">elementwise_grad</span><span class="p">(</span><span class="n">g_trial_deep</span><span class="p">,</span><span class="mi">0</span><span class="p">)(</span><span class="n">x</span><span class="p">,</span><span class="n">P</span><span class="p">)</span>

    <span class="c1"># The right side of the ODE</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">g_t</span><span class="p">)</span>

    <span class="n">err_sqr</span> <span class="o">=</span> <span class="p">(</span><span class="n">d_g_t</span> <span class="o">-</span> <span class="n">func</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">cost_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">err_sqr</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cost_sum</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">err_sqr</span><span class="p">)</span>

<span class="c1"># The right side of the ODE:</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">g_trial</span><span class="p">):</span>
    <span class="n">alpha</span><span class="p">,</span><span class="n">A</span><span class="p">,</span> <span class="n">g0</span> <span class="o">=</span> <span class="n">get_parameters</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">alpha</span><span class="o">*</span><span class="n">g_trial</span><span class="o">*</span><span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="n">g_trial</span><span class="p">)</span>

<span class="c1"># The trial solution using the deep neural network:</span>
<span class="k">def</span> <span class="nf">g_trial_deep</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
    <span class="n">alpha</span><span class="p">,</span><span class="n">A</span><span class="p">,</span> <span class="n">g0</span> <span class="o">=</span> <span class="n">get_parameters</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">g0</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">deep_neural_network</span><span class="p">(</span><span class="n">params</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># The analytical solution:</span>
<span class="k">def</span> <span class="nf">g_analytic</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="n">alpha</span><span class="p">,</span><span class="n">A</span><span class="p">,</span> <span class="n">g0</span> <span class="o">=</span> <span class="n">get_parameters</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">A</span><span class="o">*</span><span class="n">g0</span><span class="o">/</span><span class="p">(</span><span class="n">g0</span> <span class="o">+</span> <span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="n">g0</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">alpha</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">t</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">solve_ode_deep_neural_network</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">num_neurons</span><span class="p">,</span> <span class="n">num_iter</span><span class="p">,</span> <span class="n">lmb</span><span class="p">):</span>
    <span class="c1"># num_hidden_neurons is now a list of number of neurons within each hidden layer</span>

    <span class="c1"># Find the number of hidden layers:</span>
    <span class="n">N_hidden</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">num_neurons</span><span class="p">)</span>

    <span class="c1">## Set up initial weigths and biases</span>

    <span class="c1"># Initialize the list of parameters:</span>
    <span class="n">P</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">N_hidden</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># + 1 to include the output layer</span>

    <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">npr</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">num_neurons</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span> <span class="p">)</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">N_hidden</span><span class="p">):</span>
        <span class="n">P</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">npr</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">num_neurons</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="n">num_neurons</span><span class="p">[</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># +1 to include bias</span>

    <span class="c1"># For the output layer</span>
    <span class="n">P</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">npr</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_neurons</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span> <span class="c1"># +1 since bias is included</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Initial cost: </span><span class="si">%g</span><span class="s1">&#39;</span><span class="o">%</span><span class="k">cost_function_deep</span>(P, x))

    <span class="c1">## Start finding the optimal weigths using gradient descent</span>

    <span class="c1"># Find the Python function that represents the gradient of the cost function</span>
    <span class="c1"># w.r.t the 0-th input argument -- that is the weights and biases in the hidden and output layer</span>
    <span class="n">cost_function_deep_grad</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="n">cost_function_deep</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Let the update be done num_iter times</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_iter</span><span class="p">):</span>
        <span class="c1"># Evaluate the gradient at the current weights and biases in P.</span>
        <span class="c1"># The cost_grad consist now of N_hidden + 1 arrays; the gradient w.r.t the weights and biases</span>
        <span class="c1"># in the hidden layers and output layers evaluated at x.</span>
        <span class="n">cost_deep_grad</span> <span class="o">=</span>  <span class="n">cost_function_deep_grad</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_hidden</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">P</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">-</span> <span class="n">lmb</span> <span class="o">*</span> <span class="n">cost_deep_grad</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Final cost: </span><span class="si">%g</span><span class="s1">&#39;</span><span class="o">%</span><span class="k">cost_function_deep</span>(P, x))

    <span class="k">return</span> <span class="n">P</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">npr</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">4155</span><span class="p">)</span>

    <span class="c1">## Decide the vales of arguments to the function to solve</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">T</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">T</span><span class="p">,</span> <span class="n">Nt</span><span class="p">)</span>

    <span class="c1">## Set up the initial parameters</span>
    <span class="n">num_hidden_neurons</span> <span class="o">=</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">25</span><span class="p">]</span>
    <span class="n">num_iter</span> <span class="o">=</span> <span class="mi">1000</span>
    <span class="n">lmb</span> <span class="o">=</span> <span class="mf">1e-3</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">solve_ode_deep_neural_network</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">num_hidden_neurons</span><span class="p">,</span> <span class="n">num_iter</span><span class="p">,</span> <span class="n">lmb</span><span class="p">)</span>

    <span class="n">g_dnn_ag</span> <span class="o">=</span> <span class="n">g_trial_deep</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">P</span><span class="p">)</span>
    <span class="n">g_analytical</span> <span class="o">=</span> <span class="n">g_analytic</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="c1"># Find the maximum absolute difference between the solutons:</span>
    <span class="n">diff_ag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">g_dnn_ag</span> <span class="o">-</span> <span class="n">g_analytical</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The max absolute difference between the solutions is: </span><span class="si">%g</span><span class="s2">&quot;</span><span class="o">%</span><span class="k">diff_ag</span>)

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Performance of neural network solving an ODE compared to the analytical solution&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">g_analytical</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">g_dnn_ag</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;analytical&#39;</span><span class="p">,</span><span class="s1">&#39;nn&#39;</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;g(t)&#39;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Initial cost: 0.221805
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>/Users/mhjensen/miniforge3/envs/myenv/lib/python3.9/site-packages/numpy/core/fromnumeric.py:3208: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify &#39;dtype=object&#39; when creating the ndarray.
  return asarray(a).size
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Final cost: 0.000417932
The max absolute difference between the solutions is: 0.00424909
</pre></div>
</div>
<img alt="_images/chapter11_58_3.png" src="_images/chapter11_58_3.png" />
</div>
</div>
</div>
</div>
<div class="section" id="using-forward-euler-to-solve-the-ode">
<h2><span class="section-number">15.6. </span>Using forward Euler to solve the ODE<a class="headerlink" href="#using-forward-euler-to-solve-the-ode" title="Permalink to this headline">¶</a></h2>
<p>A straightforward way of solving an ODE numerically, is to use Euler’s method.</p>
<p>Euler’s method uses Taylor series to approximate the value at a function <span class="math notranslate nohighlight">\(f\)</span> at a step <span class="math notranslate nohighlight">\(\Delta x\)</span> from <span class="math notranslate nohighlight">\(x\)</span>:</p>
<div class="math notranslate nohighlight">
\[
f(x + \Delta x) \approx f(x) + \Delta x f'(x)
\]</div>
<p>In our case, using Euler’s method to approximate the value of <span class="math notranslate nohighlight">\(g\)</span> at a step <span class="math notranslate nohighlight">\(\Delta t\)</span> from <span class="math notranslate nohighlight">\(t\)</span> yields</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
  g(t + \Delta t) &amp;\approx g(t) + \Delta t g'(t) \\
  &amp;= g(t) + \Delta t \big(\alpha g(t)(A - g(t))\big)
\end{aligned}
\end{split}\]</div>
<p>along with the condition that <span class="math notranslate nohighlight">\(g(0) = g_0\)</span>.</p>
<p>Let <span class="math notranslate nohighlight">\(t_i = i \cdot \Delta t\)</span> where <span class="math notranslate nohighlight">\(\Delta t = \frac{T}{N_t-1}\)</span> where <span class="math notranslate nohighlight">\(T\)</span> is the final time our solver must solve for and <span class="math notranslate nohighlight">\(N_t\)</span> the number of values for <span class="math notranslate nohighlight">\(t \in [0, T]\)</span> for <span class="math notranslate nohighlight">\(i = 0, \dots, N_t-1\)</span>.</p>
<p>For <span class="math notranslate nohighlight">\(i \geq 1\)</span>, we have that</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
t_i &amp;= i\Delta t \\
&amp;= (i - 1)\Delta t + \Delta t \\
&amp;= t_{i-1} + \Delta t
\end{aligned}
\end{split}\]</div>
<p>Now, if <span class="math notranslate nohighlight">\(g_i = g(t_i)\)</span> then</p>
<!-- Equation labels as ordinary links -->
<div id="odenum"></div>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{equation}
  \begin{aligned}
  g_i &amp;= g(t_i) \\
  &amp;= g(t_{i-1} + \Delta t) \\
  &amp;\approx g(t_{i-1}) + \Delta t \big(\alpha g(t_{i-1})(A - g(t_{i-1}))\big) \\
  &amp;= g_{i-1} + \Delta t \big(\alpha g_{i-1}(A - g_{i-1})\big)
  \end{aligned}
\end{equation} \label{odenum} \tag{12}
\end{split}\]</div>
<p>for <span class="math notranslate nohighlight">\(i \geq 1\)</span> and <span class="math notranslate nohighlight">\(g_0 = g(t_0) = g(0) = g_0\)</span>.</p>
<p>Equation (<a class="reference external" href="#odenum">12</a>) could be implemented in the following way,
extending the program that uses the network using Autograd:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Assume that all function definitions from the example program using Autograd</span>
<span class="c1"># are located here.</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">npr</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">4155</span><span class="p">)</span>

    <span class="c1">## Decide the vales of arguments to the function to solve</span>
    <span class="n">Nt</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">T</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">T</span><span class="p">,</span> <span class="n">Nt</span><span class="p">)</span>

    <span class="c1">## Set up the initial parameters</span>
    <span class="n">num_hidden_neurons</span> <span class="o">=</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">25</span><span class="p">]</span>
    <span class="n">num_iter</span> <span class="o">=</span> <span class="mi">1000</span>
    <span class="n">lmb</span> <span class="o">=</span> <span class="mf">1e-3</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">solve_ode_deep_neural_network</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">num_hidden_neurons</span><span class="p">,</span> <span class="n">num_iter</span><span class="p">,</span> <span class="n">lmb</span><span class="p">)</span>

    <span class="n">g_dnn_ag</span> <span class="o">=</span> <span class="n">g_trial_deep</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">P</span><span class="p">)</span>
    <span class="n">g_analytical</span> <span class="o">=</span> <span class="n">g_analytic</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="c1"># Find the maximum absolute difference between the solutons:</span>
    <span class="n">diff_ag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">g_dnn_ag</span> <span class="o">-</span> <span class="n">g_analytical</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The max absolute difference between the solutions is: </span><span class="si">%g</span><span class="s2">&quot;</span><span class="o">%</span><span class="k">diff_ag</span>)

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Performance of neural network solving an ODE compared to the analytical solution&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">g_analytical</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">g_dnn_ag</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;analytical&#39;</span><span class="p">,</span><span class="s1">&#39;nn&#39;</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;g(t)&#39;</span><span class="p">)</span>

    <span class="c1">## Find an approximation to the funtion using forward Euler</span>

    <span class="n">alpha</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">g0</span> <span class="o">=</span> <span class="n">get_parameters</span><span class="p">()</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">T</span><span class="o">/</span><span class="p">(</span><span class="n">Nt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Perform forward Euler to solve the ODE</span>
    <span class="n">g_euler</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nt</span><span class="p">)</span>
    <span class="n">g_euler</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">g0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">Nt</span><span class="p">):</span>
        <span class="n">g_euler</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">g_euler</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="p">(</span><span class="n">alpha</span><span class="o">*</span><span class="n">g_euler</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">A</span> <span class="o">-</span> <span class="n">g_euler</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

    <span class="c1"># Print the errors done by each method</span>
    <span class="n">diff1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">g_euler</span> <span class="o">-</span> <span class="n">g_analytical</span><span class="p">))</span>
    <span class="n">diff2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">g_dnn_ag</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">-</span> <span class="n">g_analytical</span><span class="p">))</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Max absolute difference between Euler method and analytical: </span><span class="si">%g</span><span class="s1">&#39;</span><span class="o">%</span><span class="k">diff1</span>)
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Max absolute difference between deep neural network and analytical: </span><span class="si">%g</span><span class="s1">&#39;</span><span class="o">%</span><span class="k">diff2</span>)

    <span class="c1"># Plot results</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">g_euler</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">g_analytical</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">g_dnn_ag</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;euler&#39;</span><span class="p">,</span><span class="s1">&#39;analytical&#39;</span><span class="p">,</span><span class="s1">&#39;dnn&#39;</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time t&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;g(t)&#39;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Initial cost: 0.221805
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>/Users/mhjensen/miniforge3/envs/myenv/lib/python3.9/site-packages/numpy/core/fromnumeric.py:3208: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify &#39;dtype=object&#39; when creating the ndarray.
  return asarray(a).size
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Final cost: 0.000417932
The max absolute difference between the solutions is: 0.00424909
Max absolute difference between Euler method and analytical: 0.011225
Max absolute difference between deep neural network and analytical: 0.00424909
</pre></div>
</div>
<img alt="_images/chapter11_66_3.png" src="_images/chapter11_66_3.png" />
<img alt="_images/chapter11_66_4.png" src="_images/chapter11_66_4.png" />
</div>
</div>
</div>
<div class="section" id="solving-the-one-dimensional-poisson-equation">
<h2><span class="section-number">15.7. </span>Solving the one dimensional Poisson equation<a class="headerlink" href="#solving-the-one-dimensional-poisson-equation" title="Permalink to this headline">¶</a></h2>
<p>The Poisson equation for <span class="math notranslate nohighlight">\(g(x)\)</span> in one dimension is</p>
<!-- Equation labels as ordinary links -->
<div id="poisson"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation} \label{poisson} \tag{13}
  -g''(x) = f(x)
\end{equation}
\]</div>
<p>where <span class="math notranslate nohighlight">\(f(x)\)</span> is a given function for <span class="math notranslate nohighlight">\(x \in (0,1)\)</span>.</p>
<p>The conditions that <span class="math notranslate nohighlight">\(g(x)\)</span> is chosen to fulfill, are</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
  g(0) &amp;= 0 \\
  g(1) &amp;= 0
\end{align*}
\end{split}\]</div>
<p>This equation can be solved numerically using programs where e.g Autograd and TensorFlow are used.
The results from the networks can then be compared to the analytical solution.
In addition, it could be interesting to see how a typical method for numerically solving second order ODEs compares to the neural networks.</p>
<p>Here, the function <span class="math notranslate nohighlight">\(g(x)\)</span> to solve for follows the equation</p>
<div class="math notranslate nohighlight">
\[
-g''(x) = f(x),\qquad x \in (0,1)
\]</div>
<p>where <span class="math notranslate nohighlight">\(f(x)\)</span> is a given function, along with the chosen conditions</p>
<!-- Equation labels as ordinary links -->
<div id="cond"></div>
<div class="math notranslate nohighlight">
\[
\begin{aligned}
g(0) = g(1) = 0
\end{aligned}\label{cond} \tag{14}
\]</div>
<p>In this example, we consider the case when <span class="math notranslate nohighlight">\(f(x) = (3x + x^2)\exp(x)\)</span>.</p>
<p>For this case, a possible trial solution satisfying the conditions could be</p>
<div class="math notranslate nohighlight">
\[
g_t(x) = x \cdot (1-x) \cdot N(P,x)
\]</div>
<p>The analytical solution for this problem is</p>
<div class="math notranslate nohighlight">
\[
g(x) = x(1 - x)\exp(x)
\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">autograd.numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">autograd</span> <span class="kn">import</span> <span class="n">grad</span><span class="p">,</span> <span class="n">elementwise_grad</span>
<span class="kn">import</span> <span class="nn">autograd.numpy.random</span> <span class="k">as</span> <span class="nn">npr</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="k">def</span> <span class="nf">sigmoid</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">z</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">deep_neural_network</span><span class="p">(</span><span class="n">deep_params</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="c1"># N_hidden is the number of hidden layers</span>
    <span class="n">N_hidden</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">deep_params</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># -1 since params consist of parameters to all the hidden layers AND the output layer</span>

    <span class="c1"># Assumes input x being an one-dimensional array</span>
    <span class="n">num_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_values</span><span class="p">)</span>

    <span class="c1"># Assume that the input layer does nothing to the input x</span>
    <span class="n">x_input</span> <span class="o">=</span> <span class="n">x</span>

    <span class="c1"># Due to multiple hidden layers, define a variable referencing to the</span>
    <span class="c1"># output of the previous layer:</span>
    <span class="n">x_prev</span> <span class="o">=</span> <span class="n">x_input</span>

    <span class="c1">## Hidden layers:</span>

    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_hidden</span><span class="p">):</span>
        <span class="c1"># From the list of parameters P; find the correct weigths and bias for this layer</span>
        <span class="n">w_hidden</span> <span class="o">=</span> <span class="n">deep_params</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>

        <span class="c1"># Add a row of ones to include bias</span>
        <span class="n">x_prev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">num_values</span><span class="p">)),</span> <span class="n">x_prev</span> <span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">z_hidden</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">w_hidden</span><span class="p">,</span> <span class="n">x_prev</span><span class="p">)</span>
        <span class="n">x_hidden</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">z_hidden</span><span class="p">)</span>

        <span class="c1"># Update x_prev such that next layer can use the output from this layer</span>
        <span class="n">x_prev</span> <span class="o">=</span> <span class="n">x_hidden</span>

    <span class="c1">## Output layer:</span>

    <span class="c1"># Get the weights and bias for this layer</span>
    <span class="n">w_output</span> <span class="o">=</span> <span class="n">deep_params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Include bias:</span>
    <span class="n">x_prev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">num_values</span><span class="p">)),</span> <span class="n">x_prev</span><span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">z_output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">w_output</span><span class="p">,</span> <span class="n">x_prev</span><span class="p">)</span>
    <span class="n">x_output</span> <span class="o">=</span> <span class="n">z_output</span>

    <span class="k">return</span> <span class="n">x_output</span>

<span class="k">def</span> <span class="nf">solve_ode_deep_neural_network</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">num_neurons</span><span class="p">,</span> <span class="n">num_iter</span><span class="p">,</span> <span class="n">lmb</span><span class="p">):</span>
    <span class="c1"># num_hidden_neurons is now a list of number of neurons within each hidden layer</span>

    <span class="c1"># Find the number of hidden layers:</span>
    <span class="n">N_hidden</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">num_neurons</span><span class="p">)</span>

    <span class="c1">## Set up initial weigths and biases</span>

    <span class="c1"># Initialize the list of parameters:</span>
    <span class="n">P</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">N_hidden</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># + 1 to include the output layer</span>

    <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">npr</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">num_neurons</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span> <span class="p">)</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">N_hidden</span><span class="p">):</span>
        <span class="n">P</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">npr</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">num_neurons</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="n">num_neurons</span><span class="p">[</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># +1 to include bias</span>

    <span class="c1"># For the output layer</span>
    <span class="n">P</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">npr</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_neurons</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span> <span class="c1"># +1 since bias is included</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Initial cost: </span><span class="si">%g</span><span class="s1">&#39;</span><span class="o">%</span><span class="k">cost_function_deep</span>(P, x))

    <span class="c1">## Start finding the optimal weigths using gradient descent</span>

    <span class="c1"># Find the Python function that represents the gradient of the cost function</span>
    <span class="c1"># w.r.t the 0-th input argument -- that is the weights and biases in the hidden and output layer</span>
    <span class="n">cost_function_deep_grad</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="n">cost_function_deep</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Let the update be done num_iter times</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_iter</span><span class="p">):</span>
        <span class="c1"># Evaluate the gradient at the current weights and biases in P.</span>
        <span class="c1"># The cost_grad consist now of N_hidden + 1 arrays; the gradient w.r.t the weights and biases</span>
        <span class="c1"># in the hidden layers and output layers evaluated at x.</span>
        <span class="n">cost_deep_grad</span> <span class="o">=</span>  <span class="n">cost_function_deep_grad</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_hidden</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">P</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">-</span> <span class="n">lmb</span> <span class="o">*</span> <span class="n">cost_deep_grad</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Final cost: </span><span class="si">%g</span><span class="s1">&#39;</span><span class="o">%</span><span class="k">cost_function_deep</span>(P, x))

    <span class="k">return</span> <span class="n">P</span>

<span class="c1">## Set up the cost function specified for this Poisson equation:</span>

<span class="c1"># The right side of the ODE</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">cost_function_deep</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>

    <span class="c1"># Evaluate the trial function with the current parameters P</span>
    <span class="n">g_t</span> <span class="o">=</span> <span class="n">g_trial_deep</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">P</span><span class="p">)</span>

    <span class="c1"># Find the derivative w.r.t x of the trial function</span>
    <span class="n">d2_g_t</span> <span class="o">=</span> <span class="n">elementwise_grad</span><span class="p">(</span><span class="n">elementwise_grad</span><span class="p">(</span><span class="n">g_trial_deep</span><span class="p">,</span><span class="mi">0</span><span class="p">))(</span><span class="n">x</span><span class="p">,</span><span class="n">P</span><span class="p">)</span>

    <span class="n">right_side</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="n">err_sqr</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">d2_g_t</span> <span class="o">-</span> <span class="n">right_side</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">cost_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">err_sqr</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cost_sum</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">err_sqr</span><span class="p">)</span>

<span class="c1"># The trial solution:</span>
<span class="k">def</span> <span class="nf">g_trial_deep</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">P</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">deep_neural_network</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># The analytic solution;</span>
<span class="k">def</span> <span class="nf">g_analytic</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">npr</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">4155</span><span class="p">)</span>

    <span class="c1">## Decide the vales of arguments to the function to solve</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">)</span>

    <span class="c1">## Set up the initial parameters</span>
    <span class="n">num_hidden_neurons</span> <span class="o">=</span> <span class="p">[</span><span class="mi">200</span><span class="p">,</span><span class="mi">100</span><span class="p">]</span>
    <span class="n">num_iter</span> <span class="o">=</span> <span class="mi">1000</span>
    <span class="n">lmb</span> <span class="o">=</span> <span class="mf">1e-3</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">solve_ode_deep_neural_network</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">num_hidden_neurons</span><span class="p">,</span> <span class="n">num_iter</span><span class="p">,</span> <span class="n">lmb</span><span class="p">)</span>

    <span class="n">g_dnn_ag</span> <span class="o">=</span> <span class="n">g_trial_deep</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">P</span><span class="p">)</span>
    <span class="n">g_analytical</span> <span class="o">=</span> <span class="n">g_analytic</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># Find the maximum absolute difference between the solutons:</span>
    <span class="n">max_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">g_dnn_ag</span> <span class="o">-</span> <span class="n">g_analytical</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The max absolute difference between the solutions is: </span><span class="si">%g</span><span class="s2">&quot;</span><span class="o">%</span><span class="k">max_diff</span>)

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Performance of neural network solving an ODE compared to the analytical solution&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">g_analytical</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">g_dnn_ag</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;analytical&#39;</span><span class="p">,</span><span class="s1">&#39;nn&#39;</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;g(x)&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Initial cost: 457.256
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>/Users/mhjensen/miniforge3/envs/myenv/lib/python3.9/site-packages/numpy/core/fromnumeric.py:3208: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify &#39;dtype=object&#39; when creating the ndarray.
  return asarray(a).size
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Final cost: 0.00310113
The max absolute difference between the solutions is: 0.000464088
</pre></div>
</div>
<img alt="_images/chapter11_79_3.png" src="_images/chapter11_79_3.png" />
</div>
</div>
<div class="section" id="comparing-with-a-numerical-scheme">
<h3><span class="section-number">15.7.1. </span>Comparing with a numerical scheme<a class="headerlink" href="#comparing-with-a-numerical-scheme" title="Permalink to this headline">¶</a></h3>
<p>The Poisson equation is possible to solve using Taylor series to approximate the second derivative.</p>
<p>Using Taylor series, the second derivative can be expressed as</p>
<div class="math notranslate nohighlight">
\[
g''(x) = \frac{g(x + \Delta x) - 2g(x) + g(x-\Delta x)}{\Delta x^2} + E_{\Delta x}(x)
\]</div>
<p>where <span class="math notranslate nohighlight">\(\Delta x\)</span> is a small step size and <span class="math notranslate nohighlight">\(E_{\Delta x}(x)\)</span> being the error term.</p>
<p>Looking away from the error terms gives an approximation to the second derivative:</p>
<!-- Equation labels as ordinary links -->
<div id="approx"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation} \label{approx} \tag{15}
g''(x) \approx \frac{g(x + \Delta x) - 2g(x) + g(x-\Delta x)}{\Delta x^2}
\end{equation}
\]</div>
<p>If <span class="math notranslate nohighlight">\(x_i = i \Delta x = x_{i-1} + \Delta x\)</span> and <span class="math notranslate nohighlight">\(g_i = g(x_i)\)</span> for <span class="math notranslate nohighlight">\(i = 1,\dots N_x - 2\)</span> with <span class="math notranslate nohighlight">\(N_x\)</span> being the number of values for <span class="math notranslate nohighlight">\(x\)</span>, (<a class="reference external" href="#approx">15</a>) becomes</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
g''(x_i) &amp;\approx \frac{g(x_i + \Delta x) - 2g(x_i) + g(x_i -\Delta x)}{\Delta x^2} \\
&amp;= \frac{g_{i+1} - 2g_i + g_{i-1}}{\Delta x^2}
\end{aligned}
\end{split}\]</div>
<p>Since we know from our problem that</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
-g''(x) &amp;= f(x) \\
&amp;= (3x + x^2)\exp(x)
\end{aligned}
\end{split}\]</div>
<p>along with the conditions <span class="math notranslate nohighlight">\(g(0) = g(1) = 0\)</span>,
the following scheme can be used to find an approximate solution for <span class="math notranslate nohighlight">\(g(x)\)</span> numerically:</p>
<!-- Equation labels as ordinary links -->
<div id="odesys"></div>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{equation}
  \begin{aligned}
  -\Big( \frac{g_{i+1} - 2g_i + g_{i-1}}{\Delta x^2} \Big) &amp;= f(x_i) \\
  -g_{i+1} + 2g_i - g_{i-1} &amp;= \Delta x^2 f(x_i)
  \end{aligned}
\end{equation} \label{odesys} \tag{16}
\end{split}\]</div>
<p>for <span class="math notranslate nohighlight">\(i = 1, \dots, N_x - 2\)</span> where <span class="math notranslate nohighlight">\(g_0 = g_{N_x - 1} = 0\)</span> and <span class="math notranslate nohighlight">\(f(x_i) = (3x_i + x_i^2)\exp(x_i)\)</span>, which is given for our specific problem.</p>
<p>The equation can be rewritten into a matrix equation:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\begin{pmatrix}
2 &amp; -1 &amp; 0 &amp; \dots &amp; 0 \\
-1 &amp; 2 &amp; -1 &amp; \dots &amp; 0 \\
\vdots &amp; &amp; \ddots &amp; &amp; \vdots \\
0 &amp; \dots &amp; -1 &amp; 2 &amp; -1  \\
0 &amp; \dots &amp; 0 &amp; -1 &amp; 2\\
\end{pmatrix}
\begin{pmatrix}
g_1 \\
g_2 \\
\vdots \\
g_{N_x - 3} \\
g_{N_x - 2}
\end{pmatrix}
&amp;=
\Delta x^2
\begin{pmatrix}
f(x_1) \\
f(x_2) \\
\vdots \\
f(x_{N_x - 3}) \\
f(x_{N_x - 2})
\end{pmatrix} \\
\boldsymbol{A}\boldsymbol{g} &amp;= \boldsymbol{f},
\end{aligned}
\end{split}\]</div>
<p>which makes it possible to solve for the vector <span class="math notranslate nohighlight">\(\boldsymbol{g}\)</span>.</p>
<p>We can then compare the result from this numerical scheme with the output from our network using Autograd:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">autograd.numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">autograd</span> <span class="kn">import</span> <span class="n">grad</span><span class="p">,</span> <span class="n">elementwise_grad</span>
<span class="kn">import</span> <span class="nn">autograd.numpy.random</span> <span class="k">as</span> <span class="nn">npr</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="k">def</span> <span class="nf">sigmoid</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">z</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">deep_neural_network</span><span class="p">(</span><span class="n">deep_params</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="c1"># N_hidden is the number of hidden layers</span>
    <span class="n">N_hidden</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">deep_params</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># -1 since params consist of parameters to all the hidden layers AND the output layer</span>

    <span class="c1"># Assumes input x being an one-dimensional array</span>
    <span class="n">num_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_values</span><span class="p">)</span>

    <span class="c1"># Assume that the input layer does nothing to the input x</span>
    <span class="n">x_input</span> <span class="o">=</span> <span class="n">x</span>

    <span class="c1"># Due to multiple hidden layers, define a variable referencing to the</span>
    <span class="c1"># output of the previous layer:</span>
    <span class="n">x_prev</span> <span class="o">=</span> <span class="n">x_input</span>

    <span class="c1">## Hidden layers:</span>

    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_hidden</span><span class="p">):</span>
        <span class="c1"># From the list of parameters P; find the correct weigths and bias for this layer</span>
        <span class="n">w_hidden</span> <span class="o">=</span> <span class="n">deep_params</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>

        <span class="c1"># Add a row of ones to include bias</span>
        <span class="n">x_prev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">num_values</span><span class="p">)),</span> <span class="n">x_prev</span> <span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">z_hidden</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">w_hidden</span><span class="p">,</span> <span class="n">x_prev</span><span class="p">)</span>
        <span class="n">x_hidden</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">z_hidden</span><span class="p">)</span>

        <span class="c1"># Update x_prev such that next layer can use the output from this layer</span>
        <span class="n">x_prev</span> <span class="o">=</span> <span class="n">x_hidden</span>

    <span class="c1">## Output layer:</span>

    <span class="c1"># Get the weights and bias for this layer</span>
    <span class="n">w_output</span> <span class="o">=</span> <span class="n">deep_params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Include bias:</span>
    <span class="n">x_prev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">num_values</span><span class="p">)),</span> <span class="n">x_prev</span><span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">z_output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">w_output</span><span class="p">,</span> <span class="n">x_prev</span><span class="p">)</span>
    <span class="n">x_output</span> <span class="o">=</span> <span class="n">z_output</span>

    <span class="k">return</span> <span class="n">x_output</span>

<span class="k">def</span> <span class="nf">solve_ode_deep_neural_network</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">num_neurons</span><span class="p">,</span> <span class="n">num_iter</span><span class="p">,</span> <span class="n">lmb</span><span class="p">):</span>
    <span class="c1"># num_hidden_neurons is now a list of number of neurons within each hidden layer</span>

    <span class="c1"># Find the number of hidden layers:</span>
    <span class="n">N_hidden</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">num_neurons</span><span class="p">)</span>

    <span class="c1">## Set up initial weigths and biases</span>

    <span class="c1"># Initialize the list of parameters:</span>
    <span class="n">P</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">N_hidden</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># + 1 to include the output layer</span>

    <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">npr</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">num_neurons</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span> <span class="p">)</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">N_hidden</span><span class="p">):</span>
        <span class="n">P</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">npr</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">num_neurons</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="n">num_neurons</span><span class="p">[</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># +1 to include bias</span>

    <span class="c1"># For the output layer</span>
    <span class="n">P</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">npr</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_neurons</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span> <span class="c1"># +1 since bias is included</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Initial cost: </span><span class="si">%g</span><span class="s1">&#39;</span><span class="o">%</span><span class="k">cost_function_deep</span>(P, x))

    <span class="c1">## Start finding the optimal weigths using gradient descent</span>

    <span class="c1"># Find the Python function that represents the gradient of the cost function</span>
    <span class="c1"># w.r.t the 0-th input argument -- that is the weights and biases in the hidden and output layer</span>
    <span class="n">cost_function_deep_grad</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="n">cost_function_deep</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Let the update be done num_iter times</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_iter</span><span class="p">):</span>
        <span class="c1"># Evaluate the gradient at the current weights and biases in P.</span>
        <span class="c1"># The cost_grad consist now of N_hidden + 1 arrays; the gradient w.r.t the weights and biases</span>
        <span class="c1"># in the hidden layers and output layers evaluated at x.</span>
        <span class="n">cost_deep_grad</span> <span class="o">=</span>  <span class="n">cost_function_deep_grad</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_hidden</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">P</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">-</span> <span class="n">lmb</span> <span class="o">*</span> <span class="n">cost_deep_grad</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Final cost: </span><span class="si">%g</span><span class="s1">&#39;</span><span class="o">%</span><span class="k">cost_function_deep</span>(P, x))

    <span class="k">return</span> <span class="n">P</span>

<span class="c1">## Set up the cost function specified for this Poisson equation:</span>

<span class="c1"># The right side of the ODE</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">cost_function_deep</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>

    <span class="c1"># Evaluate the trial function with the current parameters P</span>
    <span class="n">g_t</span> <span class="o">=</span> <span class="n">g_trial_deep</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">P</span><span class="p">)</span>

    <span class="c1"># Find the derivative w.r.t x of the trial function</span>
    <span class="n">d2_g_t</span> <span class="o">=</span> <span class="n">elementwise_grad</span><span class="p">(</span><span class="n">elementwise_grad</span><span class="p">(</span><span class="n">g_trial_deep</span><span class="p">,</span><span class="mi">0</span><span class="p">))(</span><span class="n">x</span><span class="p">,</span><span class="n">P</span><span class="p">)</span>

    <span class="n">right_side</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="n">err_sqr</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">d2_g_t</span> <span class="o">-</span> <span class="n">right_side</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">cost_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">err_sqr</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cost_sum</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">err_sqr</span><span class="p">)</span>

<span class="c1"># The trial solution:</span>
<span class="k">def</span> <span class="nf">g_trial_deep</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">P</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">deep_neural_network</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># The analytic solution;</span>
<span class="k">def</span> <span class="nf">g_analytic</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">npr</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">4155</span><span class="p">)</span>

    <span class="c1">## Decide the vales of arguments to the function to solve</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">)</span>

    <span class="c1">## Set up the initial parameters</span>
    <span class="n">num_hidden_neurons</span> <span class="o">=</span> <span class="p">[</span><span class="mi">200</span><span class="p">,</span><span class="mi">100</span><span class="p">]</span>
    <span class="n">num_iter</span> <span class="o">=</span> <span class="mi">1000</span>
    <span class="n">lmb</span> <span class="o">=</span> <span class="mf">1e-3</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">solve_ode_deep_neural_network</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">num_hidden_neurons</span><span class="p">,</span> <span class="n">num_iter</span><span class="p">,</span> <span class="n">lmb</span><span class="p">)</span>

    <span class="n">g_dnn_ag</span> <span class="o">=</span> <span class="n">g_trial_deep</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">P</span><span class="p">)</span>
    <span class="n">g_analytical</span> <span class="o">=</span> <span class="n">g_analytic</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># Find the maximum absolute difference between the solutons:</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Performance of neural network solving an ODE compared to the analytical solution&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">g_analytical</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">g_dnn_ag</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;analytical&#39;</span><span class="p">,</span><span class="s1">&#39;nn&#39;</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;g(x)&#39;</span><span class="p">)</span>

    <span class="c1">## Perform the computation using the numerical scheme</span>

    <span class="n">dx</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Set up the matrix A</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="n">Nx</span><span class="o">-</span><span class="mi">2</span><span class="p">))</span>

    <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">Nx</span><span class="o">-</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="n">A</span><span class="p">[</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="n">Nx</span> <span class="o">-</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">A</span><span class="p">[</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="n">Nx</span> <span class="o">-</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="c1"># Set up the vector f</span>
    <span class="n">f_vec</span> <span class="o">=</span> <span class="n">dx</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Solve the equation</span>
    <span class="n">g_res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">f_vec</span><span class="p">)</span>

    <span class="n">g_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">Nx</span><span class="p">)</span>
    <span class="n">g_vec</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">g_res</span>

    <span class="c1"># Print the differences between each method</span>
    <span class="n">max_diff1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">g_dnn_ag</span> <span class="o">-</span> <span class="n">g_analytical</span><span class="p">))</span>
    <span class="n">max_diff2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">g_vec</span> <span class="o">-</span> <span class="n">g_analytical</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The max absolute difference between the analytical solution and DNN Autograd: </span><span class="si">%g</span><span class="s2">&quot;</span><span class="o">%</span><span class="k">max_diff1</span>)
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The max absolute difference between the analytical solution and numerical scheme: </span><span class="si">%g</span><span class="s2">&quot;</span><span class="o">%</span><span class="k">max_diff2</span>)

    <span class="c1"># Plot the results</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">g_vec</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">g_analytical</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">g_dnn_ag</span><span class="p">[</span><span class="mi">0</span><span class="p">,:])</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;numerical scheme&#39;</span><span class="p">,</span><span class="s1">&#39;analytical&#39;</span><span class="p">,</span><span class="s1">&#39;dnn&#39;</span><span class="p">])</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Initial cost: 457.256
</pre></div>
</div>
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>/Users/mhjensen/miniforge3/envs/myenv/lib/python3.9/site-packages/numpy/core/fromnumeric.py:3208: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify &#39;dtype=object&#39; when creating the ndarray.
  return asarray(a).size
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Final cost: 0.00310113
The max absolute difference between the analytical solution and DNN Autograd: 0.000464088
The max absolute difference between the analytical solution and numerical scheme: 0.00266858
</pre></div>
</div>
<img alt="_images/chapter11_91_3.png" src="_images/chapter11_91_3.png" />
<img alt="_images/chapter11_91_4.png" src="_images/chapter11_91_4.png" />
</div>
</div>
</div>
</div>
<div class="section" id="partial-differential-equations">
<h2><span class="section-number">15.8. </span>Partial Differential Equations<a class="headerlink" href="#partial-differential-equations" title="Permalink to this headline">¶</a></h2>
<p>A partial differential equation (PDE) has a solution here the function
is defined by multiple variables.  The equation may involve all kinds
of combinations of which variables the function is differentiated with
respect to.</p>
<p>In general, a partial differential equation for a function <span class="math notranslate nohighlight">\(g(x_1,\dots,x_N)\)</span> with <span class="math notranslate nohighlight">\(N\)</span> variables may be expressed as</p>
<!-- Equation labels as ordinary links -->
<div id="PDE"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation} \label{PDE} \tag{17}
  f\left(x_1, \, \dots \, , x_N, \frac{\partial g(x_1,\dots,x_N) }{\partial x_1}, \dots , \frac{\partial g(x_1,\dots,x_N) }{\partial x_N}, \frac{\partial g(x_1,\dots,x_N) }{\partial x_1\partial x_2}, \, \dots \, , \frac{\partial^n g(x_1,\dots,x_N) }{\partial x_N^n} \right) = 0
\end{equation}
\]</div>
<p>where <span class="math notranslate nohighlight">\(f\)</span> is an expression involving all kinds of possible mixed derivatives of <span class="math notranslate nohighlight">\(g(x_1,\dots,x_N)\)</span> up to an order <span class="math notranslate nohighlight">\(n\)</span>. In order for the solution to be unique, some additional conditions must also be given.</p>
<div class="section" id="type-of-problem">
<h3><span class="section-number">15.8.1. </span>Type of problem<a class="headerlink" href="#type-of-problem" title="Permalink to this headline">¶</a></h3>
<p>The problem our network must solve for, is similar to the ODE case.
We must have a trial solution <span class="math notranslate nohighlight">\(g_t\)</span> at hand.</p>
<p>For instance, the trial solution could be expressed as</p>
<div class="math notranslate nohighlight">
\[
\begin{align*}
  g_t(x_1,\dots,x_N) = h_1(x_1,\dots,x_N) + h_2(x_1,\dots,x_N,N(x_1,\dots,x_N,P))
\end{align*}
\]</div>
<p>where <span class="math notranslate nohighlight">\(h_1(x_1,\dots,x_N)\)</span> is a function that ensures <span class="math notranslate nohighlight">\(g_t(x_1,\dots,x_N)\)</span> satisfies some given conditions.
The neural network <span class="math notranslate nohighlight">\(N(x_1,\dots,x_N,P)\)</span> has weights and biases described by <span class="math notranslate nohighlight">\(P\)</span> and <span class="math notranslate nohighlight">\(h_2(x_1,\dots,x_N,N(x_1,\dots,x_N,P))\)</span> is an expression using the output from the neural network in some way.</p>
<p>The role of the function <span class="math notranslate nohighlight">\(h_2(x_1,\dots,x_N,N(x_1,\dots,x_N,P))\)</span>, is to ensure that the output of <span class="math notranslate nohighlight">\(N(x_1,\dots,x_N,P)\)</span> is zero when <span class="math notranslate nohighlight">\(g_t(x_1,\dots,x_N)\)</span> is evaluated at the values of <span class="math notranslate nohighlight">\(x_1,\dots,x_N\)</span> where the given conditions must be satisfied. The function <span class="math notranslate nohighlight">\(h_1(x_1,\dots,x_N)\)</span> should alone make <span class="math notranslate nohighlight">\(g_t(x_1,\dots,x_N)\)</span> satisfy the conditions.</p>
</div>
<div class="section" id="network-requirements">
<h3><span class="section-number">15.8.2. </span>Network requirements<a class="headerlink" href="#network-requirements" title="Permalink to this headline">¶</a></h3>
<p>The network tries then the minimize the cost function following the
same ideas as described for the ODE case, but now with more than one
variables to consider.  The concept still remains the same; find a set
of parameters <span class="math notranslate nohighlight">\(P\)</span> such that the expression <span class="math notranslate nohighlight">\(f\)</span> in (<a class="reference external" href="#PDE">17</a>) is as
close to zero as possible.</p>
<p>As for the ODE case, the cost function is the mean squared error that
the network must try to minimize. The cost function for the network to
minimize is</p>
<div class="math notranslate nohighlight">
\[
C\left(x_1, \dots, x_N, P\right) = \left(  f\left(x_1, \, \dots \, , x_N, \frac{\partial g(x_1,\dots,x_N) }{\partial x_1}, \dots , \frac{\partial g(x_1,\dots,x_N) }{\partial x_N}, \frac{\partial g(x_1,\dots,x_N) }{\partial x_1\partial x_2}, \, \dots \, , \frac{\partial^n g(x_1,\dots,x_N) }{\partial x_N^n} \right) \right)^2
\]</div>
<p>If we let <span class="math notranslate nohighlight">\(\boldsymbol{x} = \big( x_1, \dots, x_N \big)\)</span> be an array containing the values for <span class="math notranslate nohighlight">\(x_1, \dots, x_N\)</span> respectively, the cost function can be reformulated into the following:</p>
<div class="math notranslate nohighlight">
\[
C\left(\boldsymbol{x}, P\right) = f\left( \left( \boldsymbol{x}, \frac{\partial g(\boldsymbol{x}) }{\partial x_1}, \dots , \frac{\partial g(\boldsymbol{x}) }{\partial x_N}, \frac{\partial g(\boldsymbol{x}) }{\partial x_1\partial x_2}, \, \dots \, , \frac{\partial^n g(\boldsymbol{x}) }{\partial x_N^n} \right) \right)^2
\]</div>
<p>If we also have <span class="math notranslate nohighlight">\(M\)</span> different sets of values for <span class="math notranslate nohighlight">\(x_1, \dots, x_N\)</span>, that is <span class="math notranslate nohighlight">\(\boldsymbol{x}_i = \big(x_1^{(i)}, \dots, x_N^{(i)}\big)\)</span> for <span class="math notranslate nohighlight">\(i = 1,\dots,M\)</span> being the rows in matrix <span class="math notranslate nohighlight">\(X\)</span>, the cost function can be generalized into</p>
<div class="math notranslate nohighlight">
\[
C\left(X, P \right) = \sum_{i=1}^M f\left( \left( \boldsymbol{x}_i, \frac{\partial g(\boldsymbol{x}_i) }{\partial x_1}, \dots , \frac{\partial g(\boldsymbol{x}_i) }{\partial x_N}, \frac{\partial g(\boldsymbol{x}_i) }{\partial x_1\partial x_2}, \, \dots \, , \frac{\partial^n g(\boldsymbol{x}_i) }{\partial x_N^n} \right) \right)^2.
\]</div>
</div>
</div>
<div class="section" id="example-the-diffusion-equation">
<h2><span class="section-number">15.9. </span>Example: The diffusion equation<a class="headerlink" href="#example-the-diffusion-equation" title="Permalink to this headline">¶</a></h2>
<p>In one spatial dimension, the equation reads</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial g(x,t)}{\partial t} = \frac{\partial^2 g(x,t)}{\partial x^2}
\]</div>
<p>where a possible choice of conditions are</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
g(0,t) &amp;= 0 ,\qquad t \geq 0 \\
g(1,t) &amp;= 0, \qquad t \geq 0 \\
g(x,0) &amp;= u(x),\qquad x\in [0,1]
\end{align*}
\end{split}\]</div>
<p>with <span class="math notranslate nohighlight">\(u(x)\)</span> being some given function.</p>
<p>For this case, we want to find <span class="math notranslate nohighlight">\(g(x,t)\)</span> such that</p>
<!-- Equation labels as ordinary links -->
<div id="diffonedim"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation}
  \frac{\partial g(x,t)}{\partial t} = \frac{\partial^2 g(x,t)}{\partial x^2}
\end{equation} \label{diffonedim} \tag{18}
\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
g(0,t) &amp;= 0 ,\qquad t \geq 0 \\
g(1,t) &amp;= 0, \qquad t \geq 0 \\
g(x,0) &amp;= u(x),\qquad x\in [0,1]
\end{align*}
\end{split}\]</div>
<p>with <span class="math notranslate nohighlight">\(u(x) = \sin(\pi x)\)</span>.</p>
<p>First, let us set up the deep neural network.
The deep neural network will follow the same structure as discussed in the examples solving the ODEs.
First, we will look into how Autograd could be used in a network tailored to solve for bivariate functions.</p>
<p>The only change to do here, is to extend our network such that
functions of multiple parameters are correctly handled.  In this case
we have two variables in our function to solve for, that is time <span class="math notranslate nohighlight">\(t\)</span>
and position <span class="math notranslate nohighlight">\(x\)</span>.  The variables will be represented by a
one-dimensional array in the program.  The program will evaluate the
network at each possible pair <span class="math notranslate nohighlight">\((x,t)\)</span>, given an array for the desired
<span class="math notranslate nohighlight">\(x\)</span>-values and <span class="math notranslate nohighlight">\(t\)</span>-values to approximate the solution at.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">sigmoid</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">z</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">deep_neural_network</span><span class="p">(</span><span class="n">deep_params</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="c1"># x is now a point and a 1D numpy array; make it a column vector</span>
    <span class="n">num_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">num_coordinates</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">num_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># N_hidden is the number of hidden layers</span>
    <span class="n">N_hidden</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">deep_params</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># -1 since params consist of parameters to all the hidden layers AND the output layer</span>

    <span class="c1"># Assume that the input layer does nothing to the input x</span>
    <span class="n">x_input</span> <span class="o">=</span> <span class="n">x</span>
    <span class="n">x_prev</span> <span class="o">=</span> <span class="n">x_input</span>

    <span class="c1">## Hidden layers:</span>

    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_hidden</span><span class="p">):</span>
        <span class="c1"># From the list of parameters P; find the correct weigths and bias for this layer</span>
        <span class="n">w_hidden</span> <span class="o">=</span> <span class="n">deep_params</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>

        <span class="c1"># Add a row of ones to include bias</span>
        <span class="n">x_prev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">num_points</span><span class="p">)),</span> <span class="n">x_prev</span> <span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">z_hidden</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">w_hidden</span><span class="p">,</span> <span class="n">x_prev</span><span class="p">)</span>
        <span class="n">x_hidden</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">z_hidden</span><span class="p">)</span>

        <span class="c1"># Update x_prev such that next layer can use the output from this layer</span>
        <span class="n">x_prev</span> <span class="o">=</span> <span class="n">x_hidden</span>

    <span class="c1">## Output layer:</span>

    <span class="c1"># Get the weights and bias for this layer</span>
    <span class="n">w_output</span> <span class="o">=</span> <span class="n">deep_params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Include bias:</span>
    <span class="n">x_prev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">num_points</span><span class="p">)),</span> <span class="n">x_prev</span><span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">z_output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">w_output</span><span class="p">,</span> <span class="n">x_prev</span><span class="p">)</span>
    <span class="n">x_output</span> <span class="o">=</span> <span class="n">z_output</span>

    <span class="k">return</span> <span class="n">x_output</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<p>The cost function must then iterate through the given arrays
containing values for <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(t\)</span>, defines a point <span class="math notranslate nohighlight">\((x,t)\)</span> the deep
neural network and the trial solution is evaluated at, and then finds
the Jacobian of the trial solution.</p>
<p>A possible trial solution for this PDE is</p>
<div class="math notranslate nohighlight">
\[
g_t(x,t) = h_1(x,t) + x(1-x)tN(x,t,P)
\]</div>
<p>with <span class="math notranslate nohighlight">\(A(x,t)\)</span> being a function ensuring that <span class="math notranslate nohighlight">\(g_t(x,t)\)</span> satisfies our given conditions, and <span class="math notranslate nohighlight">\(N(x,t,P)\)</span> being the output from the deep neural network using weights and biases for each layer from <span class="math notranslate nohighlight">\(P\)</span>.</p>
<p>To fulfill the conditions, <span class="math notranslate nohighlight">\(A(x,t)\)</span> could be:</p>
<div class="math notranslate nohighlight">
\[
h_1(x,t) = (1-t)\Big(u(x) - \big((1-x)u(0) + x u(1)\big)\Big) = (1-t)u(x) = (1-t)\sin(\pi x)
\]</div>
<p>since <span class="math notranslate nohighlight">\((0) = u(1) = 0\)</span> and <span class="math notranslate nohighlight">\(u(x) = \sin(\pi x)\)</span>.</p>
<p>The Jacobian is used because the program must find the derivative of
the trial solution with respect to <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(t\)</span>.</p>
<p>This gives the necessity of computing the Jacobian matrix, as we want
to evaluate the gradient with respect to <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(t\)</span> (note that the
Jacobian of a scalar-valued multivariate function is simply its
gradient).</p>
<p>In Autograd, the differentiation is by default done with respect to
the first input argument of your Python function. Since the points is
an array representing <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(t\)</span>, the Jacobian is calculated using
the values of <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(t\)</span>.</p>
<p>To find the second derivative with respect to <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(t\)</span>, the
Jacobian can be found for the second time. The result is a Hessian
matrix, which is the matrix containing all the possible second order
mixed derivatives of <span class="math notranslate nohighlight">\(g(x,t)\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set up the trial function:</span>
<span class="k">def</span> <span class="nf">u</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">g_trial</span><span class="p">(</span><span class="n">point</span><span class="p">,</span><span class="n">P</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span><span class="n">t</span> <span class="o">=</span> <span class="n">point</span>
    <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">t</span><span class="o">*</span><span class="n">deep_neural_network</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">point</span><span class="p">)</span>

<span class="c1"># The right side of the ODE:</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">point</span><span class="p">):</span>
    <span class="k">return</span> <span class="mf">0.</span>

<span class="c1"># The cost function:</span>
<span class="k">def</span> <span class="nf">cost_function</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">cost_sum</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">g_t_jacobian_func</span> <span class="o">=</span> <span class="n">jacobian</span><span class="p">(</span><span class="n">g_trial</span><span class="p">)</span>
    <span class="n">g_t_hessian_func</span> <span class="o">=</span> <span class="n">hessian</span><span class="p">(</span><span class="n">g_trial</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">x_</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">t_</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
            <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_</span><span class="p">,</span><span class="n">t_</span><span class="p">])</span>

            <span class="n">g_t</span> <span class="o">=</span> <span class="n">g_trial</span><span class="p">(</span><span class="n">point</span><span class="p">,</span><span class="n">P</span><span class="p">)</span>
            <span class="n">g_t_jacobian</span> <span class="o">=</span> <span class="n">g_t_jacobian_func</span><span class="p">(</span><span class="n">point</span><span class="p">,</span><span class="n">P</span><span class="p">)</span>
            <span class="n">g_t_hessian</span> <span class="o">=</span> <span class="n">g_t_hessian_func</span><span class="p">(</span><span class="n">point</span><span class="p">,</span><span class="n">P</span><span class="p">)</span>

            <span class="n">g_t_dt</span> <span class="o">=</span> <span class="n">g_t_jacobian</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">g_t_d2x</span> <span class="o">=</span> <span class="n">g_t_hessian</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">func</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>

            <span class="n">err_sqr</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="n">g_t_dt</span> <span class="o">-</span> <span class="n">g_t_d2x</span><span class="p">)</span> <span class="o">-</span> <span class="n">func</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">cost_sum</span> <span class="o">+=</span> <span class="n">err_sqr</span>

    <span class="k">return</span> <span class="n">cost_sum</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="setting-up-the-network-using-autograd-the-full-program">
<h3><span class="section-number">15.9.1. </span>Setting up the network using Autograd; The full program<a class="headerlink" href="#setting-up-the-network-using-autograd-the-full-program" title="Permalink to this headline">¶</a></h3>
<p>Having set up the network, along with the trial solution and cost function, we can now see how the deep neural network performs by comparing the results to the analytical solution.</p>
<p>The analytical solution of our problem is</p>
<div class="math notranslate nohighlight">
\[
g(x,t) = \exp(-\pi^2 t)\sin(\pi x)
\]</div>
<p>A possible way to implement a neural network solving the PDE, is given below.
Be aware, though, that it is fairly slow for the parameters used.
A better result is possible, but requires more iterations, and thus longer time to complete.</p>
<p>Indeed, the program below is not optimal in its implementation, but rather serves as an example on how to implement and use a neural network to solve a PDE.
Using TensorFlow results in a much better execution time. Try it!</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">autograd.numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">autograd</span> <span class="kn">import</span> <span class="n">jacobian</span><span class="p">,</span><span class="n">hessian</span><span class="p">,</span><span class="n">grad</span>
<span class="kn">import</span> <span class="nn">autograd.numpy.random</span> <span class="k">as</span> <span class="nn">npr</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">cm</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">axes3d</span>

<span class="c1">## Set up the network</span>

<span class="k">def</span> <span class="nf">sigmoid</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">z</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">deep_neural_network</span><span class="p">(</span><span class="n">deep_params</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="c1"># x is now a point and a 1D numpy array; make it a column vector</span>
    <span class="n">num_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">num_coordinates</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">num_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># N_hidden is the number of hidden layers</span>
    <span class="n">N_hidden</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">deep_params</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># -1 since params consist of parameters to all the hidden layers AND the output layer</span>

    <span class="c1"># Assume that the input layer does nothing to the input x</span>
    <span class="n">x_input</span> <span class="o">=</span> <span class="n">x</span>
    <span class="n">x_prev</span> <span class="o">=</span> <span class="n">x_input</span>

    <span class="c1">## Hidden layers:</span>

    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_hidden</span><span class="p">):</span>
        <span class="c1"># From the list of parameters P; find the correct weigths and bias for this layer</span>
        <span class="n">w_hidden</span> <span class="o">=</span> <span class="n">deep_params</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>

        <span class="c1"># Add a row of ones to include bias</span>
        <span class="n">x_prev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">num_points</span><span class="p">)),</span> <span class="n">x_prev</span> <span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">z_hidden</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">w_hidden</span><span class="p">,</span> <span class="n">x_prev</span><span class="p">)</span>
        <span class="n">x_hidden</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">z_hidden</span><span class="p">)</span>

        <span class="c1"># Update x_prev such that next layer can use the output from this layer</span>
        <span class="n">x_prev</span> <span class="o">=</span> <span class="n">x_hidden</span>

    <span class="c1">## Output layer:</span>

    <span class="c1"># Get the weights and bias for this layer</span>
    <span class="n">w_output</span> <span class="o">=</span> <span class="n">deep_params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Include bias:</span>
    <span class="n">x_prev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">num_points</span><span class="p">)),</span> <span class="n">x_prev</span><span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">z_output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">w_output</span><span class="p">,</span> <span class="n">x_prev</span><span class="p">)</span>
    <span class="n">x_output</span> <span class="o">=</span> <span class="n">z_output</span>

    <span class="k">return</span> <span class="n">x_output</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

<span class="c1">## Define the trial solution and cost function</span>
<span class="k">def</span> <span class="nf">u</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">g_trial</span><span class="p">(</span><span class="n">point</span><span class="p">,</span><span class="n">P</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span><span class="n">t</span> <span class="o">=</span> <span class="n">point</span>
    <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">t</span><span class="o">*</span><span class="n">deep_neural_network</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">point</span><span class="p">)</span>

<span class="c1"># The right side of the ODE:</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">point</span><span class="p">):</span>
    <span class="k">return</span> <span class="mf">0.</span>

<span class="c1"># The cost function:</span>
<span class="k">def</span> <span class="nf">cost_function</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">cost_sum</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">g_t_jacobian_func</span> <span class="o">=</span> <span class="n">jacobian</span><span class="p">(</span><span class="n">g_trial</span><span class="p">)</span>
    <span class="n">g_t_hessian_func</span> <span class="o">=</span> <span class="n">hessian</span><span class="p">(</span><span class="n">g_trial</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">x_</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">t_</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
            <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_</span><span class="p">,</span><span class="n">t_</span><span class="p">])</span>

            <span class="n">g_t</span> <span class="o">=</span> <span class="n">g_trial</span><span class="p">(</span><span class="n">point</span><span class="p">,</span><span class="n">P</span><span class="p">)</span>
            <span class="n">g_t_jacobian</span> <span class="o">=</span> <span class="n">g_t_jacobian_func</span><span class="p">(</span><span class="n">point</span><span class="p">,</span><span class="n">P</span><span class="p">)</span>
            <span class="n">g_t_hessian</span> <span class="o">=</span> <span class="n">g_t_hessian_func</span><span class="p">(</span><span class="n">point</span><span class="p">,</span><span class="n">P</span><span class="p">)</span>

            <span class="n">g_t_dt</span> <span class="o">=</span> <span class="n">g_t_jacobian</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">g_t_d2x</span> <span class="o">=</span> <span class="n">g_t_hessian</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">func</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>

            <span class="n">err_sqr</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="n">g_t_dt</span> <span class="o">-</span> <span class="n">g_t_d2x</span><span class="p">)</span> <span class="o">-</span> <span class="n">func</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">cost_sum</span> <span class="o">+=</span> <span class="n">err_sqr</span>

    <span class="k">return</span> <span class="n">cost_sum</span> <span class="o">/</span><span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">)</span>

<span class="c1">## For comparison, define the analytical solution</span>
<span class="k">def</span> <span class="nf">g_analytic</span><span class="p">(</span><span class="n">point</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span><span class="n">t</span> <span class="o">=</span> <span class="n">point</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">t</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>

<span class="c1">## Set up a function for training the network to solve for the equation</span>
<span class="k">def</span> <span class="nf">solve_pde_deep_neural_network</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="p">,</span> <span class="n">num_neurons</span><span class="p">,</span> <span class="n">num_iter</span><span class="p">,</span> <span class="n">lmb</span><span class="p">):</span>
    <span class="c1">## Set up initial weigths and biases</span>
    <span class="n">N_hidden</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">num_neurons</span><span class="p">)</span>

    <span class="c1">## Set up initial weigths and biases</span>

    <span class="c1"># Initialize the list of parameters:</span>
    <span class="n">P</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">N_hidden</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># + 1 to include the output layer</span>

    <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">npr</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">num_neurons</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span> <span class="c1"># 2 since we have two points, +1 to include bias</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">N_hidden</span><span class="p">):</span>
        <span class="n">P</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">npr</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">num_neurons</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="n">num_neurons</span><span class="p">[</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># +1 to include bias</span>

    <span class="c1"># For the output layer</span>
    <span class="n">P</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">npr</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_neurons</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span> <span class="c1"># +1 since bias is included</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Initial cost: &#39;</span><span class="p">,</span><span class="n">cost_function</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>

    <span class="n">cost_function_grad</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="n">cost_function</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Let the update be done num_iter times</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_iter</span><span class="p">):</span>
        <span class="n">cost_grad</span> <span class="o">=</span>  <span class="n">cost_function_grad</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">x</span> <span class="p">,</span> <span class="n">t</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_hidden</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">P</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">-</span> <span class="n">lmb</span> <span class="o">*</span> <span class="n">cost_grad</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Final cost: &#39;</span><span class="p">,</span><span class="n">cost_function</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">P</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1">### Use the neural network:</span>
    <span class="n">npr</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>

    <span class="c1">## Decide the vales of arguments to the function to solve</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">Nt</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">Nt</span><span class="p">)</span>

    <span class="c1">## Set up the parameters for the network</span>
    <span class="n">num_hidden_neurons</span> <span class="o">=</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">25</span><span class="p">]</span>
    <span class="n">num_iter</span> <span class="o">=</span> <span class="mi">250</span>
    <span class="n">lmb</span> <span class="o">=</span> <span class="mf">0.01</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">solve_pde_deep_neural_network</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="p">,</span> <span class="n">num_hidden_neurons</span><span class="p">,</span> <span class="n">num_iter</span><span class="p">,</span> <span class="n">lmb</span><span class="p">)</span>

    <span class="c1">## Store the results</span>
    <span class="n">g_dnn_ag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Nt</span><span class="p">))</span>
    <span class="n">G_analytical</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Nt</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">t_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
            <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_</span><span class="p">,</span> <span class="n">t_</span><span class="p">])</span>
            <span class="n">g_dnn_ag</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">g_trial</span><span class="p">(</span><span class="n">point</span><span class="p">,</span><span class="n">P</span><span class="p">)</span>

            <span class="n">G_analytical</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">g_analytic</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>

    <span class="c1"># Find the map difference between the analytical and the computed solution</span>
    <span class="n">diff_ag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">g_dnn_ag</span> <span class="o">-</span> <span class="n">G_analytical</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Max absolute difference between the analytical solution and the network: </span><span class="si">%g</span><span class="s1">&#39;</span><span class="o">%</span><span class="k">np</span>.max(diff_ag))

    <span class="c1">## Plot the solutions in two dimensions, that being in position and time</span>

    <span class="n">T</span><span class="p">,</span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>

    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Solution from the deep neural network w/ </span><span class="si">%d</span><span class="s1"> layer&#39;</span><span class="o">%</span><span class="k">len</span>(num_hidden_neurons))
    <span class="n">s</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">g_dnn_ag</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">antialiased</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">viridis</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time $t$&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Position $x$&#39;</span><span class="p">);</span>


    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Analytical solution&#39;</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">G_analytical</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">antialiased</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">viridis</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time $t$&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Position $x$&#39;</span><span class="p">);</span>

    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Difference&#39;</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">diff_ag</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">antialiased</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">viridis</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time $t$&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Position $x$&#39;</span><span class="p">);</span>

    <span class="c1">## Take some slices of the 3D plots just to see the solutions at particular times</span>
    <span class="n">indx1</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">indx2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">Nt</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">indx3</span> <span class="o">=</span> <span class="n">Nt</span><span class="o">-</span><span class="mi">1</span>

    <span class="n">t1</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">indx1</span><span class="p">]</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">indx2</span><span class="p">]</span>
    <span class="n">t3</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">indx3</span><span class="p">]</span>

    <span class="c1"># Slice the results from the DNN</span>
    <span class="n">res1</span> <span class="o">=</span> <span class="n">g_dnn_ag</span><span class="p">[:,</span><span class="n">indx1</span><span class="p">]</span>
    <span class="n">res2</span> <span class="o">=</span> <span class="n">g_dnn_ag</span><span class="p">[:,</span><span class="n">indx2</span><span class="p">]</span>
    <span class="n">res3</span> <span class="o">=</span> <span class="n">g_dnn_ag</span><span class="p">[:,</span><span class="n">indx3</span><span class="p">]</span>

    <span class="c1"># Slice the analytical results</span>
    <span class="n">res_analytical1</span> <span class="o">=</span> <span class="n">G_analytical</span><span class="p">[:,</span><span class="n">indx1</span><span class="p">]</span>
    <span class="n">res_analytical2</span> <span class="o">=</span> <span class="n">G_analytical</span><span class="p">[:,</span><span class="n">indx2</span><span class="p">]</span>
    <span class="n">res_analytical3</span> <span class="o">=</span> <span class="n">G_analytical</span><span class="p">[:,</span><span class="n">indx3</span><span class="p">]</span>

    <span class="c1"># Plot the slices</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Computed solutions at time = </span><span class="si">%g</span><span class="s2">&quot;</span><span class="o">%</span><span class="k">t1</span>)
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">res1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">res_analytical1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;dnn&#39;</span><span class="p">,</span><span class="s1">&#39;analytical&#39;</span><span class="p">])</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Computed solutions at time = </span><span class="si">%g</span><span class="s2">&quot;</span><span class="o">%</span><span class="k">t2</span>)
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">res2</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">res_analytical2</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;dnn&#39;</span><span class="p">,</span><span class="s1">&#39;analytical&#39;</span><span class="p">])</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Computed solutions at time = </span><span class="si">%g</span><span class="s2">&quot;</span><span class="o">%</span><span class="k">t3</span>)
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">res3</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">res_analytical3</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;dnn&#39;</span><span class="p">,</span><span class="s1">&#39;analytical&#39;</span><span class="p">])</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stderr highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>/Users/mhjensen/miniforge3/envs/myenv/lib/python3.9/site-packages/numpy/core/fromnumeric.py:3208: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify &#39;dtype=object&#39; when creating the ndarray.
  return asarray(a).size
</pre></div>
</div>
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Initial cost:  41.05505310046363
</pre></div>
</div>
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">KeyboardInterrupt</span><span class="g g-Whitespace">                         </span>Traceback (most recent call last)
<span class="nn">Input In [9],</span> in <span class="ni">&lt;cell line: 129&gt;</span><span class="nt">()</span>
<span class="g g-Whitespace">    </span><span class="mi">140</span> <span class="n">num_iter</span> <span class="o">=</span> <span class="mi">250</span>
<span class="g g-Whitespace">    </span><span class="mi">141</span> <span class="n">lmb</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="ne">--&gt; </span><span class="mi">143</span> <span class="n">P</span> <span class="o">=</span> <span class="n">solve_pde_deep_neural_network</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="p">,</span> <span class="n">num_hidden_neurons</span><span class="p">,</span> <span class="n">num_iter</span><span class="p">,</span> <span class="n">lmb</span><span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">145</span> <span class="c1">## Store the results</span>
<span class="g g-Whitespace">    </span><span class="mi">146</span> <span class="n">g_dnn_ag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Nt</span><span class="p">))</span>

<span class="nn">Input In [9],</span> in <span class="ni">solve_pde_deep_neural_network</span><span class="nt">(x, t, num_neurons, num_iter, lmb)</span>
<span class="g g-Whitespace">    </span><span class="mi">118</span> <span class="c1"># Let the update be done num_iter times</span>
<span class="g g-Whitespace">    </span><span class="mi">119</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_iter</span><span class="p">):</span>
<span class="ne">--&gt; </span><span class="mi">120</span>     <span class="n">cost_grad</span> <span class="o">=</span>  <span class="n">cost_function_grad</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">x</span> <span class="p">,</span> <span class="n">t</span><span class="p">)</span>
<span class="g g-Whitespace">    </span><span class="mi">122</span>     <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_hidden</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
<span class="g g-Whitespace">    </span><span class="mi">123</span>         <span class="n">P</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">-</span> <span class="n">lmb</span> <span class="o">*</span> <span class="n">cost_grad</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>

<span class="nn">File ~/miniforge3/envs/myenv/lib/python3.9/site-packages/autograd/wrap_util.py:20,</span> in <span class="ni">unary_to_nary.&lt;locals&gt;.nary_operator.&lt;locals&gt;.nary_f</span><span class="nt">(*args, **kwargs)</span>
<span class="g g-Whitespace">     </span><span class="mi">18</span> <span class="k">else</span><span class="p">:</span>
<span class="g g-Whitespace">     </span><span class="mi">19</span>     <span class="n">x</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">argnum</span><span class="p">)</span>
<span class="ne">---&gt; </span><span class="mi">20</span> <span class="k">return</span> <span class="n">unary_operator</span><span class="p">(</span><span class="n">unary_f</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">nary_op_args</span><span class="p">,</span> <span class="o">**</span><span class="n">nary_op_kwargs</span><span class="p">)</span>

<span class="nn">File ~/miniforge3/envs/myenv/lib/python3.9/site-packages/autograd/differential_operators.py:25,</span> in <span class="ni">grad</span><span class="nt">(fun, x)</span>
<span class="g g-Whitespace">     </span><span class="mi">18</span> <span class="nd">@unary_to_nary</span>
<span class="g g-Whitespace">     </span><span class="mi">19</span> <span class="k">def</span> <span class="nf">grad</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="g g-Whitespace">     </span><span class="mi">20</span>     <span class="sd">&quot;&quot;&quot;</span>
<span class="g g-Whitespace">     </span><span class="mi">21</span><span class="sd">     Returns a function which computes the gradient of `fun` with respect to</span>
<span class="g g-Whitespace">     </span><span class="mi">22</span><span class="sd">     positional argument number `argnum`. The returned function takes the same</span>
<span class="g g-Whitespace">     </span><span class="mi">23</span><span class="sd">     arguments as `fun`, but returns the gradient instead. The function `fun`</span>
<span class="g g-Whitespace">     </span><span class="mi">24</span><span class="sd">     should be scalar-valued. The gradient has the same type as the argument.&quot;&quot;&quot;</span>
<span class="ne">---&gt; </span><span class="mi">25</span>     <span class="n">vjp</span><span class="p">,</span> <span class="n">ans</span> <span class="o">=</span> <span class="n">_make_vjp</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="g g-Whitespace">     </span><span class="mi">26</span>     <span class="k">if</span> <span class="ow">not</span> <span class="n">vspace</span><span class="p">(</span><span class="n">ans</span><span class="p">)</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
<span class="g g-Whitespace">     </span><span class="mi">27</span>         <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Grad only applies to real scalar-output functions. &quot;</span>
<span class="g g-Whitespace">     </span><span class="mi">28</span>                         <span class="s2">&quot;Try jacobian, elementwise_grad or holomorphic_grad.&quot;</span><span class="p">)</span>

<span class="nn">File ~/miniforge3/envs/myenv/lib/python3.9/site-packages/autograd/core.py:10,</span> in <span class="ni">make_vjp</span><span class="nt">(fun, x)</span>
<span class="g g-Whitespace">      </span><span class="mi">8</span> <span class="k">def</span> <span class="nf">make_vjp</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="g g-Whitespace">      </span><span class="mi">9</span>     <span class="n">start_node</span> <span class="o">=</span> <span class="n">VJPNode</span><span class="o">.</span><span class="n">new_root</span><span class="p">()</span>
<span class="ne">---&gt; </span><span class="mi">10</span>     <span class="n">end_value</span><span class="p">,</span> <span class="n">end_node</span> <span class="o">=</span>  <span class="n">trace</span><span class="p">(</span><span class="n">start_node</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="g g-Whitespace">     </span><span class="mi">11</span>     <span class="k">if</span> <span class="n">end_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
<span class="g g-Whitespace">     </span><span class="mi">12</span>         <span class="k">def</span> <span class="nf">vjp</span><span class="p">(</span><span class="n">g</span><span class="p">):</span> <span class="k">return</span> <span class="n">vspace</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">zeros</span><span class="p">()</span>

<span class="nn">File ~/miniforge3/envs/myenv/lib/python3.9/site-packages/autograd/tracer.py:10,</span> in <span class="ni">trace</span><span class="nt">(start_node, fun, x)</span>
<span class="g g-Whitespace">      </span><span class="mi">8</span> <span class="k">with</span> <span class="n">trace_stack</span><span class="o">.</span><span class="n">new_trace</span><span class="p">()</span> <span class="k">as</span> <span class="n">t</span><span class="p">:</span>
<span class="g g-Whitespace">      </span><span class="mi">9</span>     <span class="n">start_box</span> <span class="o">=</span> <span class="n">new_box</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">start_node</span><span class="p">)</span>
<span class="ne">---&gt; </span><span class="mi">10</span>     <span class="n">end_box</span> <span class="o">=</span> <span class="n">fun</span><span class="p">(</span><span class="n">start_box</span><span class="p">)</span>
<span class="g g-Whitespace">     </span><span class="mi">11</span>     <span class="k">if</span> <span class="n">isbox</span><span class="p">(</span><span class="n">end_box</span><span class="p">)</span> <span class="ow">and</span> <span class="n">end_box</span><span class="o">.</span><span class="n">_trace</span> <span class="o">==</span> <span class="n">start_box</span><span class="o">.</span><span class="n">_trace</span><span class="p">:</span>
<span class="g g-Whitespace">     </span><span class="mi">12</span>         <span class="k">return</span> <span class="n">end_box</span><span class="o">.</span><span class="n">_value</span><span class="p">,</span> <span class="n">end_box</span><span class="o">.</span><span class="n">_node</span>

<span class="nn">File ~/miniforge3/envs/myenv/lib/python3.9/site-packages/autograd/wrap_util.py:15,</span> in <span class="ni">unary_to_nary.&lt;locals&gt;.nary_operator.&lt;locals&gt;.nary_f.&lt;locals&gt;.unary_f</span><span class="nt">(x)</span>
<span class="g g-Whitespace">     </span><span class="mi">13</span> <span class="k">else</span><span class="p">:</span>
<span class="g g-Whitespace">     </span><span class="mi">14</span>     <span class="n">subargs</span> <span class="o">=</span> <span class="n">subvals</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">argnum</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
<span class="ne">---&gt; </span><span class="mi">15</span> <span class="k">return</span> <span class="n">fun</span><span class="p">(</span><span class="o">*</span><span class="n">subargs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="nn">Input In [9],</span> in <span class="ni">cost_function</span><span class="nt">(P, x, t)</span>
<span class="g g-Whitespace">     </span><span class="mi">78</span> <span class="n">g_t</span> <span class="o">=</span> <span class="n">g_trial</span><span class="p">(</span><span class="n">point</span><span class="p">,</span><span class="n">P</span><span class="p">)</span>
<span class="g g-Whitespace">     </span><span class="mi">79</span> <span class="n">g_t_jacobian</span> <span class="o">=</span> <span class="n">g_t_jacobian_func</span><span class="p">(</span><span class="n">point</span><span class="p">,</span><span class="n">P</span><span class="p">)</span>
<span class="ne">---&gt; </span><span class="mi">80</span> <span class="n">g_t_hessian</span> <span class="o">=</span> <span class="n">g_t_hessian_func</span><span class="p">(</span><span class="n">point</span><span class="p">,</span><span class="n">P</span><span class="p">)</span>
<span class="g g-Whitespace">     </span><span class="mi">82</span> <span class="n">g_t_dt</span> <span class="o">=</span> <span class="n">g_t_jacobian</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="g g-Whitespace">     </span><span class="mi">83</span> <span class="n">g_t_d2x</span> <span class="o">=</span> <span class="n">g_t_hessian</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

<span class="nn">File ~/miniforge3/envs/myenv/lib/python3.9/site-packages/autograd/wrap_util.py:20,</span> in <span class="ni">unary_to_nary.&lt;locals&gt;.nary_operator.&lt;locals&gt;.nary_f</span><span class="nt">(*args, **kwargs)</span>
<span class="g g-Whitespace">     </span><span class="mi">18</span> <span class="k">else</span><span class="p">:</span>
<span class="g g-Whitespace">     </span><span class="mi">19</span>     <span class="n">x</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">argnum</span><span class="p">)</span>
<span class="ne">---&gt; </span><span class="mi">20</span> <span class="k">return</span> <span class="n">unary_operator</span><span class="p">(</span><span class="n">unary_f</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">nary_op_args</span><span class="p">,</span> <span class="o">**</span><span class="n">nary_op_kwargs</span><span class="p">)</span>

<span class="nn">File ~/miniforge3/envs/myenv/lib/python3.9/site-packages/autograd/differential_operators.py:78,</span> in <span class="ni">hessian</span><span class="nt">(fun, x)</span>
<span class="g g-Whitespace">     </span><span class="mi">75</span> <span class="nd">@unary_to_nary</span>
<span class="g g-Whitespace">     </span><span class="mi">76</span> <span class="k">def</span> <span class="nf">hessian</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="g g-Whitespace">     </span><span class="mi">77</span>     <span class="s2">&quot;Returns a function that computes the exact Hessian.&quot;</span>
<span class="ne">---&gt; </span><span class="mi">78</span>     <span class="k">return</span> <span class="n">jacobian</span><span class="p">(</span><span class="n">jacobian</span><span class="p">(</span><span class="n">fun</span><span class="p">))(</span><span class="n">x</span><span class="p">)</span>

<span class="nn">File ~/miniforge3/envs/myenv/lib/python3.9/site-packages/autograd/wrap_util.py:20,</span> in <span class="ni">unary_to_nary.&lt;locals&gt;.nary_operator.&lt;locals&gt;.nary_f</span><span class="nt">(*args, **kwargs)</span>
<span class="g g-Whitespace">     </span><span class="mi">18</span> <span class="k">else</span><span class="p">:</span>
<span class="g g-Whitespace">     </span><span class="mi">19</span>     <span class="n">x</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">argnum</span><span class="p">)</span>
<span class="ne">---&gt; </span><span class="mi">20</span> <span class="k">return</span> <span class="n">unary_operator</span><span class="p">(</span><span class="n">unary_f</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">nary_op_args</span><span class="p">,</span> <span class="o">**</span><span class="n">nary_op_kwargs</span><span class="p">)</span>

<span class="nn">File ~/miniforge3/envs/myenv/lib/python3.9/site-packages/autograd/differential_operators.py:61,</span> in <span class="ni">jacobian</span><span class="nt">(fun, x)</span>
<span class="g g-Whitespace">     </span><span class="mi">59</span> <span class="n">jacobian_shape</span> <span class="o">=</span> <span class="n">ans_vspace</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="n">vspace</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="g g-Whitespace">     </span><span class="mi">60</span> <span class="n">grads</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">vjp</span><span class="p">,</span> <span class="n">ans_vspace</span><span class="o">.</span><span class="n">standard_basis</span><span class="p">())</span>
<span class="ne">---&gt; </span><span class="mi">61</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">grads</span><span class="p">),</span> <span class="n">jacobian_shape</span><span class="p">)</span>

<span class="nn">File ~/miniforge3/envs/myenv/lib/python3.9/site-packages/autograd/numpy/numpy_wrapper.py:88,</span> in <span class="ni">stack</span><span class="nt">(arrays, axis)</span>
<span class="g g-Whitespace">     </span><span class="mi">83</span> <span class="k">def</span> <span class="nf">stack</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="g g-Whitespace">     </span><span class="mi">84</span>     <span class="c1"># this code is basically copied from numpy/core/shape_base.py&#39;s stack</span>
<span class="g g-Whitespace">     </span><span class="mi">85</span>     <span class="c1"># we need it here because we want to re-implement stack in terms of the</span>
<span class="g g-Whitespace">     </span><span class="mi">86</span>     <span class="c1"># primitives defined in this file</span>
<span class="ne">---&gt; </span><span class="mi">88</span>     <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">]</span>
<span class="g g-Whitespace">     </span><span class="mi">89</span>     <span class="k">if</span> <span class="ow">not</span> <span class="n">arrays</span><span class="p">:</span>
<span class="g g-Whitespace">     </span><span class="mi">90</span>         <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;need at least one array to stack&#39;</span><span class="p">)</span>

<span class="nn">File ~/miniforge3/envs/myenv/lib/python3.9/site-packages/autograd/numpy/numpy_wrapper.py:88,</span> in <span class="ni">&lt;listcomp&gt;</span><span class="nt">(.0)</span>
<span class="g g-Whitespace">     </span><span class="mi">83</span> <span class="k">def</span> <span class="nf">stack</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="g g-Whitespace">     </span><span class="mi">84</span>     <span class="c1"># this code is basically copied from numpy/core/shape_base.py&#39;s stack</span>
<span class="g g-Whitespace">     </span><span class="mi">85</span>     <span class="c1"># we need it here because we want to re-implement stack in terms of the</span>
<span class="g g-Whitespace">     </span><span class="mi">86</span>     <span class="c1"># primitives defined in this file</span>
<span class="ne">---&gt; </span><span class="mi">88</span>     <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">]</span>
<span class="g g-Whitespace">     </span><span class="mi">89</span>     <span class="k">if</span> <span class="ow">not</span> <span class="n">arrays</span><span class="p">:</span>
<span class="g g-Whitespace">     </span><span class="mi">90</span>         <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;need at least one array to stack&#39;</span><span class="p">)</span>

<span class="nn">File ~/miniforge3/envs/myenv/lib/python3.9/site-packages/autograd/core.py:14,</span> in <span class="ni">make_vjp.&lt;locals&gt;.vjp</span><span class="nt">(g)</span>
<span class="ne">---&gt; </span><span class="mi">14</span> <span class="k">def</span> <span class="nf">vjp</span><span class="p">(</span><span class="n">g</span><span class="p">):</span> <span class="k">return</span> <span class="n">backward_pass</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">end_node</span><span class="p">)</span>

<span class="nn">File ~/miniforge3/envs/myenv/lib/python3.9/site-packages/autograd/core.py:21,</span> in <span class="ni">backward_pass</span><span class="nt">(g, end_node)</span>
<span class="g g-Whitespace">     </span><span class="mi">19</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">toposort</span><span class="p">(</span><span class="n">end_node</span><span class="p">):</span>
<span class="g g-Whitespace">     </span><span class="mi">20</span>     <span class="n">outgrad</span> <span class="o">=</span> <span class="n">outgrads</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
<span class="ne">---&gt; </span><span class="mi">21</span>     <span class="n">ingrads</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">vjp</span><span class="p">(</span><span class="n">outgrad</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="g g-Whitespace">     </span><span class="mi">22</span>     <span class="k">for</span> <span class="n">parent</span><span class="p">,</span> <span class="n">ingrad</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">parents</span><span class="p">,</span> <span class="n">ingrads</span><span class="p">):</span>
<span class="g g-Whitespace">     </span><span class="mi">23</span>         <span class="n">outgrads</span><span class="p">[</span><span class="n">parent</span><span class="p">]</span> <span class="o">=</span> <span class="n">add_outgrads</span><span class="p">(</span><span class="n">outgrads</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">parent</span><span class="p">),</span> <span class="n">ingrad</span><span class="p">)</span>

<span class="nn">File ~/miniforge3/envs/myenv/lib/python3.9/site-packages/autograd/core.py:67,</span> in <span class="ni">defvjp.&lt;locals&gt;.vjp_argnums.&lt;locals&gt;.&lt;lambda&gt;</span><span class="nt">(g)</span>
<span class="g g-Whitespace">     </span><span class="mi">64</span>         <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
<span class="g g-Whitespace">     </span><span class="mi">65</span>             <span class="s2">&quot;VJP of </span><span class="si">{}</span><span class="s2"> wrt argnum 0 not defined&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fun</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
<span class="g g-Whitespace">     </span><span class="mi">66</span>     <span class="n">vjp</span> <span class="o">=</span> <span class="n">vjpfun</span><span class="p">(</span><span class="n">ans</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="ne">---&gt; </span><span class="mi">67</span>     <span class="k">return</span> <span class="k">lambda</span> <span class="n">g</span><span class="p">:</span> <span class="p">(</span><span class="n">vjp</span><span class="p">(</span><span class="n">g</span><span class="p">),)</span>
<span class="g g-Whitespace">     </span><span class="mi">68</span> <span class="k">elif</span> <span class="n">L</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
<span class="g g-Whitespace">     </span><span class="mi">69</span>     <span class="n">argnum_0</span><span class="p">,</span> <span class="n">argnum_1</span> <span class="o">=</span> <span class="n">argnums</span>

<span class="nn">File ~/miniforge3/envs/myenv/lib/python3.9/site-packages/autograd/numpy/numpy_vjps.py:82,</span> in <span class="ni">&lt;lambda&gt;</span><span class="nt">(g)</span>
<span class="g g-Whitespace">     </span><span class="mi">80</span> <span class="n">defvjp</span><span class="p">(</span><span class="n">anp</span><span class="o">.</span><span class="n">log10</span><span class="p">,</span>  <span class="k">lambda</span> <span class="n">ans</span><span class="p">,</span> <span class="n">x</span> <span class="p">:</span> <span class="k">lambda</span> <span class="n">g</span><span class="p">:</span> <span class="n">g</span> <span class="o">/</span> <span class="n">x</span> <span class="o">/</span> <span class="n">anp</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>
<span class="g g-Whitespace">     </span><span class="mi">81</span> <span class="n">defvjp</span><span class="p">(</span><span class="n">anp</span><span class="o">.</span><span class="n">log1p</span><span class="p">,</span>  <span class="k">lambda</span> <span class="n">ans</span><span class="p">,</span> <span class="n">x</span> <span class="p">:</span> <span class="k">lambda</span> <span class="n">g</span><span class="p">:</span> <span class="n">g</span> <span class="o">/</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
<span class="ne">---&gt; </span><span class="mi">82</span> <span class="n">defvjp</span><span class="p">(</span><span class="n">anp</span><span class="o">.</span><span class="n">sin</span><span class="p">,</span>    <span class="k">lambda</span> <span class="n">ans</span><span class="p">,</span> <span class="n">x</span> <span class="p">:</span> <span class="k">lambda</span> <span class="n">g</span><span class="p">:</span> <span class="n">g</span> <span class="o">*</span> <span class="n">anp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="g g-Whitespace">     </span><span class="mi">83</span> <span class="n">defvjp</span><span class="p">(</span><span class="n">anp</span><span class="o">.</span><span class="n">cos</span><span class="p">,</span>    <span class="k">lambda</span> <span class="n">ans</span><span class="p">,</span> <span class="n">x</span> <span class="p">:</span> <span class="k">lambda</span> <span class="n">g</span><span class="p">:</span> <span class="o">-</span> <span class="n">g</span> <span class="o">*</span> <span class="n">anp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="g g-Whitespace">     </span><span class="mi">84</span> <span class="n">defvjp</span><span class="p">(</span><span class="n">anp</span><span class="o">.</span><span class="n">tan</span><span class="p">,</span>    <span class="k">lambda</span> <span class="n">ans</span><span class="p">,</span> <span class="n">x</span> <span class="p">:</span> <span class="k">lambda</span> <span class="n">g</span><span class="p">:</span> <span class="n">g</span> <span class="o">/</span> <span class="n">anp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="nn">File ~/miniforge3/envs/myenv/lib/python3.9/site-packages/autograd/tracer.py:37,</span> in <span class="ni">primitive.&lt;locals&gt;.f_wrapped</span><span class="nt">(*args, **kwargs)</span>
<span class="g g-Whitespace">     </span><span class="mi">35</span> <span class="nd">@wraps</span><span class="p">(</span><span class="n">f_raw</span><span class="p">)</span>
<span class="g g-Whitespace">     </span><span class="mi">36</span> <span class="k">def</span> <span class="nf">f_wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="ne">---&gt; </span><span class="mi">37</span>     <span class="n">boxed_args</span><span class="p">,</span> <span class="n">trace</span><span class="p">,</span> <span class="n">node_constructor</span> <span class="o">=</span> <span class="n">find_top_boxed_args</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="g g-Whitespace">     </span><span class="mi">38</span>     <span class="k">if</span> <span class="n">boxed_args</span><span class="p">:</span>
<span class="g g-Whitespace">     </span><span class="mi">39</span>         <span class="n">argvals</span> <span class="o">=</span> <span class="n">subvals</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="p">[(</span><span class="n">argnum</span><span class="p">,</span> <span class="n">box</span><span class="o">.</span><span class="n">_value</span><span class="p">)</span> <span class="k">for</span> <span class="n">argnum</span><span class="p">,</span> <span class="n">box</span> <span class="ow">in</span> <span class="n">boxed_args</span><span class="p">])</span>

<span class="nn">File ~/miniforge3/envs/myenv/lib/python3.9/site-packages/autograd/tracer.py:70,</span> in <span class="ni">find_top_boxed_args</span><span class="nt">(args)</span>
<span class="g g-Whitespace">     </span><span class="mi">68</span> <span class="n">top_node_type</span> <span class="o">=</span> <span class="kc">None</span>
<span class="g g-Whitespace">     </span><span class="mi">69</span> <span class="k">for</span> <span class="n">argnum</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
<span class="ne">---&gt; </span><span class="mi">70</span>     <span class="k">if</span> <span class="n">isbox</span><span class="p">(</span><span class="n">arg</span><span class="p">):</span>
<span class="g g-Whitespace">     </span><span class="mi">71</span>         <span class="n">trace</span> <span class="o">=</span> <span class="n">arg</span><span class="o">.</span><span class="n">_trace</span>
<span class="g g-Whitespace">     </span><span class="mi">72</span>         <span class="k">if</span> <span class="n">trace</span> <span class="o">&gt;</span> <span class="n">top_trace</span><span class="p">:</span>

<span class="ne">KeyboardInterrupt</span>: 
</pre></div>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="solving-the-wave-equation-with-neural-networks">
<h2><span class="section-number">15.10. </span>Solving the wave equation with Neural Networks<a class="headerlink" href="#solving-the-wave-equation-with-neural-networks" title="Permalink to this headline">¶</a></h2>
<p>The wave equation is</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial^2 g(x,t)}{\partial t^2} = c^2\frac{\partial^2 g(x,t)}{\partial x^2}
\]</div>
<p>with <span class="math notranslate nohighlight">\(c\)</span> being the specified wave speed.</p>
<p>Here, the chosen conditions are</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
	g(0,t) &amp;= 0 \\
	g(1,t) &amp;= 0 \\
	g(x,0) &amp;= u(x) \\
	\frac{\partial g(x,t)}{\partial t} \Big |_{t = 0} &amp;= v(x)
\end{align*}
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\frac{\partial g(x,t)}{\partial t} \Big |_{t = 0}\)</span> means the derivative of <span class="math notranslate nohighlight">\(g(x,t)\)</span> with respect to <span class="math notranslate nohighlight">\(t\)</span> is evaluated at <span class="math notranslate nohighlight">\(t = 0\)</span>, and <span class="math notranslate nohighlight">\(u(x)\)</span> and <span class="math notranslate nohighlight">\(v(x)\)</span> being given functions.</p>
<p>The wave equation to solve for, is</p>
<!-- Equation labels as ordinary links -->
<div id="wave"></div>
<div class="math notranslate nohighlight">
\[
\begin{equation} \label{wave} \tag{19}
\frac{\partial^2 g(x,t)}{\partial t^2} = c^2 \frac{\partial^2 g(x,t)}{\partial x^2}
\end{equation}
\]</div>
<p>where <span class="math notranslate nohighlight">\(c\)</span> is the given wave speed.
The chosen conditions for this equation are</p>
<!-- Equation labels as ordinary links -->
<div id="condwave"></div>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
g(0,t) &amp;= 0, &amp;t \geq 0 \\
g(1,t) &amp;= 0, &amp;t \geq 0 \\
g(x,0) &amp;= u(x), &amp;x\in[0,1] \\
\frac{\partial g(x,t)}{\partial t}\Big |_{t = 0} &amp;= v(x), &amp;x \in [0,1]
\end{aligned} \label{condwave} \tag{20}
\end{split}\]</div>
<p>In this example, let <span class="math notranslate nohighlight">\(c = 1\)</span> and <span class="math notranslate nohighlight">\(u(x) = \sin(\pi x)\)</span> and <span class="math notranslate nohighlight">\(v(x) = -\pi\sin(\pi x)\)</span>.</p>
<p>Setting up the network is done in similar matter as for the example of solving the diffusion equation.
The only things we have to change, is the trial solution such that it satisfies the conditions from (<a class="reference external" href="#condwave">20</a>) and the cost function.</p>
<p>The trial solution becomes slightly different since we have other conditions than in the example of solving the diffusion equation. Here, a possible trial solution <span class="math notranslate nohighlight">\(g_t(x,t)\)</span> is</p>
<div class="math notranslate nohighlight">
\[
g_t(x,t) = h_1(x,t) + x(1-x)t^2N(x,t,P)
\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[
h_1(x,t) = (1-t^2)u(x) + tv(x)
\]</div>
<p>Note that this trial solution satisfies the conditions only if <span class="math notranslate nohighlight">\(u(0) = v(0) = u(1) = v(1) = 0\)</span>, which is the case in this example.</p>
<p>The analytical solution for our specific problem, is</p>
<div class="math notranslate nohighlight">
\[
g(x,t) = \sin(\pi x)\cos(\pi t) - \sin(\pi x)\sin(\pi t)
\]</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">autograd.numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">autograd</span> <span class="kn">import</span> <span class="n">hessian</span><span class="p">,</span><span class="n">grad</span>
<span class="kn">import</span> <span class="nn">autograd.numpy.random</span> <span class="k">as</span> <span class="nn">npr</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">cm</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">axes3d</span>

<span class="c1">## Set up the trial function:</span>
<span class="k">def</span> <span class="nf">u</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">v</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">h1</span><span class="p">(</span><span class="n">point</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span><span class="n">t</span> <span class="o">=</span> <span class="n">point</span>
    <span class="k">return</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">t</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">t</span><span class="o">*</span><span class="n">v</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">g_trial</span><span class="p">(</span><span class="n">point</span><span class="p">,</span><span class="n">P</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span><span class="n">t</span> <span class="o">=</span> <span class="n">point</span>
    <span class="k">return</span> <span class="n">h1</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">t</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">deep_neural_network</span><span class="p">(</span><span class="n">P</span><span class="p">,</span><span class="n">point</span><span class="p">)</span>

<span class="c1">## Define the cost function</span>
<span class="k">def</span> <span class="nf">cost_function</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">cost_sum</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">g_t_hessian_func</span> <span class="o">=</span> <span class="n">hessian</span><span class="p">(</span><span class="n">g_trial</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">x_</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">t_</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
            <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_</span><span class="p">,</span><span class="n">t_</span><span class="p">])</span>

            <span class="n">g_t_hessian</span> <span class="o">=</span> <span class="n">g_t_hessian_func</span><span class="p">(</span><span class="n">point</span><span class="p">,</span><span class="n">P</span><span class="p">)</span>

            <span class="n">g_t_d2x</span> <span class="o">=</span> <span class="n">g_t_hessian</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">g_t_d2t</span> <span class="o">=</span> <span class="n">g_t_hessian</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">err_sqr</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(</span><span class="n">g_t_d2t</span> <span class="o">-</span> <span class="n">g_t_d2x</span><span class="p">)</span> <span class="p">)</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">cost_sum</span> <span class="o">+=</span> <span class="n">err_sqr</span>

    <span class="k">return</span> <span class="n">cost_sum</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

<span class="c1">## The neural network</span>
<span class="k">def</span> <span class="nf">sigmoid</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">z</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">deep_neural_network</span><span class="p">(</span><span class="n">deep_params</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="c1"># x is now a point and a 1D numpy array; make it a column vector</span>
    <span class="n">num_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">num_coordinates</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">num_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># N_hidden is the number of hidden layers</span>
    <span class="n">N_hidden</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">deep_params</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># -1 since params consist of parameters to all the hidden layers AND the output layer</span>

    <span class="c1"># Assume that the input layer does nothing to the input x</span>
    <span class="n">x_input</span> <span class="o">=</span> <span class="n">x</span>
    <span class="n">x_prev</span> <span class="o">=</span> <span class="n">x_input</span>

    <span class="c1">## Hidden layers:</span>

    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_hidden</span><span class="p">):</span>
        <span class="c1"># From the list of parameters P; find the correct weigths and bias for this layer</span>
        <span class="n">w_hidden</span> <span class="o">=</span> <span class="n">deep_params</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>

        <span class="c1"># Add a row of ones to include bias</span>
        <span class="n">x_prev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">num_points</span><span class="p">)),</span> <span class="n">x_prev</span> <span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">z_hidden</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">w_hidden</span><span class="p">,</span> <span class="n">x_prev</span><span class="p">)</span>
        <span class="n">x_hidden</span> <span class="o">=</span> <span class="n">sigmoid</span><span class="p">(</span><span class="n">z_hidden</span><span class="p">)</span>

        <span class="c1"># Update x_prev such that next layer can use the output from this layer</span>
        <span class="n">x_prev</span> <span class="o">=</span> <span class="n">x_hidden</span>

    <span class="c1">## Output layer:</span>

    <span class="c1"># Get the weights and bias for this layer</span>
    <span class="n">w_output</span> <span class="o">=</span> <span class="n">deep_params</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Include bias:</span>
    <span class="n">x_prev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="n">num_points</span><span class="p">)),</span> <span class="n">x_prev</span><span class="p">),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">z_output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">w_output</span><span class="p">,</span> <span class="n">x_prev</span><span class="p">)</span>
    <span class="n">x_output</span> <span class="o">=</span> <span class="n">z_output</span>

    <span class="k">return</span> <span class="n">x_output</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

<span class="c1">## The analytical solution</span>
<span class="k">def</span> <span class="nf">g_analytic</span><span class="p">(</span><span class="n">point</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span><span class="n">t</span> <span class="o">=</span> <span class="n">point</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">solve_pde_deep_neural_network</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="p">,</span> <span class="n">num_neurons</span><span class="p">,</span> <span class="n">num_iter</span><span class="p">,</span> <span class="n">lmb</span><span class="p">):</span>
    <span class="c1">## Set up initial weigths and biases</span>
    <span class="n">N_hidden</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">num_neurons</span><span class="p">)</span>

    <span class="c1">## Set up initial weigths and biases</span>

    <span class="c1"># Initialize the list of parameters:</span>
    <span class="n">P</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">N_hidden</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># + 1 to include the output layer</span>

    <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">npr</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">num_neurons</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span> <span class="c1"># 2 since we have two points, +1 to include bias</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">N_hidden</span><span class="p">):</span>
        <span class="n">P</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">npr</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">num_neurons</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="n">num_neurons</span><span class="p">[</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># +1 to include bias</span>

    <span class="c1"># For the output layer</span>
    <span class="n">P</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">npr</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_neurons</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span> <span class="c1"># +1 since bias is included</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Initial cost: &#39;</span><span class="p">,</span><span class="n">cost_function</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>

    <span class="n">cost_function_grad</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="n">cost_function</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Let the update be done num_iter times</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_iter</span><span class="p">):</span>
        <span class="n">cost_grad</span> <span class="o">=</span>  <span class="n">cost_function_grad</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">x</span> <span class="p">,</span> <span class="n">t</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_hidden</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">P</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="n">P</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">-</span> <span class="n">lmb</span> <span class="o">*</span> <span class="n">cost_grad</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>


    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Final cost: &#39;</span><span class="p">,</span><span class="n">cost_function</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">P</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1">### Use the neural network:</span>
    <span class="n">npr</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>

    <span class="c1">## Decide the vales of arguments to the function to solve</span>
    <span class="n">Nx</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">Nt</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">Nt</span><span class="p">)</span>

    <span class="c1">## Set up the parameters for the network</span>
    <span class="n">num_hidden_neurons</span> <span class="o">=</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span>
    <span class="n">num_iter</span> <span class="o">=</span> <span class="mi">1000</span>
    <span class="n">lmb</span> <span class="o">=</span> <span class="mf">0.01</span>

    <span class="n">P</span> <span class="o">=</span> <span class="n">solve_pde_deep_neural_network</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="p">,</span> <span class="n">num_hidden_neurons</span><span class="p">,</span> <span class="n">num_iter</span><span class="p">,</span> <span class="n">lmb</span><span class="p">)</span>

    <span class="c1">## Store the results</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Nt</span><span class="p">))</span>
    <span class="n">res_analytical</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Nt</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">t_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
            <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_</span><span class="p">,</span> <span class="n">t_</span><span class="p">])</span>
            <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">g_trial</span><span class="p">(</span><span class="n">point</span><span class="p">,</span><span class="n">P</span><span class="p">)</span>

            <span class="n">res_analytical</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">g_analytic</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>

    <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">res</span> <span class="o">-</span> <span class="n">res_analytical</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Max difference between analytical and solution from nn: </span><span class="si">%g</span><span class="s2">&quot;</span><span class="o">%</span><span class="k">np</span>.max(diff))

    <span class="c1">## Plot the solutions in two dimensions, that being in position and time</span>

    <span class="n">T</span><span class="p">,</span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">x</span><span class="p">)</span>

    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Solution from the deep neural network w/ </span><span class="si">%d</span><span class="s1"> layer&#39;</span><span class="o">%</span><span class="k">len</span>(num_hidden_neurons))
    <span class="n">s</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">res</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">antialiased</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">viridis</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time $t$&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Position $x$&#39;</span><span class="p">);</span>


    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Analytical solution&#39;</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">res_analytical</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">antialiased</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">viridis</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time $t$&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Position $x$&#39;</span><span class="p">);</span>


    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">gca</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Difference&#39;</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot_surface</span><span class="p">(</span><span class="n">T</span><span class="p">,</span><span class="n">X</span><span class="p">,</span><span class="n">diff</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">antialiased</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="o">.</span><span class="n">viridis</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time $t$&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Position $x$&#39;</span><span class="p">);</span>

    <span class="c1">## Take some slices of the 3D plots just to see the solutions at particular times</span>
    <span class="n">indx1</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">indx2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">Nt</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">indx3</span> <span class="o">=</span> <span class="n">Nt</span><span class="o">-</span><span class="mi">1</span>

    <span class="n">t1</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">indx1</span><span class="p">]</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">indx2</span><span class="p">]</span>
    <span class="n">t3</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">indx3</span><span class="p">]</span>

    <span class="c1"># Slice the results from the DNN</span>
    <span class="n">res1</span> <span class="o">=</span> <span class="n">res</span><span class="p">[:,</span><span class="n">indx1</span><span class="p">]</span>
    <span class="n">res2</span> <span class="o">=</span> <span class="n">res</span><span class="p">[:,</span><span class="n">indx2</span><span class="p">]</span>
    <span class="n">res3</span> <span class="o">=</span> <span class="n">res</span><span class="p">[:,</span><span class="n">indx3</span><span class="p">]</span>

    <span class="c1"># Slice the analytical results</span>
    <span class="n">res_analytical1</span> <span class="o">=</span> <span class="n">res_analytical</span><span class="p">[:,</span><span class="n">indx1</span><span class="p">]</span>
    <span class="n">res_analytical2</span> <span class="o">=</span> <span class="n">res_analytical</span><span class="p">[:,</span><span class="n">indx2</span><span class="p">]</span>
    <span class="n">res_analytical3</span> <span class="o">=</span> <span class="n">res_analytical</span><span class="p">[:,</span><span class="n">indx3</span><span class="p">]</span>

    <span class="c1"># Plot the slices</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Computed solutions at time = </span><span class="si">%g</span><span class="s2">&quot;</span><span class="o">%</span><span class="k">t1</span>)
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">res1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">res_analytical1</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;dnn&#39;</span><span class="p">,</span><span class="s1">&#39;analytical&#39;</span><span class="p">])</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Computed solutions at time = </span><span class="si">%g</span><span class="s2">&quot;</span><span class="o">%</span><span class="k">t2</span>)
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">res2</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">res_analytical2</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;dnn&#39;</span><span class="p">,</span><span class="s1">&#39;analytical&#39;</span><span class="p">])</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Computed solutions at time = </span><span class="si">%g</span><span class="s2">&quot;</span><span class="o">%</span><span class="k">t3</span>)
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">res3</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">res_analytical3</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;dnn&#39;</span><span class="p">,</span><span class="s1">&#39;analytical&#39;</span><span class="p">])</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="resources-on-differential-equations-and-deep-learning">
<h2><span class="section-number">15.11. </span>Resources on differential equations and deep learning<a class="headerlink" href="#resources-on-differential-equations-and-deep-learning" title="Permalink to this headline">¶</a></h2>
<ol class="simple">
<li><p><a class="reference external" href="https://pdfs.semanticscholar.org/d061/df393e0e8fbfd0ea24976458b7d42419040d.pdf">Artificial neural networks for solving ordinary and partial differential equations by I.E. Lagaris et al</a></p></li>
<li><p><a class="reference external" href="https://becominghuman.ai/neural-networks-for-solving-differential-equations-fa230ac5e04c">Neural networks for solving differential equations by A. Honchar</a></p></li>
<li><p><a class="reference external" href="http://cs229.stanford.edu/proj2013/ChiaramonteKiener-SolvingDifferentialEquationsUsingNeuralNetworks.pdf">Solving differential equations using neural networks by M.M Chiaramonte and M. Kiener</a></p></li>
<li><p><a class="reference external" href="https://www.springer.com/us/book/9783540225515">Introduction to Partial Differential Equations by A. Tveito, R. Winther</a></p></li>
</ol>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            
                <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="chapter10.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title"><span class="section-number">14. </span>Building a Feed Forward Neural Network</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="chapter12.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">16. </span>Convolutional Neural Networks</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            
        </div>
    </div>
    <footer class="footer">
  <p>
    
      By Morten Hjorth-Jensen<br/>
    
        &copy; Copyright 2021.<br/>
  </p>
</footer>
</main>


      </div>
    </div>
  
  <script src="_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>