<!--
HTML file automatically generated from DocOnce source
(https://github.com/doconce/doconce/)
doconce format html week7.do.txt --pygments_html_style=perldoc --html_style=solarized3 --html_links_in_new_window --html_output=week7-solarized --no_mako
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/doconce/doconce/" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="February 26-March, 2024: Quantum Computing, Quantum Machine Learning and Quantum Information Theories">
<title>February 26-March, 2024: Quantum Computing, Quantum Machine Learning and Quantum Information Theories</title>
<link href="https://cdn.rawgit.com/doconce/doconce/master/bundled/html_styles/style_solarized_box/css/solarized_light_code.css" rel="stylesheet" type="text/css" title="light"/>
<script src="https://cdn.rawgit.com/doconce/doconce/master/bundled/html_styles/style_solarized_box/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<link href="https://thomasf.github.io/solarized-css/solarized-light.min.css" rel="stylesheet">
<style type="text/css">
h1 {color: #b58900;}  /* yellow */
/* h1 {color: #cb4b16;}  orange */
/* h1 {color: #d33682;}  magenta, the original choice of thomasf */
code { padding: 0px; background-color: inherit; }
pre {
  border: 0pt solid #93a1a1;
  box-shadow: none;
}
.alert-text-small   { font-size: 80%;  }
.alert-text-large   { font-size: 130%; }
.alert-text-normal  { font-size: 90%;  }
.alert {
  padding:8px 35px 8px 14px; margin-bottom:18px;
  text-shadow:0 1px 0 rgba(255,255,255,0.5);
  border:1px solid #93a1a1;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  -moz-border-radius: 4px;
  color: #555;
  background-color: #eee8d5;
  background-position: 10px 5px;
  background-repeat: no-repeat;
  background-size: 38px;
  padding-left: 55px;
  width: 75%;
 }
.alert-block {padding-top:14px; padding-bottom:14px}
.alert-block > p, .alert-block > ul {margin-bottom:1em}
.alert li {margin-top: 1em}
.alert-block p+p {margin-top:5px}
.alert-notice { background-image: url(https://cdn.rawgit.com/doconce/doconce/master/bundled/html_images/small_yellow_notice.png); }
.alert-summary  { background-image:url(https://cdn.rawgit.com/doconce/doconce/master/bundled/html_images/small_yellow_summary.png); }
.alert-warning { background-image: url(https://cdn.rawgit.com/doconce/doconce/master/bundled/html_images/small_yellow_warning.png); }
.alert-question {background-image:url(https://cdn.rawgit.com/doconce/doconce/master/bundled/html_images/small_yellow_question.png); }
div { text-align: justify; text-justify: inter-word; }
.tab {
  padding-left: 1.5em;
}
div.toc p,a {
  line-height: 1.3;
  margin-top: 1.1;
  margin-bottom: 1.1;
}
</style>
</head>

<!-- tocinfo
{'highest level': 2,
 'sections': [('Plans for the week of February 26-March 1',
               2,
               None,
               'plans-for-the-week-of-february-26-march-1'),
              ('Meet the VQE', 2, None, 'meet-the-vqe'),
              ('Main advantage', 2, None, 'main-advantage'),
              ('Basic idea', 2, None, 'basic-idea'),
              ('VQE and quantum circuits', 2, None, 'vqe-and-quantum-circuits'),
              ('Varying paramters', 2, None, 'varying-paramters'),
              ('Constructing trial states',
               2,
               None,
               'constructing-trial-states'),
              ('Hybrid opeations', 2, None, 'hybrid-opeations'),
              ('Reminder on technicalities',
               2,
               None,
               'reminder-on-technicalities'),
              ('Pauli $X$ reminder', 2, None, 'pauli-x-reminder'),
              ('Rewriting the Pauli $X$ matrix',
               2,
               None,
               'rewriting-the-pauli-x-matrix'),
              ('The Pauli $Y$ matrix', 2, None, 'the-pauli-y-matrix'),
              ('Rotations', 2, None, 'rotations'),
              ('Rayleigh-Ritz variational principle',
               2,
               None,
               'rayleigh-ritz-variational-principle'),
              ('The ansatz', 2, None, 'the-ansatz'),
              ('Rotations again', 2, None, 'rotations-again'),
              ('Measurements and more', 2, None, 'measurements-and-more'),
              ('Collecting data', 2, None, 'collecting-data'),
              ('The VQE algoritm', 2, None, 'the-vqe-algoritm'),
              ('VQE overview', 2, None, 'vqe-overview'),
              ('Ansatzes', 2, None, 'ansatzes'),
              ('Preparing the states', 2, None, 'preparing-the-states'),
              ('Rotations used', 2, None, 'rotations-used'),
              ('Implementing using qiskit',
               2,
               None,
               'implementing-using-qiskit'),
              ('VQE and efficient computations of gradients',
               2,
               None,
               'vqe-and-efficient-computations-of-gradients'),
              ('Symmetric matrix', 2, None, 'symmetric-matrix'),
              ('Non-interacting solution', 2, None, 'non-interacting-solution'),
              ('Rewriting with Pauli matrices',
               2,
               None,
               'rewriting-with-pauli-matrices'),
              ('Selecting parameters', 2, None, 'selecting-parameters'),
              ('Setting up the matrix', 2, None, 'setting-up-the-matrix'),
              ('Measurements and computational basis',
               2,
               None,
               'measurements-and-computational-basis'),
              ('Expectation value of $\\boldsymbol{I}$',
               2,
               None,
               'expectation-value-of-boldsymbol-i'),
              ('The Pauli matrices', 2, None, 'the-pauli-matrices'),
              ('In more detail', 2, None, 'in-more-detail'),
              ('For the other two matrices',
               2,
               None,
               'for-the-other-two-matrices'),
              ('Analyzing these equations',
               2,
               None,
               'analyzing-these-equations'),
              ('Using the inner products', 2, None, 'using-the-inner-products'),
              ('Rethinking the basis', 2, None, 'rethinking-the-basis'),
              ('Measurements', 2, None, 'measurements'),
              ('Computational basis', 2, None, 'computational-basis'),
              ('Unitary transformation of $\\boldsymbol{X}$',
               2,
               None,
               'unitary-transformation-of-boldsymbol-x'),
              ('Generalizing', 2, None, 'generalizing'),
              ('Implementing the VQE', 2, None, 'implementing-the-vqe'),
              ('Multiple ansatzes', 2, None, 'multiple-ansatzes'),
              ('Rotations again', 2, None, 'rotations-again'),
              ('Simple code', 2, None, 'simple-code'),
              ('Gradient descent and calculations of gradients',
               2,
               None,
               'gradient-descent-and-calculations-of-gradients'),
              ('Setting up gradients', 2, None, 'setting-up-gradients'),
              ('Derivatives', 2, None, 'derivatives'),
              ('Derivatives of the expectation value of the Hamiltonian',
               2,
               None,
               'derivatives-of-the-expectation-value-of-the-hamiltonian'),
              ('Two addtional expectation values',
               2,
               None,
               'two-addtional-expectation-values'),
              ('Rotations again and again',
               2,
               None,
               'rotations-again-and-again'),
              ('Bloch sphere math', 2, None, 'bloch-sphere-math'),
              ('Derivatives', 2, None, 'derivatives'),
              ('Rewriting', 2, None, 'rewriting'),
              ('Final manipulations', 2, None, 'final-manipulations'),
              ('The expressions to implement',
               2,
               None,
               'the-expressions-to-implement'),
              ('Final expression', 2, None, 'final-expression'),
              ('Basics of gradient descent and stochastic gradient descent',
               2,
               None,
               'basics-of-gradient-descent-and-stochastic-gradient-descent'),
              ('Computing quantum gradients',
               2,
               None,
               'computing-quantum-gradients'),
              ('A smarter way of doing this',
               2,
               None,
               'a-smarter-way-of-doing-this'),
              ('The code for the one qubit case (code developed by August '
               'Gude, 2023)',
               2,
               None,
               'the-code-for-the-one-qubit-case-code-developed-by-august-gude-2023'),
              ('Plans for next week', 2, None, 'plans-for-next-week')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- ------------------- main content ---------------------- -->
<center>
<h1>February 26-March, 2024: Quantum Computing, Quantum Machine Learning and Quantum Information Theories</h1>
</center>  <!-- document title -->

<!-- author(s): Morten Hjorth-Jensen -->
<center>
<b>Morten Hjorth-Jensen</b> [1, 2]
</center>
<!-- institution(s) -->
<center>
[1] <b>Department of Physics, University of Oslo</b>
</center>
<center>
[2] <b>Department of Physics and Astronomy and Facility for Rare Isotope Beams, Michigan State University</b>
</center>
<br>
<center>
<h4>February 28</h4>
</center> <!-- date -->
<br>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="plans-for-the-week-of-february-26-march-1">Plans for the week of February 26-March 1 </h2>

<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<ol>
 <li> Reminder on basics of the VQE method and how to perform measurements for the simpler one- and two-qubit Hamiltonians</li>
 <li> Simulating efficiently Hamiltonians on quantum computers with the VQE method and gradient descent to optimize the state function ansatz</li>
 <li> Work on project 1</li>
 <li> <a href="https://www.sciencedirect.com/science/article/pii/S0370157322003118?via%3Dihub" target="_blank">Reading suggestion, VQE review article</a></li>
</ol>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="meet-the-vqe">Meet the VQE </h2>

<p>The Variational quantum eigensolver (VQE) is a hybrid quantum-classical
algorithm that finds the smallest eigenvalue (and corresponding
eigenvector) of a given Hamiltonian. One of the main applications of
the algorithm is finding ground state energy of quantum mechanical systems.
It has a
big advantage over the quantum phase estimation (QPE) algorithms, that also can be used
for finding the ground state energy of a molecule.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="main-advantage">Main advantage </h2>
<p>The main advantage
is that VQE uses much smaller circuit depths (or gates) than
QPE, what is very important for NISQ (Noisy Intermediate-Scale
Quantum) era quantum computation. In the NISQ era (now!) we are
working with qubits that are very noisy because they are not isolated
from the environment well enough. Thus, there is small and finite time
to work with qubits until they will be <em>spoiled</em>, because of the
environment, imperfect gates and etc. This restriction gives a big
advantage to those algorithms (like VQE) that are using small depth
circuits.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="basic-idea">Basic idea </h2>

<p>The idea of the VQE algorithm is as follows. We have a Hamiltonian that can be expressed by the sum of tensor products of Pauli operators (Pauli terms):</p>

$$
H = 0.4 \cdot IX + 0.6 \cdot IZ + 0.8 \cdot XY.
$$

<p>For a given \( \left| \psi \right\rangle \) we want to measure the expectation value of the Hamiltonian:</p>

$$
\left\langle H \right\rangle = \left\langle \psi \right| H \left| \psi \right\rangle = 0.4 \cdot \left\langle \psi \right| IX \left| \psi \right\rangle + 0.6 \cdot \left\langle \psi \right| IZ \left| \psi \right\rangle + 0.8 \cdot \left\langle \psi \right| XY \left| \psi \right\rangle.
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="vqe-and-quantum-circuits">VQE and quantum circuits </h2>

<p>How one can see the \( \left\langle H \right\rangle \) expectation value
could be computed by adding the expectation values of its parts (Pauli
terms). The algorithm does exactly that. It constructs a quantum
circuit for each Pauli term and computes the expectation value of the
corresponding Pauli term. Then, the algorithm sums all calculated
expectation values of Pauli terms and obtains the expectation value of
\( H \). In this algorithm, we will do this routine of estimating the
expectation value of \( H \) over and over again for different trial
wavefunctions (ansatz states) \( \left| \psi \right\rangle \).
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="varying-paramters">Varying paramters </h2>

<p>It is known that the eigenvector \( \left| \psi_g \right\rangle \) that
minimizes the expectation value \( \left\langle H \right\rangle \)
corresponds to the eigenvector of \( H \) that has the smallest
eigenvalue. So, basically we can try all possible trial wavefunctions
$\left| \psi \right\rangle$s to find the \( \left| \psi_g \right\rangle \)
that has the smallest expectation value. Here the question is how we
create those trial states?
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="constructing-trial-states">Constructing trial states </h2>

<p>In the algorithm, the trial states are
created from a parametrized circuit. By changing the parameters one
obtains different wavefunctions (ansatz states). If your circuit
with its parameters is good enough you will have access to the
subspace of the states that includes the \( \left| \psi_g
\right\rangle \). Otherwise, if the circuit will not have a possibility
to generate our desired \( \left| \psi_g \right\rangle \) it will be
impossible to find the right solution.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="hybrid-opeations">Hybrid opeations </h2>

<p>The parameters of the state preparation circuit are controlled by a
classical computer. At each step, the classical computer will change
the parameters by using some optimization method in order to create an
ansatz state that will have a smaller expectation value then previous
ansatz states had. This way the classical computer and the quantum
computer are working together to archive the goal of the algorithm (to
find the ground state energy). That's way, VQE is a quantum-classical
hybrid algorithm.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="reminder-on-technicalities">Reminder on technicalities </h2>

<p>From our earlier discussions we know that the Pauli \( Z \) matrix has the
above basis states as eigen states through
</p>

$$
\boldsymbol{Z}\vert 0 \rangle=+1\vert 0 \rangle,
$$

<p>and</p>
$$
\boldsymbol{Z}\vert 1 \rangle=-1\vert 1 \rangle,
$$

<p>with eigenvalue \( -1 \).</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="pauli-x-reminder">Pauli \( X \) reminder </h2>

<p>For the Pauli \( X \) matrix on the other hand we have</p>
$$
\boldsymbol{X}\vert 0 \rangle=+1\vert 1 \rangle,
$$

<p>and</p>
$$
\boldsymbol{X}\vert 1 \rangle=-1\vert 0 \rangle,
$$

<p>with eigenvalues \( 1 \) in both cases. The latter two equations tell us
that the computational basis we have chosen, and in which we will
prepare our states, is not an eigenbasis of the \( \sigma_x \) matrix.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="rewriting-the-pauli-x-matrix">Rewriting the Pauli \( X \) matrix </h2>

<p>We rewrite the Pauli \( X \) matrix in terms of a Pauli
\( Z \) matrixcusing the Hadamard matrix
twice, that is
</p>

$$
\boldsymbol{X}=\boldsymbol{\sigma}_x=\boldsymbol{H}\boldsymbol{Z}\boldsymbol{H}.
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="the-pauli-y-matrix">The Pauli \( Y \) matrix </h2>

<p>The Pauli \( Y \) matrix can be written as</p>

$$
\boldsymbol{Y}=\boldsymbol{\sigma}_y=\boldsymbol{H}\boldsymbol{S}^{\dagger}\boldsymbol{Z}\boldsymbol{H}\boldsymbol{S},
$$

<p>where \( S \) is the phase matrix</p>
$$
S = \begin{bmatrix} 1 & 0 \\ 0 & \imath \end{bmatrix}.
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="rotations">Rotations </h2>

<p>Another important set of gates are the <b>rotation operators</b> \( R_x, R_y \) and \( R_z \).
By application to a qubit, we can reach any point on the Bloch sphere by usage of all three once. They are expressed as
</p>
$$
\begin{align*}
    \begin{split}
        R_x(\theta) &= \exp{-iX\theta/2} = \begin{bmatrix}
            \cos(\theta/2) & -i\sin(\theta/2) \\
            -i\sin(\theta/2) & \cos(\theta/2)
        \end{bmatrix}, \\
        R_y(\theta) &= \exp{-iY\theta/2} = \begin{bmatrix}
            \cos(\theta/2) & -\sin(\theta/2) \\
            -\sin(\theta/2) & \cos(\theta/2)
        \end{bmatrix}, \\
        R_z(\theta) &= \exp{-iZ\theta/2} = \begin{bmatrix}
            \exp{-i\theta/2} & 0 \\
            0 & \exp{i\theta/2}
        \end{bmatrix}
    \end{split}
\end{align*}
$$

<p>with all having a period of \( 4\pi \).</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="rayleigh-ritz-variational-principle">Rayleigh-Ritz variational principle </h2>

<p>The Rayleigh-Ritz variational principle states that for a given
Hamiltonian \( H \), the expectation value of a trial state or
just ansatz \( \vert \psi \rangle \) puts a lower bound on the ground state
energy \( E_0 \).
</p>

$$
    \frac{\langle \psi \vert H\vert \psi \rangle}{\langle \psi \vert \psi \rangle} \geq E_0.
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="the-ansatz">The ansatz </h2>

<p>The ansatz is typically chosen to be a parameterized superposition of
basis states that can be varied to improve the energy estimate,
\( \vert \psi\rangle \equiv \vert psi(\boldsymbol{\theta})\rangle \) where
\( \boldsymbol{\theta} = (\theta_1, \ldots, \theta_M) \) are the \( M \)
optimization parameters.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="rotations-again">Rotations again </h2>

<p>To have any flexibility in the
ansatz \( \vert \psi\rangle \), we need to allow for parametrization. The most
common approach is the so-called \( R_y \) ansatz, where we apply chained
operations of rotating around the \( y \)-axis by \( \boldsymbol{\theta} =
(\theta_1,\ldots,\theta_Q) \) of the Bloch sphere and CNOT operations.
</p>

<p>Applications of \( y \) rotations
specifically ensures that our coefficients always remain real, which
often is satisfactory when dealing with many-body systems. 
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="measurements-and-more">Measurements and more </h2>

<p>After the ansatz has been constructed, the Hamiltonian must
be applied. As discussed, the Hamiltonian must be written in terms of
Pauli strings.
</p>

<p>To obtain the expectation value
of the ground state energy, one can measure the expectation value of
each Pauli string, 
</p>
$$
\begin{align*}
    E(\boldsymbol{\theta}) = \sum_i w_i\langle \psi(\boldsymbol{\theta})\vert P_i \vert \psi(\boldsymbol{\theta})\rangle \equiv \sum_i w_i f_i,
\end{align*}
$$

<p>where \( f_i \) is the expectation value of the Pauli string \( i \).</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="collecting-data">Collecting data </h2>

<p>This is estimated statistically by considering measurements in the
appropriate basis of the operator in the Pauli string.
</p>

<p>With \( N_0 \) and \( N_1 \) as the number of \( 0 \) and \( 1 \) measurements respectively, we can estimate \( f_i \) since </p>
$$
\begin{align*}
    f_i = \lim_{N \to \infty} \frac{N_0 - N_1}{N},
\end{align*}
$$

<p>where \( N \) as the number of shots (measurements).</p>

<p>Each Pauli string requires it own circuit, where multiple measurements
of each string is required. Adding the results together with the
corresponding weights, the ground state energy can be estimated. To
optimize with respect to  \( \boldsymbol{\theta} \), a classical optimizer is often
applied.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="the-vqe-algoritm">The VQE algoritm </h2>

<p>The VQE algorithm consists of several steps, partially done on a classical computer:</p>
<ol>
<li> A parameterized ansatz for the quantum state is implemented on a quantum computer.</li>
<li> The ansatz is measured in a given measurement basis.</li>
<li> Postprocessing on a classical computer converts the measurement outcomes to an expectation value.</li>
<li> Classical minimization algorithms are used to up- date the variational parameters.</li>
</ol>
<p>The updated variational parameters are then sent back to the quantum
computer, and the process is repeated until the optimal variational
parameters are found. 
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="vqe-overview">VQE overview </h2>

<br/><br/>
<center>
<p><img src="figures/vqe.png" width="700" align="bottom"></p>
</center>
<br/><br/>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="ansatzes">Ansatzes </h2>

<p>Every possible qubit wavefunction \( \left| \psi \right\rangle \) can be presented as a vector: </p>
$$
\left| \psi \right\rangle = \begin{pmatrix}
\cos{\left( \theta/2 \right)}\\
e^{i \varphi} \cdot \sin{\left( \theta/2 \right)}
\end{pmatrix},
$$

<p>where the numbers \( \theta \) and \( \varphi \) define a point on the unit
three-dimensional sphere, the so-called  Bloch sphere.
</p>

<p>For a random one qubit Hamiltonian, a <em>good</em> quantum state preparation
circuit should be able to generate all possible states in the Bloch
sphere.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="preparing-the-states">Preparing the states </h2>

<p>Before quantum state preparation, our qubit is in the \( \vert 0\rangle \) state.
This corresponds to the vertical position of
the vector in the Bloch sphere. In order to generate any possible
\( \left| \psi \right\rangle \) we will apply \( R_x(t_1) \) and \( R_y(t_2) \)
gates on the \( \left| 0 \right\rangle \) initial state
</p>
$$
R_y(t_2)R_x(t_1) \left| 0 \right\rangle = \left| \psi\right\rangle.
$$

<p>The rotation \( R_x(t_1) \)
corresponds to the rotation in the Bloch
sphere around the \( x \)-axis and \( R_y(t_2) \) the rotation around the \( y \)-axis.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="rotations-used">Rotations used </h2>

<p>With these two rotations, one can have access to any point in
the Bloch sphere. Here we show the matrix forms of \( R_x(t_1) \) and
\( R_y(t_2) \) gates:
</p>

$$
R_x(t_1) = \begin{pmatrix}
cos(\frac{t_1}{2}) & -i \cdot sin(\frac{t_1}{2})\\
-i \cdot sin(\frac{t_1}{2}) & cos(\frac{t_1}{2})
\end{pmatrix},
\qquad
R_y(t_2) = \begin{pmatrix}
cos(\frac{t_2}{2}) & -sin(\frac{t_2}{2})\\
sin(\frac{t_2}{2}) & cos(\frac{t_2}{2})
\end{pmatrix}.
$$

<p>These two gates with there parameters (\( t_1 \) and \( t_2 \)) will generate
for us the trial (ansatz) wavefunctions. The two parameters will be in
control of the Classical Computer and its optimization model.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="implementing-using-qiskit">Implementing using qiskit </h2>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">random</span> <span style="color: #8B008B; font-weight: bold">import</span> random
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">qiskit</span> <span style="color: #8B008B; font-weight: bold">import</span> *
<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">quantum_state_preparation</span>(circuit, parameters):
    q = circuit.qregs[<span style="color: #B452CD">0</span>] <span style="color: #228B22"># q is the quantum register where the info about qubits is stored</span>
    circuit.rx(parameters[<span style="color: #B452CD">0</span>], q[<span style="color: #B452CD">0</span>]) <span style="color: #228B22"># q[0] is our one and only qubit XD</span>
    circuit.ry(parameters[<span style="color: #B452CD">1</span>], q[<span style="color: #B452CD">0</span>])
    <span style="color: #8B008B; font-weight: bold">return</span> circuit
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="vqe-and-efficient-computations-of-gradients">VQE and efficient computations of gradients  </h2>

<p>We start with a reminder on the VQE method with applications to the
one-qubit system discussed last week.
</p>

<p>Here we revisit the one-qubit system and develop a VQE
code for studying this system using gradient descent as a method to
optimize the variational ansatz. 
</p>

<p>We start with a simple \( 2\times 2 \) Hamiltonian matrix expressed in
terms of Pauli \( X \) and \( Z \) matrices, as discussed in the project text.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="symmetric-matrix">Symmetric matrix </h2>

<p>We define a  symmetric matrix  \( H\in {\mathbb{R}}^{2\times 2} \)</p>
$$
H = \begin{bmatrix} H_{11} & H_{12} \\ H_{21} & H_{22}
\end{bmatrix},
$$

<p>We  let \( H = H_0 + H_I \), where</p>
$$
H_0= \begin{bmatrix} E_1 & 0 \\ 0 & E_2\end{bmatrix},
$$

<p>is a diagonal matrix. Similarly,</p>
$$
H_I= \begin{bmatrix} V_{11} & V_{12} \\ V_{21} & V_{22}\end{bmatrix},
$$

<p>where \( V_{ij} \) represent various interaction matrix elements.</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="non-interacting-solution">Non-interacting solution </h2>

<p>We can view \( H_0 \) as the non-interacting solution</p>
$$
\begin{equation}
       H_0\vert 0 \rangle =E_1\vert 0 \rangle,
\label{_auto1}
\end{equation}
$$

<p>and</p>
$$
\begin{equation}
       H_0\vert 1\rangle =E_2\vert 1\rangle,
\label{_auto2}
\end{equation}
$$

<p>where we have defined the orthogonal computational one-qubit basis states \( \vert 0\rangle \) and \( \vert 1\rangle \).</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="rewriting-with-pauli-matrices">Rewriting with Pauli matrices </h2>
<p>We rewrite \( H \) (and \( H_0 \) and \( H_I \))  via Pauli matrices</p>
$$
H_0 = \mathcal{E} I + \Omega \sigma_z, \quad \mathcal{E} = \frac{E_1
  + E_2}{2}, \; \Omega = \frac{E_1-E_2}{2},
$$

<p>and</p>
$$
H_I = c \boldsymbol{I} +\omega_z\sigma_z + \omega_x\sigma_x,
$$

<p>with \( c = (V_{11}+V_{22})/2 \), \( \omega_z = (V_{11}-V_{22})/2 \) and \( \omega_x = V_{12}=V_{21} \).
We let our Hamiltonian depend linearly on a strength parameter \( \lambda \)
</p>

$$
H=H_0+\lambda H_\mathrm{I},
$$

<p>with \( \lambda \in [0,1] \), where the limits \( \lambda=0 \) and \( \lambda=1 \)
represent the non-interacting (or unperturbed) and fully interacting
system, respectively.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="selecting-parameters">Selecting parameters </h2>

<p>The model is an eigenvalue problem with only
two available states.
</p>

<p>Here we set the parameters \( E_1=0 \),
\( E_2=4 \), \( V_{11}=-V_{22}=3 \) and \( V_{12}=V_{21}=0.2 \).
</p>

<p>The non-interacting solutions represent our computational basis.
Pertinent to our choice of parameters, is that at \( \lambda\geq 2/3 \),
the lowest eigenstate is dominated by \( \vert 1\rangle \) while the upper
is \( \vert 0 \rangle \). At \( \lambda=1 \) the \( \vert 0 \rangle \) mixing of
the lowest eigenvalue is \( 1\% \) while for \( \lambda\leq 2/3 \) we have a
\( \vert 0 \rangle \) component of more than \( 90\% \).  The character of the
eigenvectors has therefore been interchanged when passing \( z=2/3 \). The
value of the parameter \( V_{12} \) represents the strength of the coupling
between the two states.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="setting-up-the-matrix">Setting up the matrix </h2>
<p>This part is best seen using the jupyter-notebook</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #8B008B; font-weight: bold">from</span>  <span style="color: #008b45; text-decoration: underline">matplotlib</span> <span style="color: #8B008B; font-weight: bold">import</span> pyplot <span style="color: #8B008B; font-weight: bold">as</span> plt
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
dim = <span style="color: #B452CD">2</span>
Hamiltonian = np.zeros((dim,dim))
e0 = <span style="color: #B452CD">0.0</span>
e1 = <span style="color: #B452CD">4.0</span>
Xnondiag = <span style="color: #B452CD">0.20</span>
Xdiag = <span style="color: #B452CD">3.0</span>
Eigenvalue = np.zeros(dim)
<span style="color: #228B22"># setting up the Hamiltonian</span>
Hamiltonian[<span style="color: #B452CD">0</span>,<span style="color: #B452CD">0</span>] = Xdiag+e0
Hamiltonian[<span style="color: #B452CD">0</span>,<span style="color: #B452CD">1</span>] = Xnondiag
Hamiltonian[<span style="color: #B452CD">1</span>,<span style="color: #B452CD">0</span>] = Hamiltonian[<span style="color: #B452CD">0</span>,<span style="color: #B452CD">1</span>]
Hamiltonian[<span style="color: #B452CD">1</span>,<span style="color: #B452CD">1</span>] = e1-Xdiag
<span style="color: #228B22"># diagonalize and obtain eigenvalues, not necessarily sorted</span>
EigValues, EigVectors = np.linalg.eig(Hamiltonian)
permute = EigValues.argsort()
EigValues = EigValues[permute]
<span style="color: #228B22"># print only the lowest eigenvalue</span>
<span style="color: #658b00">print</span>(EigValues[<span style="color: #B452CD">0</span>])
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Now rewrite it in terms of the identity matrix and the Pauli matrix X and Z</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #228B22"># Now rewrite it in terms of the identity matrix and the Pauli matrix X and Z</span>
X = np.array([[<span style="color: #B452CD">0</span>,<span style="color: #B452CD">1</span>],[<span style="color: #B452CD">1</span>,<span style="color: #B452CD">0</span>]])
Y = np.array([[<span style="color: #B452CD">0</span>,-<span style="color: #B452CD">1</span>j],[<span style="color: #B452CD">1</span>j,<span style="color: #B452CD">0</span>]])
Z = np.array([[<span style="color: #B452CD">1</span>,<span style="color: #B452CD">0</span>],[<span style="color: #B452CD">0</span>,-<span style="color: #B452CD">1</span>]])
<span style="color: #228B22"># identity matrix</span>
I = np.array([[<span style="color: #B452CD">1</span>,<span style="color: #B452CD">0</span>],[<span style="color: #B452CD">0</span>,<span style="color: #B452CD">1</span>]])

epsilon = (e0+e1)*<span style="color: #B452CD">0.5</span>; omega = (e0-e1)*<span style="color: #B452CD">0.5</span>
c = <span style="color: #B452CD">0.0</span>; omega_z=Xdiag; omega_x = Xnondiag
Hamiltonian = (epsilon+c)*I+(omega_z+omega)*Z+omega_x*X
EigValues, EigVectors = np.linalg.eig(Hamiltonian)
permute = EigValues.argsort()
EigValues = EigValues[permute]
<span style="color: #228B22"># print only the lowest eigenvalue</span>
<span style="color: #658b00">print</span>(EigValues[<span style="color: #B452CD">0</span>])
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="measurements-and-computational-basis">Measurements and computational basis </h2>

<p>We have seen how to rewrite the above \( 2\times 2 \) eiegenvalue problem in terms of a Hamiltonian defined by Pauli \( \boldsymbol{X} \) and \( \boldsymbol{Z} \) matrices,
and the identity matrix \( \boldsymbol{I} \). Let us make this Hamiltonian that involves only one qubit somewhat more general
</p>
$$
\left\langle H \right\rangle = \left\langle \psi \right| H \left| \psi \right\rangle = a \cdot \left\langle \psi \right| I \left| \psi \right\rangle + b \cdot \left\langle \psi \right| Z \left| \psi \right\rangle + c \cdot \left\langle \psi \right| X \left| \psi \right\rangle + d \cdot \left\langle \psi \right| Y \left| \psi \right\rangle.
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="expectation-value-of-boldsymbol-i">Expectation value of \( \boldsymbol{I} \) </h2>

<p>For the \( I \) operator the expectation value is always unity:</p>

$$
\left\langle \psi \right| \boldsymbol{I} \left| \psi \right\rangle = \left\langle \psi \right|\left| \psi \right\rangle = 1.
$$

<p>Its contribution to the overall expectaction value is thus given by the constant \( a \).</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="the-pauli-matrices">The Pauli matrices </h2>

<p>For rest of the Pauli operators, we should make the following remark:
every one qubit quantum state \( \left| \psi \right\rangle \) can be
represented via different sets of basis vectors:
</p>

$$
\left| \psi \right\rangle = c_1^z \cdot \left| 0 \right\rangle + c_2^z \cdot \left| 1 \right\rangle = c_1^x \cdot \left| + \right\rangle + c_2^x \cdot \left| - \right\rangle = c_1^y \cdot \left| +i \right\rangle + c_2^y \cdot \left| -i \right\rangle.
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="in-more-detail">In more detail </h2>
<p>We have</p>
$$
\begin{align*}
&\text{Z eigenvectors} \qquad
\left| 0 \right\rangle = \begin{pmatrix}
1\\
0
\end{pmatrix},
&&\left| 1 \right\rangle = \begin{pmatrix}
0\\
1
\end{pmatrix},
\end{align*}
$$

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="for-the-other-two-matrices">For the other two matrices </h2>

$$
\begin{align*}
&\text{X eigenvectors} \qquad
\left| + \right\rangle = \frac{1}{\sqrt{2}} \begin{pmatrix}
1\\
1
\end{pmatrix},
&&\left| - \right\rangle = \frac{1}{\sqrt{2}} \begin{pmatrix}
1\\
-1
\end{pmatrix},
\\
&\text{Y eigenvectors} \qquad
\left| +i \right\rangle = \frac{1}{\sqrt{2}} \begin{pmatrix}
1\\
i
\end{pmatrix}, 
&&\left| -i \right\rangle = \frac{1}{\sqrt{2}} \begin{pmatrix}
1\\
-i
\end{pmatrix}.
\end{align*}
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="analyzing-these-equations">Analyzing these equations </h2>

<p>The first presented eigenvectors for each Pauli has an eigenvalue equal to \( +1 \): \( Z \left| 0 \right\rangle = +1\left| 0 \right\rangle \), \( X \left| + \right\rangle = +1\left| + \right\rangle \), \( Y \left| +i \right\rangle = +1\left| +i \right\rangle \). And the second presented eigenvectors for each Pauli has an eigenvalue equal to \( -1 \): \( Z \left| 1 \right\rangle = -1\left| 1 \right\rangle \), \( X \left| - \right\rangle = -1\left| - \right\rangle \), \( Y \left| -i \right\rangle = -1\left| -i \right\rangle \). Now, let's calculate the expectation values of these Pauli operators: </p>

$$
\begin{align*}
\left\langle \psi \right| Z \left| \psi \right\rangle &= \left( {c_1^z}^* \cdot \left\langle 0 \right| + {c_2^z}^* \cdot \left\langle 1 \right| \right) Z \left( c_1^z \cdot \left| 0 \right\rangle + c_2^z \cdot \left| 1 \right\rangle \right) = {\left| c_1^z \right|}^2 - {\left| c_2^z \right|}^2,
\\
\left\langle \psi \right| X \left| \psi \right\rangle &= \left( {c_1^x}^* \cdot \left\langle + \right| + {c_2^x}^* \cdot \left\langle - \right| \right) X \left( c_1^x \cdot \left| + \right\rangle + c_2^x \cdot \left| - \right\rangle \right) = {\left| c_1^x \right|}^2 - {\left| c_2^x \right|}^2,
\\
\left\langle \psi \right| Y \left| \psi \right\rangle &= \left( {c_1^y}^* \cdot \left\langle +i \right| + {c_2^y}^* \cdot \left\langle -i \right| \right) Y \left( c_1^y \cdot \left| +i \right\rangle + c_2^y \cdot \left| -i \right\rangle \right) = {\left| c_1^y \right|}^2 - {\left| c_2^y \right|}^2.
\end{align*}
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="using-the-inner-products">Using the inner products </h2>
<p>Here we have taken into account that the inner product of orthonormal vectors is 0 (e.g. \( \left\langle 0 \right| \left| 1 \right\rangle = 0 \), \( \left\langle + \right| \left| - \right\rangle = 0 \), \( \left\langle +i \right| \left| -i \right\rangle = 0 \)).</p>

<p>But what are these $\left| c \right|^2$s? The \( {\left| c_1^z
\right|}^2 \) and \( {\left| c_2^z \right|}^2 \) are by definition the
probabilities that after Z basis measurement (measuring is it \( \left|
0 \right\rangle \) or is it \( \left| 1 \right\rangle \)) the quantum state
\( \left| \psi \right\rangle \) will become \( \left| 0 \right\rangle \) or
\( \left| 1 \right\rangle \) respectively.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="rethinking-the-basis">Rethinking the basis </h2>

<p>In order to find that value, we should run our program with our trial
\( \left| \psi \right\rangle \) wavefunction and do \( Z \) measurement on the
qubit \( N \) times (it is  named <em>shots</em> in the code).
</p>

<p>The probability
of finding the qubit after measurment in \( \left| 0 \right\rangle \)
state will be equal to \( {\left| c_1^z \right|}^2 = \frac{n_0}{N} \),
where \( n_0 \) is the number of the \( \left| 0 \right\rangle \) state
measurments. Similarly, \( {\left| c_2^z \right|}^2 = \frac{n_1}{N} \),
where \( n_1 \) is the number of the \( \left| 1 \right\rangle \) state
measurments.
</p>

<p>Thus, the final expectation value will be \( \left\langle Z\right\rangle = \frac{n_0 - n_1}{N} \).</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="measurements">Measurements </h2>

<p>For \( \left\langle X \right\rangle = \frac{n_+ - n_-}{N} \) and
\( \left\langle Y \right\rangle = \frac{n_{+i} - n_{-i}}{N} \) the
expectation value estimation procedure stays the same.
</p>

<p>Here \( n_+ \) and \( n_- \) are numbers of measurements in X basis that
corresponds to \( \left| + \right\rangle \) or \( \left| - \right\rangle \)
outcomes respectively. And \( n_{+i} \) and \( n_{-i} \) are numbers of
measurements in \( Y \) basis that corresponds to \( \left| +i
\right\rangle \) or \( \left| -i \right\rangle \) outcomes respectively.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="computational-basis">Computational basis </h2>

<p>The difficulty comes from the fact that one may have the possibility
to measure only in the \( Z \) basis. To solve this difficulty we still do
a \( Z \) basis measurement, but, before that, we apply specific operators
to the \( \left| \psi \right\rangle \) state.
</p>

<p>We try to apply such an
operator that after measuring the probability of \( \left| 0
\right\rangle \) outcome will be equal to the probability of \( \left| +
\right\rangle \) $\left( \left| +i \right\rangle \right)$ outcome.
</p>

<p>And the probability of \( \left| 1 \right\rangle \) outcome will be equal to
the probability of \( \left| - \right\rangle \) $\left( \left| -i \right\rangle \right)$ outcome.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="unitary-transformation-of-boldsymbol-x">Unitary transformation of \( \boldsymbol{X} \) </h2>

<p>If we use the Hadamard gate</p>
$$
\boldsymbol{H} = \frac{1}{\sqrt{2}}\begin{pmatrix}
1 & 1\\
1 & -1
\end{pmatrix},
$$

<p>we can rewrite</p>
$$
\boldsymbol{X}=\boldsymbol{H}\boldsymbol{Z}\boldsymbol{H}.
$$

<p>The Hadamard gate/matrix is a unitary matrix with the property that \( \boldsymbol{H}^2=\boldsymbol{I} \).</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="generalizing">Generalizing </h2>

<p>For the one-qubit Hamiltonian we have toyed with till now, we can thus
rewrite in an easy way the Hamiltonian so that we can perform
measurements using our favorite computational basis.
</p>

<p>The transformation of the Pauli \( \boldsymbol{X} \) matrix can be generalized, as
we will see in more detail next week for the two-qubit Hamiltonian and
the Lipkin model, to the following expression
</p>
$$
{\cal P}=\boldsymbol{U}^{\dagger}\boldsymbol{M}\boldsymbol{U},
$$

<p>where \( {\cal P} \) represents some combination of the Pauli matrices and
the identity matrix, \( \boldsymbol{U} \) is a unitary matrix and \( \boldsymbol{M} \)
represents the gate/matrix which performs the measurements, often
represented by a Pauli \( \boldsymbol{Z} \) gate/matrix.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="implementing-the-vqe">Implementing the VQE </h2>

<p>For a one-qubit system we can reach every point on the Bloch sphere
(as discussed earlier) with a rotation about the \( x \)-axis and the
\( y \)-axis.
</p>

<p>We can express this mathematically through the following operations (see whiteboard for the drawing), giving us a new state \( \vert \psi\rangle \)</p>
$$
\vert\psi\rangle = R_y(\phi)R_x(\theta)\vert 0 \rangle.
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="multiple-ansatzes">Multiple ansatzes </h2>

<p>We can produce multiple ansatzes for the new state in terms of the
angles \( \theta \) and \( \phi \).  With these ansatzes we can in turn
calculate the expectation value of the above Hamiltonian, now
rewritten in terms of various Pauli matrices (and thereby gates), that is compute
</p>

$$
\langle \psi \vert (c+\mathcal{E})\boldsymbol{I} + (\Omega+\omega_z)\boldsymbol{\sigma}_z + \omega_x\boldsymbol{\sigma}_x\vert \psi \rangle.
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="rotations-again">Rotations again </h2>

<p>We can now set up a series of ansatzes for \( \vert \psi \rangle \) as
function of the angles \( \theta \) and \( \phi \) and find thereafter the
variational minimum using for example a gradient descent method.
</p>

<p>To do so, we need to remind ourselves about the mathematical expressions for
the rotational matrices/operators.
</p>

$$
R_x(\theta)=\cos{\frac{\theta}{2}}\boldsymbol{I}-\imath \sin{\frac{\theta}{2}}\boldsymbol{\sigma}_x,
$$

<p>and</p>

$$
R_y(\phi)=\cos{\frac{\phi}{2}}\boldsymbol{I}-\imath \sin{\frac{\phi}{2}}\boldsymbol{\sigma}_y.
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="simple-code">Simple code </h2>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #228B22"># define the rotation matrices</span>
<span style="color: #228B22"># Define angles theta and phi</span>
theta = <span style="color: #B452CD">0.5</span>*np.pi; phi = <span style="color: #B452CD">0.2</span>*np.pi
Rx = np.cos(theta*<span style="color: #B452CD">0.5</span>)*I-<span style="color: #B452CD">1</span>j*np.sin(theta*<span style="color: #B452CD">0.5</span>)*X
Ry = np.cos(phi*<span style="color: #B452CD">0.5</span>)*I-<span style="color: #B452CD">1</span>j*np.sin(phi*<span style="color: #B452CD">0.5</span>)*Y
<span style="color: #228B22">#define basis states</span>
basis0 = np.array([<span style="color: #B452CD">1</span>,<span style="color: #B452CD">0</span>])
basis1 = np.array([<span style="color: #B452CD">0</span>,<span style="color: #B452CD">1</span>])

NewBasis = Ry @ Rx @ basis0
<span style="color: #658b00">print</span>(NewBasis)
<span style="color: #228B22"># Compute the expectation value</span>
<span style="color: #228B22">#Note hermitian conjugation</span>
Energy = NewBasis.conj().T @ Hamiltonian @ NewBasis
<span style="color: #658b00">print</span>(Energy)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Not an impressive results. We set up now a loop over many angles \( \theta \) and \( \phi \) and compute the energies</p>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #228B22"># define a number of angles</span>
n = <span style="color: #B452CD">20</span>
angle = np.arange(<span style="color: #B452CD">0</span>,<span style="color: #B452CD">180</span>,<span style="color: #B452CD">10</span>)
n = np.size(angle)
ExpectationValues = np.zeros((n,n))
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span> (n):
    theta = np.pi*angle[i]/<span style="color: #B452CD">180.0</span>
    Rx = np.cos(theta*<span style="color: #B452CD">0.5</span>)*I-<span style="color: #B452CD">1</span>j*np.sin(theta*<span style="color: #B452CD">0.5</span>)*X
    <span style="color: #8B008B; font-weight: bold">for</span> j <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span> (n):
        phi = np.pi*angle[j]/<span style="color: #B452CD">180.0</span>
        Ry = np.cos(phi*<span style="color: #B452CD">0.5</span>)*I-<span style="color: #B452CD">1</span>j*np.sin(phi*<span style="color: #B452CD">0.5</span>)*Y
        NewBasis = Ry @ Rx @ basis0
        Energy = NewBasis.conj().T @ Hamiltonian @ NewBasis
        Edifference=<span style="color: #658b00">abs</span>(np.real(EigValues[<span style="color: #B452CD">0</span>]-Energy))
        ExpectationValues[i,j]=Edifference

<span style="color: #658b00">print</span>(np.min(ExpectationValues))
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Clearly, this is not the best way of proceeding. Rather, here we
could try to find the optimal values for the parameters \( \theta \) and
\( \phi \) through computation of their respective gradients and thereby
find the minimum as function of the optimal angles \( \hat{\theta} \) and
\( \hat{\phi} \).
</p>

<p>Let us now implement a classical gradient descent algorithm to the computation of the energies. 
We will follow closely  <a href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.99.032331" target="_blank"><tt>https://journals.aps.org/pra/abstract/10.1103/PhysRevA.99.032331</tt></a> in order to calculate gradients of the Hamiltonian.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="gradient-descent-and-calculations-of-gradients">Gradient descent and calculations of gradients </h2>

<p>In order to optimize the VQE ansatz, we need to compute derivatives
with respect to the variational parameters.  Here we develop first a
simpler approach tailored to the one-qubit case. For this particular
case, we have defined an ansatz in terms of the Pauli rotation
matrices.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="setting-up-gradients">Setting up gradients </h2>

<p>These define an arbitrary one-qubit state on the Bloch
sphere through the expression
</p>

$$
\vert\psi\rangle = \vert \psi(\theta,\phi)\rangle =R_y(\phi)R_x(\theta)\vert 0 \rangle.
$$

<p>Each of these rotation matrices can be written in a more general form as</p>
$$
R_{i}(\gamma)=\exp{-(\imath\frac{\gamma}{2}\sigma_i)}=\cos{(\frac{\gamma}{2})}\boldsymbol{I}-\imath\sin{(\frac{\gamma}{2})}\boldsymbol{\sigma}_i,
$$

<p>where \( \sigma_i \) is one of the Pauli matrices \( \sigma_{x,y,z} \). </p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="derivatives">Derivatives </h2>

<p>It is easy to see that the derivative with respect to \( \gamma \) is</p>
$$
\frac{\partial R_{i}(\gamma)}{\partial \gamma}=-\frac{\gamma}{2}\boldsymbol{\sigma}_i R_{i}(\gamma).
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="derivatives-of-the-expectation-value-of-the-hamiltonian">Derivatives of the expectation value of the Hamiltonian </h2>

<p>We can now calculate the derivative of the expectation value of the
Hamiltonian in terms of the angles \( \theta \) and \( \phi \). We have two
derivatives 
</p>
$$
\frac{\partial}{\partial \theta}\left[\langle \psi(\theta,\phi) \vert \boldsymbol{H}\vert \psi(\theta,\phi)\rangle\right]=\frac{\partial}{\partial \theta}\left[\langle\boldsymbol{H}(\theta,\phi)\rangle\right]=\langle \psi(\theta,\phi) \vert \boldsymbol{H}(-\frac{\imath}{2}\boldsymbol{\sigma}_x\vert \psi(\theta,\phi)\rangle+\hspace{0.1cm}\mathrm{h.c},
$$

<p>and</p>
$$
\frac{\partial }{\partial \phi}\left[\langle \psi(\theta,\phi) \vert \boldsymbol{H}\vert \psi(\theta,\phi)\rangle\right]=\frac{\partial}{\partial \phi}\left[\langle\boldsymbol{H}(\theta,\phi)\rangle\right]=\langle \psi(\theta,\phi) \vert \boldsymbol{H}(-\frac{\imath}{2}\boldsymbol{\sigma}_y\vert \psi(\theta,\phi)\rangle+\hspace{0.1cm}\mathrm{h.c}. 
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="two-addtional-expectation-values">Two addtional expectation values </h2>

<p>This means that we have to calculate two additional expectation values
in addition to the expectation value of the Hamiltonian itself.  If we
stay with an ansatz for the single qubit states given by the above
rotation operators, we can, following for example <a href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.99.032331" target="_blank">the article by
Maria Schuld et
al</a>,
show that the derivative of the expectation value of the Hamiltonian
can be written as (we focus only on a given angle \( \phi \))
</p>

$$
\frac{\partial}{\partial \phi}\left[\langle\boldsymbol{H}(\phi)\rangle\right]=\frac{1}{2}\left[\langle\boldsymbol{H}(\phi+\frac{\pi}{2})\rangle-\langle\boldsymbol{H}(\phi-\frac{\pi}{2})\rangle\right].
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="rotations-again-and-again">Rotations again and again </h2>
<p>To see this, consider again the definition of the rotation operators.
We can write these operators as
</p>

$$
R_i(\phi)=\exp{-\imath(\phi \boldsymbol{\sigma}_i)},
$$

<p>with \( \boldsymbol{sigma}_i \), with \( \boldsymbol{\sigma}_i \) being any of the Pauli
matrices \( X \), \( Y \) and \( Z \). The latter can be generalized to other
unitary matrices as well.
The derivative with respect to \( \phi \) gives
</p>
$$
\frac{\partial R_i(\phi)}{\partial \phi}=-\frac{\imath}{2} \boldsymbol{\sigma}_i\exp{-\imath(\phi \boldsymbol{\sigma}_i)}=-\frac{\imath}{2} \boldsymbol{\sigma} R_i(\phi).
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="bloch-sphere-math">Bloch sphere math </h2>

<p>Our ansatz for a general one-qubit state on the Bloch sphere contains the product of a rotation around the \( x \)-axis and the \( y \)-axis. In the derivation here we focus only on one angle however. Our ansatz is then given by</p>

$$
\vert \psi \rangle = R_i(\phi)\vert 0 \rangle,
$$

<p>and the expectation value of our Hamiltonian is</p>

$$
\langle \psi \vert \hat{H}\vert \psi \rangle = \langle 0 \vert R_i(\phi)^{\dagger} \hat{H}R_i(\phi)\vert 0\rangle. 
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="derivatives">Derivatives </h2>

<p>Our derivative with respect to the angle \( \phi \) has a similar structure, that is</p>
$$
\frac{\partial }{\partial \phi}\left[\langle \psi(\theta,\phi) \vert \boldsymbol{H}\vert \psi(\theta,\phi)\rangle\right]=\langle \psi(\theta,\phi) \vert \boldsymbol{H}(-\frac{\imath}{2}\boldsymbol{\sigma}_y\vert \psi(\theta,\phi)\rangle+\hspace{0.1cm}\mathrm{h.c}. 
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="rewriting">Rewriting </h2>

<p>In order to rewrite the equation of the derivative,
the following relation is useful
</p>
$$
\langle \psi \vert \hat{A}^{\dagger}\hat{B}\hat{C}\vert \psi \rangle = \frac{1}{2}\left[
\langle \psi \vert (\hat{A}+\hat{C})^{\dagger}\hat{B}(\boldsymbol{A}+\hat{C})\vert \psi \rangle-\langle \psi \vert (\hat{A}-\hat{C})^{\dagger}\hat{B}(\boldsymbol{A}-\hat{C})\vert \psi \rangle\right],
$$

<p>where \( \hat{A} \), \( \hat{B} \) and \( \hat{C} \) are arbitrary hermitian
operators.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="final-manipulations">Final manipulations </h2>

<p>If we identify these operators as \( \hat{A}=\boldsymbol{I} \), with
\( \boldsymbol{I} \) being the unit operator, \( \hat{B}=\hat{H} \) our Hamiltonian,
and \( \hat{C}=-\imath \boldsymbol{\sigma}_i/2 \), we obtain the following
expression for the expectation value of the derivative (excluding the hermitian conjugate)
</p>

$$
\langle \psi \vert \boldsymbol{I}^{\dagger}\hat{H}(-\frac{\imath}{2}\boldsymbol{\sigma}_i\vert \psi \rangle = \frac{1}{2}\left[
\langle \psi \vert (\boldsymbol{I}-\frac{\imath}{2} \boldsymbol{\sigma}_i)^{\dagger}\hat{H}(\boldsymbol{I}-\frac{\imath}{2} \boldsymbol{\sigma}_i)\vert \psi \rangle-\langle \psi \vert (\boldsymbol{I}+\frac{\imath}{2} \boldsymbol{\sigma}_i)^{\dagger}\hat{H}(\boldsymbol{I}+\frac{\imath}{2} \boldsymbol{\sigma}_i)\vert \psi \rangle\right].
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="the-expressions-to-implement">The expressions to implement </h2>

<p>If we then use that the rotation matrices can be rewritten as</p>
$$
R_{i}(\phi)=\exp{-(\imath\frac{\phi}{2}\sigma_i)}=\cos{(\frac{\phi}{2})}\boldsymbol{I}-\imath\sin{(\frac{\phi}{2})}\boldsymbol{\sigma}_i,
$$

<p>we see that if we set the angle to \( \phi=\pi/2 \), we have </p>
$$
R_{i}(\frac{\pi}{2})=\cos{(\frac{\pi}{4})}\boldsymbol{I}-\imath\sin{(\frac{\pi}{4})}\boldsymbol{\sigma}_i=\frac{1}{\sqrt{2}}\left(\boldsymbol{I}-\frac{\imath}{2} \boldsymbol{\sigma}_i\right).
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="final-expression">Final expression </h2>

<p>This means that we can write</p>
$$
\langle \psi \vert \boldsymbol{I}^{\dagger}\hat{H}(-\frac{\imath}{2}\boldsymbol{\sigma}_i\vert \psi \rangle = \frac{1}{2}\left[
\langle \psi \vert R_i(\frac{\pi}{2})^{\dagger}\hat{H}R_i(\frac{\pi}{2})\vert \psi \rangle-\langle \psi \vert R_i(-\frac{\pi}{2})^{\dagger}\hat{H}R_i(-\frac{\pi}{2})^{\dagger}\vert \psi \rangle\right]=\frac{1}{2}(\langle\hat{H}(\phi+\frac{\pi}{2})\rangle-\langle\hat{H}(\phi-\frac{\pi}{2})\rangle).
$$


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="basics-of-gradient-descent-and-stochastic-gradient-descent">Basics of gradient descent and stochastic gradient descent </h2>

<p>In order to implement the above equations, we need to remind the
reader about basic elements of various optimization approaches. Our
main focus here will be various gradient descent approaches and quasi-Newton methods like Broyden's algorithm and variations thereof.
</p>

<p>This material is covered by the lectures from <a href="https://github.com/CompPhysics/ComputationalPhysics2/blob/gh-pages/doc/pub/week6/ipynb/week6.ipynb" target="_blank">FYS4411 on gradient optimization</a></p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="computing-quantum-gradients">Computing quantum gradients  </h2>

<p>Let us implement
efficient implementations of gradient methods to the derivatives of
the Hamiltonian expectation values.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #8B008B; font-weight: bold">from</span>  <span style="color: #008b45; text-decoration: underline">matplotlib</span> <span style="color: #8B008B; font-weight: bold">import</span> pyplot <span style="color: #8B008B; font-weight: bold">as</span> plt
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">scipy.optimize</span> <span style="color: #8B008B; font-weight: bold">import</span> minimize
dim = <span style="color: #B452CD">2</span>
Hamiltonian = np.zeros((dim,dim))
e0 = <span style="color: #B452CD">0.0</span>
e1 = <span style="color: #B452CD">4.0</span>
Xnondiag = <span style="color: #B452CD">0.20</span>
Xdiag = <span style="color: #B452CD">3.0</span>
Eigenvalue = np.zeros(dim)
<span style="color: #228B22"># setting up the Hamiltonian</span>
Hamiltonian[<span style="color: #B452CD">0</span>,<span style="color: #B452CD">0</span>] = Xdiag+e0
Hamiltonian[<span style="color: #B452CD">0</span>,<span style="color: #B452CD">1</span>] = Xnondiag
Hamiltonian[<span style="color: #B452CD">1</span>,<span style="color: #B452CD">0</span>] = Hamiltonian[<span style="color: #B452CD">0</span>,<span style="color: #B452CD">1</span>]
Hamiltonian[<span style="color: #B452CD">1</span>,<span style="color: #B452CD">1</span>] = e1-Xdiag
<span style="color: #228B22"># diagonalize and obtain eigenvalues, not necessarily sorted</span>
EigValues, EigVectors = np.linalg.eig(Hamiltonian)
permute = EigValues.argsort()
EigValues = EigValues[permute]
<span style="color: #228B22"># print only the lowest eigenvalue</span>
<span style="color: #658b00">print</span>(EigValues[<span style="color: #B452CD">0</span>])

<span style="color: #228B22"># Now rewrite it in terms of the identity matrix and the Pauli matrix X and Z</span>
X = np.array([[<span style="color: #B452CD">0</span>,<span style="color: #B452CD">1</span>],[<span style="color: #B452CD">1</span>,<span style="color: #B452CD">0</span>]])
Y = np.array([[<span style="color: #B452CD">0</span>,-<span style="color: #B452CD">1</span>j],[<span style="color: #B452CD">1</span>j,<span style="color: #B452CD">0</span>]])
Z = np.array([[<span style="color: #B452CD">1</span>,<span style="color: #B452CD">0</span>],[<span style="color: #B452CD">0</span>,-<span style="color: #B452CD">1</span>]])
<span style="color: #228B22"># identity matrix</span>
I = np.array([[<span style="color: #B452CD">1</span>,<span style="color: #B452CD">0</span>],[<span style="color: #B452CD">0</span>,<span style="color: #B452CD">1</span>]])

epsilon = (e0+e1)*<span style="color: #B452CD">0.5</span>; omega = (e0-e1)*<span style="color: #B452CD">0.5</span>
c = <span style="color: #B452CD">0.0</span>; omega_z=Xdiag; omega_x = Xnondiag
Hamiltonian = (epsilon+c)*I+(omega_z+omega)*Z+omega_x*X
EigValues, EigVectors = np.linalg.eig(Hamiltonian)
permute = EigValues.argsort()
EigValues = EigValues[permute]
<span style="color: #228B22"># print only the lowest eigenvalue</span>
<span style="color: #658b00">print</span>(EigValues[<span style="color: #B452CD">0</span>])

<span style="color: #228B22"># define the rotation matrices</span>

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">Rx</span>(theta):
    <span style="color: #8B008B; font-weight: bold">return</span> np.cos(theta*<span style="color: #B452CD">0.5</span>)*I-<span style="color: #B452CD">1</span>j*np.sin(theta*<span style="color: #B452CD">0.5</span>)*X
<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">Ry</span>(phi):
    <span style="color: #8B008B; font-weight: bold">return</span> np.cos(phi*<span style="color: #B452CD">0.5</span>)*I-<span style="color: #B452CD">1</span>j*np.sin(phi*<span style="color: #B452CD">0.5</span>)*Y

<span style="color: #228B22">#define basis states</span>
basis0 = np.array([<span style="color: #B452CD">1</span>,<span style="color: #B452CD">0</span>])
basis1 = np.array([<span style="color: #B452CD">0</span>,<span style="color: #B452CD">1</span>])

<span style="color: #228B22"># Computing the expectation value of the energy </span>
<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">Energy</span>(theta,phi):
    Basis = Ry(phi) @ Rx(theta) @ basis0
    energy = Basis.conj().T @ Hamiltonian @ Basis
    <span style="color: #8B008B; font-weight: bold">return</span> energy


<span style="color: #228B22"># Set up iteration using gradient descent method</span>
eta = <span style="color: #B452CD">0.1</span>
Niterations = <span style="color: #B452CD">100</span>
<span style="color: #228B22"># Random angles using uniform distribution</span>
theta = <span style="color: #B452CD">2</span>*np.pi*np.random.rand()
phi = <span style="color: #B452CD">2</span>*np.pi*np.random.rand()
pi2 = <span style="color: #B452CD">0.5</span>*np.pi
<span style="color: #8B008B; font-weight: bold">for</span> <span style="color: #658b00">iter</span> <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(Niterations):
    thetagradient = <span style="color: #B452CD">0.5</span>*(Energy(theta+pi2,phi)-Energy(theta-pi2,phi))
    phigradient = <span style="color: #B452CD">0.5</span>*(Energy(theta,phi+pi2)-Energy(theta,phi-pi2))
    theta -= eta*thetagradient
    phi -= eta*phigradient
<span style="color: #658b00">print</span>(Energy(theta,phi))
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="a-smarter-way-of-doing-this">A smarter way of doing this </h2>

<p>The above approach means that we are setting up several matrix-matrix
and matrix-vector multiplications. Although straight forward it is not
the most efficient way of doing this, in particular in case the
matrices become large (and sparse). But there are some more important
issues.
</p>

<p>In a physical realization of these systems we cannot just multiply the
state with the Hamiltonian. When performing a measurement we can only
measure in one particular direction. For the computational basis
states which we have, \( \vert 0\rangle \) and \( \vert 1\rangle \), we have
to measure along the bases of the Pauli matrices and reconstruct the
eigenvalues from these measurements.
</p>

<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="the-code-for-the-one-qubit-case-code-developed-by-august-gude-2023">The code for the one qubit case (code developed by August Gude, 2023) </h2>

<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">numpy</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">np</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">matplotlib.pyplot</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">plt</span>
<span style="color: #8B008B; font-weight: bold">import</span> <span style="color: #008b45; text-decoration: underline">seaborn</span> <span style="color: #8B008B; font-weight: bold">as</span> <span style="color: #008b45; text-decoration: underline">sns</span>; sns.set_theme(font_scale=<span style="color: #B452CD">1.5</span>)
<span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">tqdm</span> <span style="color: #8B008B; font-weight: bold">import</span> tqdm

sigma_x = np.array([[<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>], [<span style="color: #B452CD">1</span>, <span style="color: #B452CD">0</span>]])
sigma_y = np.array([[<span style="color: #B452CD">0</span>, -<span style="color: #B452CD">1</span>j], [<span style="color: #B452CD">1</span>j, <span style="color: #B452CD">0</span>]])
sigma_z = np.array([[<span style="color: #B452CD">1</span>, <span style="color: #B452CD">0</span>], [<span style="color: #B452CD">0</span>, -<span style="color: #B452CD">1</span>]])
I = np.eye(<span style="color: #B452CD">2</span>)

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">Hamiltonian</span>(lmb):
    E1 = <span style="color: #B452CD">0</span>
    E2 = <span style="color: #B452CD">4</span>
    V11 = <span style="color: #B452CD">3</span>
    V22 = -<span style="color: #B452CD">3</span>
    V12 = <span style="color: #B452CD">0.2</span>
    V21 = <span style="color: #B452CD">0.2</span>

    eps = (E1 + E2) / <span style="color: #B452CD">2</span>
    omega = (E1 - E2) / <span style="color: #B452CD">2</span>
    c = (V11 + V22) / <span style="color: #B452CD">2</span>
    omega_z = (V11 - V22) / <span style="color: #B452CD">2</span>
    omega_x = V12

    H0 = eps * I + omega * sigma_z
    H1 = c * I + omega_z * sigma_z + omega_x * sigma_x
    <span style="color: #8B008B; font-weight: bold">return</span> H0 + lmb * H1
    
lmbvalues_ana = np.arange(<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>, <span style="color: #B452CD">0.01</span>)
eigvals_ana = np.zeros((<span style="color: #658b00">len</span>(lmbvalues_ana), <span style="color: #B452CD">2</span>))
<span style="color: #8B008B; font-weight: bold">for</span> index, lmb <span style="color: #8B008B">in</span> <span style="color: #658b00">enumerate</span>(lmbvalues_ana):
    H = Hamiltonian(lmb)
    eigen, eigvecs = np.linalg.eig(H)
    permute = eigen.argsort()
    eigvals_ana[index] = eigen[permute]
    eigvecs = eigvecs[:,permute]


fig, axs = plt.subplots(<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>, figsize=(<span style="color: #B452CD">10</span>, <span style="color: #B452CD">10</span>))
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">2</span>):
    axs.plot(lmbvalues_ana, eigvals_ana[:,i], label=<span style="color: #CD5555">f&#39;$E_{</span>i+<span style="color: #B452CD">1</span><span style="color: #CD5555">}$&#39;</span>)
axs.set_xlabel(<span style="color: #CD5555">r&#39;$\lambda$&#39;</span>)
axs.set_ylabel(<span style="color: #CD5555">&#39;Energy&#39;</span>)
axs.legend()
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>This was the standard eigenvalue problem. Let us now switch to our own implementation of the VQE.</p>


<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">src.qc</span> <span style="color: #8B008B; font-weight: bold">import</span> *

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">prepare_state</span>(theta, phi, target = <span style="color: #8B008B; font-weight: bold">None</span>):
    I = np.eye(<span style="color: #B452CD">2</span>)
    sigma_x = np.array([[<span style="color: #B452CD">0</span>, <span style="color: #B452CD">1</span>], [<span style="color: #B452CD">1</span>, <span style="color: #B452CD">0</span>]])
    sigma_y = np.array([[<span style="color: #B452CD">0</span>, -<span style="color: #B452CD">1</span>j], [<span style="color: #B452CD">1</span>j, <span style="color: #B452CD">0</span>]])
    state = np.array([<span style="color: #B452CD">1</span>, <span style="color: #B452CD">0</span>])
    Rx = np.cos(theta/<span style="color: #B452CD">2</span>) * I - <span style="color: #B452CD">1</span>j * np.sin(theta/<span style="color: #B452CD">2</span>) * sigma_x
    Ry = np.cos(phi/<span style="color: #B452CD">2</span>) * I - <span style="color: #B452CD">1</span>j * np.sin(phi/<span style="color: #B452CD">2</span>) * sigma_y
    state = Ry @ Rx @ state
    <span style="color: #8B008B; font-weight: bold">if</span> target <span style="color: #8B008B">is</span> <span style="color: #8B008B">not</span> <span style="color: #8B008B; font-weight: bold">None</span>:
        state = target
    <span style="color: #8B008B; font-weight: bold">return</span> state

<span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">get_energy</span>(angles, lmb, number_shots, target = <span style="color: #8B008B; font-weight: bold">None</span>):
    theta, phi = angles[<span style="color: #B452CD">0</span>], angles[<span style="color: #B452CD">1</span>]
    <span style="color: #228B22"># print(f&#39;Theta = {theta}, Phi = {phi}&#39;)</span>
    E1 = <span style="color: #B452CD">0</span>; E2 = <span style="color: #B452CD">4</span>; V11 = <span style="color: #B452CD">3</span>; V22 = -<span style="color: #B452CD">3</span>; V12 = <span style="color: #B452CD">0.2</span>; V21 = <span style="color: #B452CD">0.2</span>

    eps = (E1 + E2) / <span style="color: #B452CD">2</span>; omega = (E1 - E2) / <span style="color: #B452CD">2</span>; c = (V11 + V22) / <span style="color: #B452CD">2</span>; omega_z = (V11 - V22) / <span style="color: #B452CD">2</span>; omega_x = V12

    init_state = prepare_state(theta, phi, target)
    qubit = One_qubit()
    qubit.set_state(init_state)
    measure_z = qubit.measure(number_shots)

    qubit.set_state(init_state)
    qubit.apply_hadamard()
    measure_x = qubit.measure(number_shots)
    
    <span style="color: #228B22"># expected value of Z = (number of 0 measurements - number of 1 measurements)/ number of shots</span>
    <span style="color: #228B22"># number of 1 measurements = sum(measure_z)</span>
    exp_val_z = (omega + lmb*omega_z)*(number_shots - <span style="color: #B452CD">2</span>*np.sum(measure_z)) / number_shots
    exp_val_x = lmb*omega_x*(number_shots - <span style="color: #B452CD">2</span>*np.sum(measure_x)) / number_shots
    exp_val_i = (eps + c*lmb) 
    exp_val = (exp_val_z + exp_val_x + exp_val_i)
    <span style="color: #8B008B; font-weight: bold">return</span> exp_val 
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #8B008B; font-weight: bold">def</span> <span style="color: #008b45">minimize_energy</span>(lmb, number_shots, angles_0, learning_rate, max_epochs):
    <span style="color: #228B22"># angles = np.random.uniform(low = 0, high = np.pi, size = 2)</span>
    angles = angles_0 <span style="color: #228B22">#lmb*np.array([np.pi, np.pi])</span>
    epoch = <span style="color: #B452CD">0</span>
    delta_energy = <span style="color: #B452CD">1</span>
    energy = get_energy(angles, lmb, number_shots)
    <span style="color: #8B008B; font-weight: bold">while</span> (epoch &lt; max_epochs) <span style="color: #8B008B">and</span> (delta_energy &gt; <span style="color: #B452CD">1e-4</span>):
        grad = np.zeros_like(angles)
        <span style="color: #8B008B; font-weight: bold">for</span> idx <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(angles.shape[<span style="color: #B452CD">0</span>]):
            angles_temp = angles.copy()
            angles_temp[idx] += np.pi/<span style="color: #B452CD">2</span> 
            E_plus = get_energy(angles_temp, lmb, number_shots)
            angles_temp[idx] -= np.pi 
            E_minus = get_energy(angles_temp, lmb, number_shots)
            grad[idx] = (E_plus - E_minus)/<span style="color: #B452CD">2</span> 
        angles -= learning_rate*grad 
        new_energy = get_energy(angles, lmb, number_shots)
        delta_energy = np.abs(new_energy - energy)
        energy = new_energy
        epoch += <span style="color: #B452CD">1</span>
    <span style="color: #8B008B; font-weight: bold">return</span> angles, epoch, (epoch &lt; max_epochs), energy, delta_energy
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;">number_shots_search = <span style="color: #B452CD">10_000</span>
number_shots = <span style="color: #B452CD">10_000</span>
learning_rate = <span style="color: #B452CD">0.3</span>
max_epochs = <span style="color: #B452CD">400</span>
lmbvalues = np.linspace(<span style="color: #B452CD">0.0</span>, <span style="color: #B452CD">1.0</span>, <span style="color: #B452CD">30</span>)
min_energy = np.zeros(<span style="color: #658b00">len</span>(lmbvalues))
epochs = np.zeros(<span style="color: #658b00">len</span>(lmbvalues))
<span style="color: #8B008B; font-weight: bold">for</span> index, lmb <span style="color: #8B008B">in</span> <span style="color: #658b00">enumerate</span>(tqdm(lmbvalues)):
    memory = <span style="color: #B452CD">0</span>
    angles_0 = np.random.uniform(low = <span style="color: #B452CD">0</span>, high = np.pi, size = <span style="color: #B452CD">2</span>)
    angles, epochs[index], converged, energy, delta_energy = minimize_energy(lmb, number_shots_search, angles_0, learning_rate, max_epochs)
    <span style="color: #8B008B; font-weight: bold">if</span> epochs[index] &lt; (epochs[index-<span style="color: #B452CD">1</span>] - <span style="color: #B452CD">5</span>):
        angles_0 = np.random.uniform(low = <span style="color: #B452CD">0</span>, high = np.pi, size = <span style="color: #B452CD">2</span>)
        angles, epochs[index], converged, energy, delta_energy = minimize_energy(lmb, number_shots_search, angles_0, learning_rate, max_epochs)
    min_energy[index] = get_energy(angles, lmb, number_shots)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;"><span style="color: #8B008B; font-weight: bold">from</span> <span style="color: #008b45; text-decoration: underline">scipy.optimize</span> <span style="color: #8B008B; font-weight: bold">import</span> minimize
number_shots = <span style="color: #B452CD">10_000</span>
lmbvalues_scipy = np.linspace(<span style="color: #B452CD">0.0</span>, <span style="color: #B452CD">1.0</span>, <span style="color: #B452CD">50</span>)
min_energy_scipy = np.zeros(<span style="color: #658b00">len</span>(lmbvalues_scipy))
<span style="color: #8B008B; font-weight: bold">for</span> index, lmb <span style="color: #8B008B">in</span> <span style="color: #658b00">enumerate</span>(tqdm(lmbvalues_scipy)):
    angles_start = np.random.uniform(low = <span style="color: #B452CD">0</span>, high = np.pi, size = <span style="color: #B452CD">4</span>)
    res = minimize(get_energy, angles_start, args = (lmb, number_shots), method = <span style="color: #CD5555">&#39;Powell&#39;</span>, options = {<span style="color: #CD5555">&#39;maxiter&#39;</span>: <span style="color: #B452CD">1000</span>}, tol = <span style="color: #B452CD">1e-5</span>)
    min_energy_scipy[index] = res.fun
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
<!-- code=python (!bc pycod) typeset with pygments style "perldoc" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #eeeedd">
  <pre style="line-height: 125%;">fig, axs = plt.subplots(<span style="color: #B452CD">1</span>, <span style="color: #B452CD">1</span>, figsize=(<span style="color: #B452CD">10</span>, <span style="color: #B452CD">10</span>))
<span style="color: #8B008B; font-weight: bold">for</span> i <span style="color: #8B008B">in</span> <span style="color: #658b00">range</span>(<span style="color: #B452CD">2</span>):
    axs.plot(lmbvalues_ana, eigvals_ana[:,i], label=<span style="color: #CD5555">f&#39;$E_{</span>i+<span style="color: #B452CD">1</span><span style="color: #CD5555">}$&#39;</span>, color = <span style="color: #CD5555">&#39;#4c72b0&#39;</span>)
axs.scatter(lmbvalues, min_energy, label = <span style="color: #CD5555">&#39;VQE eigenvalues&#39;</span>, color = <span style="color: #CD5555">&#39;#dd8452&#39;</span>)
axs.scatter(lmbvalues_scipy, min_energy_scipy, label = <span style="color: #CD5555">&#39;VQE Scipy&#39;</span>, color = <span style="color: #CD5555">&#39;#55a868&#39;</span>)
axs.set_xlabel(<span style="color: #CD5555">r&#39;$\lambda$&#39;</span>)
axs.set_ylabel(<span style="color: #CD5555">&#39;Energy&#39;</span>)
plt.legend()
plt.show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split --><br><br><br><br><br><br><br><br><br><br>
<h2 id="plans-for-next-week">Plans for next week </h2>
<div class="alert alert-block alert-block alert-text-normal">
<b></b>
<p>
<ol>
<li> Introducing the Lipkin model</li>
<li> Solving problems with more than one qubit and discussion of project 1</li>
</ol>
</div>

<!-- ------------------- end of main content --------------- -->
<center style="font-size:80%">
<!-- copyright --> &copy; 1999-2024, Morten Hjorth-Jensen. Released under CC Attribution-NonCommercial 4.0 license
</center>
</body>
</html>

