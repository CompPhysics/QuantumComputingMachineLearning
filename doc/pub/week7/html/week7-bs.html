<!--
HTML file automatically generated from DocOnce source
(https://github.com/doconce/doconce/)
doconce format html week7.do.txt --html_style=bootstrap --pygments_html_style=default --html_admon=bootstrap_panel --html_output=week7-bs --no_mako
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/doconce/doconce/" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="February 26-March, 2024: Quantum Computing, Quantum Machine Learning and Quantum Information Theories">
<title>February 26-March, 2024: Quantum Computing, Quantum Machine Learning and Quantum Information Theories</title>
<!-- Bootstrap style: bootstrap -->
<!-- doconce format html week7.do.txt --html_style=bootstrap --pygments_html_style=default --html_admon=bootstrap_panel --html_output=week7-bs --no_mako -->
<link href="https://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="https://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->
<style type="text/css">
/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}
/* Adds an invisible element before each target to offset for the navigation
   bar */
.anchor::before {
  content:"";
  display:block;
  height:50px;      /* fixed header height for style bootstrap */
  margin:-50px 0 0; /* negative fixed header height */
}
</style>
</head>

<!-- tocinfo
{'highest level': 2,
 'sections': [('Plans for the week of February 26-March 1',
               2,
               None,
               'plans-for-the-week-of-february-26-march-1'),
              ('Reminder on technicalities',
               2,
               None,
               'reminder-on-technicalities'),
              ('Rotations', 2, None, 'rotations'),
              ('Rayleigh-Ritz variational principle',
               2,
               None,
               'rayleigh-ritz-variational-principle'),
              ('The ansatz', 2, None, 'the-ansatz'),
              ('Rotations again', 2, None, 'rotations-again'),
              ('Measurements and more', 2, None, 'measurements-and-more'),
              ('Collecting data', 2, None, 'collecting-data'),
              ('The VQE algoritm', 2, None, 'the-vqe-algoritm'),
              ('VQE overview', 2, None, 'vqe-overview'),
              ('VQE and efficient computations of gradients',
               2,
               None,
               'vqe-and-efficient-computations-of-gradients'),
              ('Symmetric matrix', 2, None, 'symmetric-matrix'),
              ('Non-interacting solution', 2, None, 'non-interacting-solution'),
              ('Rewriting with Pauli matrices',
               2,
               None,
               'rewriting-with-pauli-matrices'),
              ('Selecting parameters', 2, None, 'selecting-parameters'),
              ('Setting up the matrix', 2, None, 'setting-up-the-matrix'),
              ('Implementing the VQE', 2, None, 'implementing-the-vqe'),
              ('Multiple ansatzes', 2, None, 'multiple-ansatzes'),
              ('Rotations again', 2, None, 'rotations-again'),
              ('Simple code', 2, None, 'simple-code'),
              ('Gradient descent and calculations of gradients',
               2,
               None,
               'gradient-descent-and-calculations-of-gradients'),
              ('Setting up gradients', 2, None, 'setting-up-gradients'),
              ('Derivatives', 2, None, 'derivatives'),
              ('Derivatives of the expectation value of the Hamiltonian',
               2,
               None,
               'derivatives-of-the-expectation-value-of-the-hamiltonian'),
              ('Two addtional expectation values',
               2,
               None,
               'two-addtional-expectation-values'),
              ('Rotations again and again',
               2,
               None,
               'rotations-again-and-again'),
              ('Bloch sphere math', 2, None, 'bloch-sphere-math'),
              ('Derivatives', 2, None, 'derivatives'),
              ('Rewriting', 2, None, 'rewriting'),
              ('Final manipulations', 2, None, 'final-manipulations'),
              ('The expressions to implement',
               2,
               None,
               'the-expressions-to-implement'),
              ('Final expression', 2, None, 'final-expression'),
              ('Basics of gradient descent and stochastic gradient descent',
               2,
               None,
               'basics-of-gradient-descent-and-stochastic-gradient-descent'),
              ('Computing quantum gradients',
               2,
               None,
               'computing-quantum-gradients'),
              ('A smarter way of doing this',
               2,
               None,
               'a-smarter-way-of-doing-this'),
              ('Using properties of Pauli matrices',
               2,
               None,
               'using-properties-of-pauli-matrices'),
              ('Pauli $X$ reminder', 2, None, 'pauli-x-reminder'),
              ('Rewriting the Pauli $X$ matrix',
               2,
               None,
               'rewriting-the-pauli-x-matrix'),
              ('The Pauli $Y$ matrix', 2, None, 'the-pauli-y-matrix'),
              ('The code for the one qubit case (code developed by August '
               'Gude, 2023)',
               2,
               None,
               'the-code-for-the-one-qubit-case-code-developed-by-august-gude-2023'),
              ('Switching to Qiskit', 2, None, 'switching-to-qiskit')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="week7-bs.html">February 26-March, 2024: Quantum Computing, Quantum Machine Learning and Quantum Information Theories</a>
  </div>
  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="#plans-for-the-week-of-february-26-march-1" style="font-size: 80%;">Plans for the week of February 26-March 1</a></li>
     <!-- navigation toc: --> <li><a href="#reminder-on-technicalities" style="font-size: 80%;">Reminder on technicalities</a></li>
     <!-- navigation toc: --> <li><a href="#rotations" style="font-size: 80%;">Rotations</a></li>
     <!-- navigation toc: --> <li><a href="#rayleigh-ritz-variational-principle" style="font-size: 80%;">Rayleigh-Ritz variational principle</a></li>
     <!-- navigation toc: --> <li><a href="#the-ansatz" style="font-size: 80%;">The ansatz</a></li>
     <!-- navigation toc: --> <li><a href="#rotations-again" style="font-size: 80%;">Rotations again</a></li>
     <!-- navigation toc: --> <li><a href="#measurements-and-more" style="font-size: 80%;">Measurements and more</a></li>
     <!-- navigation toc: --> <li><a href="#collecting-data" style="font-size: 80%;">Collecting data</a></li>
     <!-- navigation toc: --> <li><a href="#the-vqe-algoritm" style="font-size: 80%;">The VQE algoritm</a></li>
     <!-- navigation toc: --> <li><a href="#vqe-overview" style="font-size: 80%;">VQE overview</a></li>
     <!-- navigation toc: --> <li><a href="#vqe-and-efficient-computations-of-gradients" style="font-size: 80%;">VQE and efficient computations of gradients</a></li>
     <!-- navigation toc: --> <li><a href="#symmetric-matrix" style="font-size: 80%;">Symmetric matrix</a></li>
     <!-- navigation toc: --> <li><a href="#non-interacting-solution" style="font-size: 80%;">Non-interacting solution</a></li>
     <!-- navigation toc: --> <li><a href="#rewriting-with-pauli-matrices" style="font-size: 80%;">Rewriting with Pauli matrices</a></li>
     <!-- navigation toc: --> <li><a href="#selecting-parameters" style="font-size: 80%;">Selecting parameters</a></li>
     <!-- navigation toc: --> <li><a href="#setting-up-the-matrix" style="font-size: 80%;">Setting up the matrix</a></li>
     <!-- navigation toc: --> <li><a href="#implementing-the-vqe" style="font-size: 80%;">Implementing the VQE</a></li>
     <!-- navigation toc: --> <li><a href="#multiple-ansatzes" style="font-size: 80%;">Multiple ansatzes</a></li>
     <!-- navigation toc: --> <li><a href="#rotations-again" style="font-size: 80%;">Rotations again</a></li>
     <!-- navigation toc: --> <li><a href="#simple-code" style="font-size: 80%;">Simple code</a></li>
     <!-- navigation toc: --> <li><a href="#gradient-descent-and-calculations-of-gradients" style="font-size: 80%;">Gradient descent and calculations of gradients</a></li>
     <!-- navigation toc: --> <li><a href="#setting-up-gradients" style="font-size: 80%;">Setting up gradients</a></li>
     <!-- navigation toc: --> <li><a href="#derivatives" style="font-size: 80%;">Derivatives</a></li>
     <!-- navigation toc: --> <li><a href="#derivatives-of-the-expectation-value-of-the-hamiltonian" style="font-size: 80%;">Derivatives of the expectation value of the Hamiltonian</a></li>
     <!-- navigation toc: --> <li><a href="#two-addtional-expectation-values" style="font-size: 80%;">Two addtional expectation values</a></li>
     <!-- navigation toc: --> <li><a href="#rotations-again-and-again" style="font-size: 80%;">Rotations again and again</a></li>
     <!-- navigation toc: --> <li><a href="#bloch-sphere-math" style="font-size: 80%;">Bloch sphere math</a></li>
     <!-- navigation toc: --> <li><a href="#derivatives" style="font-size: 80%;">Derivatives</a></li>
     <!-- navigation toc: --> <li><a href="#rewriting" style="font-size: 80%;">Rewriting</a></li>
     <!-- navigation toc: --> <li><a href="#final-manipulations" style="font-size: 80%;">Final manipulations</a></li>
     <!-- navigation toc: --> <li><a href="#the-expressions-to-implement" style="font-size: 80%;">The expressions to implement</a></li>
     <!-- navigation toc: --> <li><a href="#final-expression" style="font-size: 80%;">Final expression</a></li>
     <!-- navigation toc: --> <li><a href="#basics-of-gradient-descent-and-stochastic-gradient-descent" style="font-size: 80%;">Basics of gradient descent and stochastic gradient descent</a></li>
     <!-- navigation toc: --> <li><a href="#computing-quantum-gradients" style="font-size: 80%;">Computing quantum gradients</a></li>
     <!-- navigation toc: --> <li><a href="#a-smarter-way-of-doing-this" style="font-size: 80%;">A smarter way of doing this</a></li>
     <!-- navigation toc: --> <li><a href="#using-properties-of-pauli-matrices" style="font-size: 80%;">Using properties of Pauli matrices</a></li>
     <!-- navigation toc: --> <li><a href="#pauli-x-reminder" style="font-size: 80%;">Pauli \( X \) reminder</a></li>
     <!-- navigation toc: --> <li><a href="#rewriting-the-pauli-x-matrix" style="font-size: 80%;">Rewriting the Pauli \( X \) matrix</a></li>
     <!-- navigation toc: --> <li><a href="#the-pauli-y-matrix" style="font-size: 80%;">The Pauli \( Y \) matrix</a></li>
     <!-- navigation toc: --> <li><a href="#the-code-for-the-one-qubit-case-code-developed-by-august-gude-2023" style="font-size: 80%;">The code for the one qubit case (code developed by August Gude, 2023)</a></li>
     <!-- navigation toc: --> <li><a href="#switching-to-qiskit" style="font-size: 80%;">Switching to Qiskit</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->
<div class="container">
<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->
<!-- ------------------- main content ---------------------- -->
<div class="jumbotron">
<center>
<h1>February 26-March, 2024: Quantum Computing, Quantum Machine Learning and Quantum Information Theories</h1>
</center>  <!-- document title -->

<!-- author(s): Morten Hjorth-Jensen -->
<center>
<b>Morten Hjorth-Jensen</b> [1, 2]
</center>
<!-- institution(s) -->
<center>
[1] <b>Department of Physics, University of Oslo</b>
</center>
<center>
[2] <b>Department of Physics and Astronomy and Facility for Rare Isotope Beams, Michigan State University</b>
</center>
<br>
<center>
<h4>February 28</h4>
</center> <!-- date -->
<br>

<!-- potential-jumbotron-button -->
</div> <!-- end jumbotron -->

<!-- !split -->
<h2 id="plans-for-the-week-of-february-26-march-1" class="anchor">Plans for the week of February 26-March 1 </h2>

<div class="panel panel-default">
<div class="panel-body">
<!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
<ol>
 <li> Reminder on basics of the VQE method and how to perform measurements for the simpler one- and two-qubit Hamiltonians</li>
 <li> Simulating efficiently Hamiltonians on quantum computers with the VQE method and gradient descent to optimize the state function ansatz</li>
 <li> Introducing the Lipkin model</li>
 <li> <a href="https://www.sciencedirect.com/science/article/pii/S0370157322003118?via%3Dihub" target="_self">Reading suggestion, VQE review article</a></li>
</ol>
</div>
</div>


<!-- !split -->
<h2 id="reminder-on-technicalities" class="anchor">Reminder on technicalities </h2>
<p>The most important operators are the Pauli matrices, often referred to the \( X,Y \) and \( Z \) gates</p>
$$
\begin{align}
    X = \begin{bmatrix}
        0 & 1 
\label{_auto1}\\
        1 & 0
    \end{bmatrix}, Y = \begin{bmatrix}
        0 & -i 
\label{_auto2}\\
        i & 0
    \end{bmatrix}, Z = \begin{bmatrix}
        1 & 0 
\label{_auto3}\\
        0 & -1
    \end{bmatrix}.
\label{_auto4}
\end{align}
$$

<p>Through the tensor product we can compose operators acting on multiple qubits.</p>

<!-- !split -->
<h2 id="rotations" class="anchor">Rotations </h2>

<p>Another important set of gates are the \textit{rotation operators} \( R_x, R_y \) and \( R_z \). By application to a qbit, we can reach any point on the Bloch sphere by usage of all three once. They are expressed as</p>
$$
\begin{align*}
    \begin{split}
        R_x(\theta) &= \exp{-iX\theta/2} = \begin{bmatrix}
            \cos(\theta/2) & -i\sin(\theta/2) \\
            -i\sin(\theta/2) & \cos(\theta/2)
        \end{bmatrix}, \\
        R_y(\theta) &= \exp{-iY\theta/2} = \begin{bmatrix}
            \cos(\theta/2) & -\sin(\theta/2) \\
            -\sin(\theta/2) & \cos(\theta/2)
        \end{bmatrix}, \\
        R_z(\theta) &= \exp{-iZ\theta/2} = \begin{bmatrix}
            \exp{-i\theta/2} & 0 \\
            0 & \exp{i\theta/2}
        \end{bmatrix}
    \end{split}
\end{align*}
$$

<p>with all having a period of \( 4\pi \).</p>

<!-- !split -->
<h2 id="rayleigh-ritz-variational-principle" class="anchor">Rayleigh-Ritz variational principle </h2>

<p>The Rayleigh-Ritz variational principle states that for a given
Hamiltonian \( H \), the expectation value of a trial state or
just ansatz \( \vert x \rangle \) puts a lower bound on the ground state
energy \( E_0 \).
</p>

$$
    \frac{\langle \psi \vert H\vert \psi \rangle}{\langle \psi \vert \psi \rangle} \geq E_0.
$$


<!-- !split -->
<h2 id="the-ansatz" class="anchor">The ansatz </h2>

<p>The ansatz is typically chosen to be a parameterized superposition of
basis states that can be varied to improve the energy estimate,
\( \vert \psi\rangle equiv \vert psi(\boldsymbol{\theta})\rangle \) where
\( \boldsymbol{\theta} = (\theta_1, \ldots, \theta_M) \) are the \( M \)
optimization parameters.
</p>

<!-- !split -->
<h2 id="rotations-again" class="anchor">Rotations again </h2>

<p>To have any flexibility in the
ansatz \( \vert \psi\rangle \), we need to allow for parametrization. The most
common approach is the so-called \( R_y \) ansatz, where we apply chained
operations of rotating around the \( y \)-axis by \( \boldsymbol{\theta} =
(\theta_1,\ldots,\theta_Q) \) of the Bloch sphere and CNOT operations.
</p>

<p>Applications of \( y \) rotations
specifically ensures that our coefficients always remain real, which
often is satisfactory when dealing with many-body systems. 
</p>

<!-- !split -->
<h2 id="measurements-and-more" class="anchor">Measurements and more </h2>

<p>After the ansatz has been constructed, the Hamiltonian must
be applied. As discussed, the Hamiltonian must be written in terms of
Pauli strings.
</p>

<p>To obtain the expectation value
of the ground state energy, one can measure the expectation value of
each Pauli string, 
</p>
$$
\begin{align*}
    E(\boldsymbol{\theta}) = \sum_i w_i\langle \psi(\boldsymbol{\theta})\vert P_i \vert \psi(\boldsymbol{\theta})\rangle \equiv \sum_i w_i f_i,
\end{align*}
$$

<p>where \( f_i \) is the expectation value of the Pauli string \( i \).</p>

<!-- !split -->
<h2 id="collecting-data" class="anchor">Collecting data </h2>

<p>This is estimated statistically by considering measurements in the
appropriate basis of the operator in the Pauli string.
</p>

<p>With \( N_0 \) and \( N_1 \) as the number of \( 0 \) and \( 1 \) measurements respectively, we can estimate \( f_i \) since </p>
$$
\begin{align*}
    f_i = \lim_{N \to \infty} \frac{N_0 - N_1}{N},
\end{align*}
$$

<p>where \( N \) as the number of shots (measurements).</p>

<p>Each Pauli string requires it own circuit, where multiple measurements
of each string is required. Adding the results together with the
corresponding weights, the ground state energy can be estimated. To
optimize with respect to  \( \boldsymbol{\theta} \), a classical optimizer is often
applied.
</p>

<!-- !split -->
<h2 id="the-vqe-algoritm" class="anchor">The VQE algoritm </h2>

<p>The VQE algorithm consists of several steps, partially done on a classical computer:</p>
<ol>
<li> A parameterized ansatz for the quantum state is implemented on a quantum computer.</li>
<li> The ansatz is measured in a given measurement basis.</li>
<li> Postprocessing on a classical computer converts the measurement outcomes to an expectation value.</li>
<li> Classical minimization algorithms are used to up- date the variational parameters.</li>
</ol>
<p>The updated variational parameters are then sent back to the quantum
computer, and the process is repeated until the optimal variational
parameters are found. 
</p>

<!-- !split -->
<h2 id="vqe-overview" class="anchor">VQE overview </h2>

<br/><br/>
<center>
<p><img src="figures/vqe.png" width="700" align="bottom"></p>
</center>
<br/><br/>

<!-- !split -->
<h2 id="vqe-and-efficient-computations-of-gradients" class="anchor">VQE and efficient computations of gradients  </h2>

<p>We start with a reminder on the VQE method with applications to the
one-qubit system discussed last week.
</p>

<p>Here we revisit the one-qubit system and develop a VQE
code for studying this system using gradient descent as a method to
optimize the variational ansatz. 
</p>

<p>We start with a simple \( 2\times 2 \) Hamiltonian matrix expressed in
terms of Pauli \( X \) and \( Z \) matrices, as discussed in the project text.
</p>

<!-- !split -->
<h2 id="symmetric-matrix" class="anchor">Symmetric matrix </h2>

<p>We define a  symmetric matrix  \( H\in {\mathbb{R}}^{2\times 2} \)</p>
$$
H = \begin{bmatrix} H_{11} & H_{12} \\ H_{21} & H_{22}
\end{bmatrix},
$$

<p>We  let \( H = H_0 + H_I \), where</p>
$$
H_0= \begin{bmatrix} E_1 & 0 \\ 0 & E_2\end{bmatrix},
$$

<p>is a diagonal matrix. Similarly,</p>
$$
H_I= \begin{bmatrix} V_{11} & V_{12} \\ V_{21} & V_{22}\end{bmatrix},
$$

<p>where \( V_{ij} \) represent various interaction matrix elements.</p>

<!-- !split -->
<h2 id="non-interacting-solution" class="anchor">Non-interacting solution </h2>

<p>We can view \( H_0 \) as the non-interacting solution</p>
$$
\begin{equation}
       H_0\vert 0 \rangle =E_1\vert 0 \rangle,
\label{_auto5}
\end{equation}
$$

<p>and</p>
$$
\begin{equation}
       H_0\vert 1\rangle =E_2\vert 1\rangle,
\label{_auto6}
\end{equation}
$$

<p>where we have defined the orthogonal computational one-qubit basis states \( \vert 0\rangle \) and \( \vert 1\rangle \).</p>

<!-- !split -->
<h2 id="rewriting-with-pauli-matrices" class="anchor">Rewriting with Pauli matrices </h2>
<p>We rewrite \( H \) (and \( H_0 \) and \( H_I \))  via Pauli matrices</p>
$$
H_0 = \mathcal{E} I + \Omega \sigma_z, \quad \mathcal{E} = \frac{E_1
  + E_2}{2}, \; \Omega = \frac{E_1-E_2}{2},
$$

<p>and</p>
$$
H_I = c \boldsymbol{I} +\omega_z\sigma_z + \omega_x\sigma_x,
$$

<p>with \( c = (V_{11}+V_{22})/2 \), \( \omega_z = (V_{11}-V_{22})/2 \) and \( \omega_x = V_{12}=V_{21} \).
We let our Hamiltonian depend linearly on a strength parameter \( \lambda \)
</p>

$$
H=H_0+\lambda H_\mathrm{I},
$$

<p>with \( \lambda \in [0,1] \), where the limits \( \lambda=0 \) and \( \lambda=1 \)
represent the non-interacting (or unperturbed) and fully interacting
system, respectively.
</p>

<!-- !split -->
<h2 id="selecting-parameters" class="anchor">Selecting parameters </h2>

<p>The model is an eigenvalue problem with only
two available states.
</p>

<p>Here we set the parameters \( E_1=0 \),
\( E_2=4 \), \( V_{11}=-V_{22}=3 \) and \( V_{12}=V_{21}=0.2 \).
</p>

<p>The non-interacting solutions represent our computational basis.
Pertinent to our choice of parameters, is that at \( \lambda\geq 2/3 \),
the lowest eigenstate is dominated by \( \vert 1\rangle \) while the upper
is \( \vert 0 \rangle \). At \( \lambda=1 \) the \( \vert 0 \rangle \) mixing of
the lowest eigenvalue is \( 1\% \) while for \( \lambda\leq 2/3 \) we have a
\( \vert 0 \rangle \) component of more than \( 90\% \).  The character of the
eigenvectors has therefore been interchanged when passing \( z=2/3 \). The
value of the parameter \( V_{12} \) represents the strength of the coupling
between the two states.
</p>

<!-- !split -->
<h2 id="setting-up-the-matrix" class="anchor">Setting up the matrix </h2>
<p>This part is best seen using the jupyter-notebook</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">from</span>  <span style="color: #0000FF; font-weight: bold">matplotlib</span> <span style="color: #008000; font-weight: bold">import</span> pyplot <span style="color: #008000; font-weight: bold">as</span> plt
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
dim <span style="color: #666666">=</span> <span style="color: #666666">2</span>
Hamiltonian <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((dim,dim))
e0 <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
e1 <span style="color: #666666">=</span> <span style="color: #666666">4.0</span>
Xnondiag <span style="color: #666666">=</span> <span style="color: #666666">0.20</span>
Xdiag <span style="color: #666666">=</span> <span style="color: #666666">3.0</span>
Eigenvalue <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(dim)
<span style="color: #408080; font-style: italic"># setting up the Hamiltonian</span>
Hamiltonian[<span style="color: #666666">0</span>,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> Xdiag<span style="color: #666666">+</span>e0
Hamiltonian[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>] <span style="color: #666666">=</span> Xnondiag
Hamiltonian[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> Hamiltonian[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>]
Hamiltonian[<span style="color: #666666">1</span>,<span style="color: #666666">1</span>] <span style="color: #666666">=</span> e1<span style="color: #666666">-</span>Xdiag
<span style="color: #408080; font-style: italic"># diagonalize and obtain eigenvalues, not necessarily sorted</span>
EigValues, EigVectors <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>eig(Hamiltonian)
permute <span style="color: #666666">=</span> EigValues<span style="color: #666666">.</span>argsort()
EigValues <span style="color: #666666">=</span> EigValues[permute]
<span style="color: #408080; font-style: italic"># print only the lowest eigenvalue</span>
<span style="color: #008000">print</span>(EigValues[<span style="color: #666666">0</span>])
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Now rewrite it in terms of the identity matrix and the Pauli matrix X and Z</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #408080; font-style: italic"># Now rewrite it in terms of the identity matrix and the Pauli matrix X and Z</span>
X <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>],[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>]])
Y <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([[<span style="color: #666666">0</span>,<span style="color: #666666">-1</span>j],[<span style="color: #666666">1</span>j,<span style="color: #666666">0</span>]])
Z <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>],[<span style="color: #666666">0</span>,<span style="color: #666666">-1</span>]])
<span style="color: #408080; font-style: italic"># identity matrix</span>
I <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>],[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>]])

epsilon <span style="color: #666666">=</span> (e0<span style="color: #666666">+</span>e1)<span style="color: #666666">*0.5</span>; omega <span style="color: #666666">=</span> (e0<span style="color: #666666">-</span>e1)<span style="color: #666666">*0.5</span>
c <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>; omega_z<span style="color: #666666">=</span>Xdiag; omega_x <span style="color: #666666">=</span> Xnondiag
Hamiltonian <span style="color: #666666">=</span> (epsilon<span style="color: #666666">+</span>c)<span style="color: #666666">*</span>I<span style="color: #666666">+</span>(omega_z<span style="color: #666666">+</span>omega)<span style="color: #666666">*</span>Z<span style="color: #666666">+</span>omega_x<span style="color: #666666">*</span>X
EigValues, EigVectors <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>eig(Hamiltonian)
permute <span style="color: #666666">=</span> EigValues<span style="color: #666666">.</span>argsort()
EigValues <span style="color: #666666">=</span> EigValues[permute]
<span style="color: #408080; font-style: italic"># print only the lowest eigenvalue</span>
<span style="color: #008000">print</span>(EigValues[<span style="color: #666666">0</span>])
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split -->
<h2 id="implementing-the-vqe" class="anchor">Implementing the VQE </h2>

<p>For a one-qubit system we can reach every point on the Bloch sphere
(as discussed earlier) with a rotation about the \( x \)-axis and the
\( y \)-axis.
</p>

<p>We can express this mathematically through the following operations (see whiteboard for the drawing), giving us a new state \( \vert \psi\rangle \)</p>
$$
\vert\psi\rangle = R_y(\phi)R_x(\theta)\vert 0 \rangle.
$$


<!-- !split -->
<h2 id="multiple-ansatzes" class="anchor">Multiple ansatzes </h2>

<p>We can produce multiple ansatzes for the new state in terms of the
angles \( \theta \) and \( \phi \).  With these ansatzes we can in turn
calculate the expectation value of the above Hamiltonian, now
rewritten in terms of various Pauli matrices (and thereby gates), that is compute
</p>

$$
\langle \psi \vert (c+\mathcal{E})\boldsymbol{I} + (\Omega+\omega_z)\boldsymbol{\sigma}_z + \omega_x\boldsymbol{\sigma}_x\vert \psi \rangle.
$$


<!-- !split -->
<h2 id="rotations-again" class="anchor">Rotations again </h2>

<p>We can now set up a series of ansatzes for \( \vert \psi \rangle \) as
function of the angles \( \theta \) and \( \phi \) and find thereafter the
variational minimum using for example a gradient descent method.
</p>

<p>To do so, we need to remind ourselves about the mathematical expressions for
the rotational matrices/operators.
</p>

$$
R_x(\theta)=\cos{\frac{\theta}{2}}\boldsymbol{I}-\imath \sin{\frac{\theta}{2}}\boldsymbol{\sigma}_x,
$$

<p>and</p>

$$
R_y(\phi)=\cos{\frac{\phi}{2}}\boldsymbol{I}-\imath \sin{\frac{\phi}{2}}\boldsymbol{\sigma}_y.
$$


<!-- !split -->
<h2 id="simple-code" class="anchor">Simple code </h2>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #408080; font-style: italic"># define the rotation matrices</span>
<span style="color: #408080; font-style: italic"># Define angles theta and phi</span>
theta <span style="color: #666666">=</span> <span style="color: #666666">0.5*</span>np<span style="color: #666666">.</span>pi; phi <span style="color: #666666">=</span> <span style="color: #666666">0.2*</span>np<span style="color: #666666">.</span>pi
Rx <span style="color: #666666">=</span> np<span style="color: #666666">.</span>cos(theta<span style="color: #666666">*0.5</span>)<span style="color: #666666">*</span>I<span style="color: #666666">-1</span>j<span style="color: #666666">*</span>np<span style="color: #666666">.</span>sin(theta<span style="color: #666666">*0.5</span>)<span style="color: #666666">*</span>X
Ry <span style="color: #666666">=</span> np<span style="color: #666666">.</span>cos(phi<span style="color: #666666">*0.5</span>)<span style="color: #666666">*</span>I<span style="color: #666666">-1</span>j<span style="color: #666666">*</span>np<span style="color: #666666">.</span>sin(phi<span style="color: #666666">*0.5</span>)<span style="color: #666666">*</span>Y
<span style="color: #408080; font-style: italic">#define basis states</span>
basis0 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([<span style="color: #666666">1</span>,<span style="color: #666666">0</span>])
basis1 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([<span style="color: #666666">0</span>,<span style="color: #666666">1</span>])

NewBasis <span style="color: #666666">=</span> Ry <span style="color: #666666">@</span> Rx <span style="color: #666666">@</span> basis0
<span style="color: #008000">print</span>(NewBasis)
<span style="color: #408080; font-style: italic"># Compute the expectation value</span>
<span style="color: #408080; font-style: italic">#Note hermitian conjugation</span>
Energy <span style="color: #666666">=</span> NewBasis<span style="color: #666666">.</span>conj()<span style="color: #666666">.</span>T <span style="color: #666666">@</span> Hamiltonian <span style="color: #666666">@</span> NewBasis
<span style="color: #008000">print</span>(Energy)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Not an impressive results. We set up now a loop over many angles \( \theta \) and \( \phi \) and compute the energies</p>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #408080; font-style: italic"># define a number of angles</span>
n <span style="color: #666666">=</span> <span style="color: #666666">20</span>
angle <span style="color: #666666">=</span> np<span style="color: #666666">.</span>arange(<span style="color: #666666">0</span>,<span style="color: #666666">180</span>,<span style="color: #666666">10</span>)
n <span style="color: #666666">=</span> np<span style="color: #666666">.</span>size(angle)
ExpectationValues <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((n,n))
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span> (n):
    theta <span style="color: #666666">=</span> np<span style="color: #666666">.</span>pi<span style="color: #666666">*</span>angle[i]<span style="color: #666666">/180.0</span>
    Rx <span style="color: #666666">=</span> np<span style="color: #666666">.</span>cos(theta<span style="color: #666666">*0.5</span>)<span style="color: #666666">*</span>I<span style="color: #666666">-1</span>j<span style="color: #666666">*</span>np<span style="color: #666666">.</span>sin(theta<span style="color: #666666">*0.5</span>)<span style="color: #666666">*</span>X
    <span style="color: #008000; font-weight: bold">for</span> j <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span> (n):
        phi <span style="color: #666666">=</span> np<span style="color: #666666">.</span>pi<span style="color: #666666">*</span>angle[j]<span style="color: #666666">/180.0</span>
        Ry <span style="color: #666666">=</span> np<span style="color: #666666">.</span>cos(phi<span style="color: #666666">*0.5</span>)<span style="color: #666666">*</span>I<span style="color: #666666">-1</span>j<span style="color: #666666">*</span>np<span style="color: #666666">.</span>sin(phi<span style="color: #666666">*0.5</span>)<span style="color: #666666">*</span>Y
        NewBasis <span style="color: #666666">=</span> Ry <span style="color: #666666">@</span> Rx <span style="color: #666666">@</span> basis0
        Energy <span style="color: #666666">=</span> NewBasis<span style="color: #666666">.</span>conj()<span style="color: #666666">.</span>T <span style="color: #666666">@</span> Hamiltonian <span style="color: #666666">@</span> NewBasis
        Edifference<span style="color: #666666">=</span><span style="color: #008000">abs</span>(np<span style="color: #666666">.</span>real(EigValues[<span style="color: #666666">0</span>]<span style="color: #666666">-</span>Energy))
        ExpectationValues[i,j]<span style="color: #666666">=</span>Edifference

<span style="color: #008000">print</span>(np<span style="color: #666666">.</span>min(ExpectationValues))
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>Clearly, this is not the best way of proceeding. Rather, here we
could try to find the optimal values for the parameters \( \theta \) and
\( \phi \) through computation of their respective gradients and thereby
find the minimum as function of the optimal angles \( \hat{\theta} \) and
\( \hat{\phi} \).
</p>

<p>Let us now implement a classical gradient descent algorithm to the computation of the energies. 
We will follow closely  <a href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.99.032331" target="_self"><tt>https://journals.aps.org/pra/abstract/10.1103/PhysRevA.99.032331</tt></a> in order to calculate gradients of the Hamiltonian.
</p>

<!-- !split -->
<h2 id="gradient-descent-and-calculations-of-gradients" class="anchor">Gradient descent and calculations of gradients </h2>

<p>In order to optimize the VQE ansatz, we need to compute derivatives
with respect to the variational parameters.  Here we develop first a
simpler approach tailored to the one-qubit case. For this particular
case, we have defined an ansatz in terms of the Pauli rotation
matrices.
</p>

<!-- !split -->
<h2 id="setting-up-gradients" class="anchor">Setting up gradients </h2>

<p>These define an arbitrary one-qubit state on the Bloch
sphere through the expression
</p>

$$
\vert\psi\rangle = \vert \psi(\theta,\phi)\rangle =R_y(\phi)R_x(\theta)\vert 0 \rangle.
$$

<p>Each of these rotation matrices can be written in a more general form as</p>
$$
R_{i}(\gamma)=\exp{-(\imath\frac{\gamma}{2}\sigma_i)}=\cos{(\frac{\gamma}{2})}\boldsymbol{I}-\imath\sin{(\frac{\gamma}{2})}\boldsymbol{\sigma}_i,
$$

<p>where \( \sigma_i \) is one of the Pauli matrices \( \sigma_{x,y,z} \). </p>

<!-- !split -->
<h2 id="derivatives" class="anchor">Derivatives </h2>

<p>It is easy to see that the derivative with respect to \( \gamma \) is</p>
$$
\frac{\partial R_{i}(\gamma)}{\partial \gamma}=-\frac{\gamma}{2}\boldsymbol{\sigma}_i R_{i}(\gamma).
$$


<!-- !split -->
<h2 id="derivatives-of-the-expectation-value-of-the-hamiltonian" class="anchor">Derivatives of the expectation value of the Hamiltonian </h2>

<p>We can now calculate the derivative of the expectation value of the
Hamiltonian in terms of the angles \( \theta \) and \( \phi \). We have two
derivatives 
</p>
$$
\frac{\partial}{\partial \theta}\left[\langle \psi(\theta,\phi) \vert \boldsymbol{H}\vert \psi(\theta,\phi)\rangle\right]=\frac{\partial}{\partial \theta}\left[\langle\boldsymbol{H}(\theta,\phi)\rangle\right]=\langle \psi(\theta,\phi) \vert \boldsymbol{H}(-\frac{\imath}{2}\boldsymbol{\sigma}_x\vert \psi(\theta,\phi)\rangle+\hspace{0.1cm}\mathrm{h.c},
$$

<p>and</p>
$$
\frac{\partial }{\partial \phi}\left[\langle \psi(\theta,\phi) \vert \boldsymbol{H}\vert \psi(\theta,\phi)\rangle\right]=\frac{\partial}{\partial \phi}\left[\langle\boldsymbol{H}(\theta,\phi)\rangle\right]=\langle \psi(\theta,\phi) \vert \boldsymbol{H}(-\frac{\imath}{2}\boldsymbol{\sigma}_y\vert \psi(\theta,\phi)\rangle+\hspace{0.1cm}\mathrm{h.c}. 
$$


<!-- !split -->
<h2 id="two-addtional-expectation-values" class="anchor">Two addtional expectation values </h2>

<p>This means that we have to calculate two additional expectation values
in addition to the expectation value of the Hamiltonian itself.  If we
stay with an ansatz for the single qubit states given by the above
rotation operators, we can, following for example <a href="https://journals.aps.org/pra/abstract/10.1103/PhysRevA.99.032331" target="_self">the article by
Maria Schuld et
al</a>,
show that the derivative of the expectation value of the Hamiltonian
can be written as (we focus only on a given angle \( \phi \))
</p>

$$
\frac{\partial}{\partial \phi}\left[\langle\boldsymbol{H}(\phi)\rangle\right]=\frac{1}{2}\left[\langle\boldsymbol{H}(\phi+\frac{\pi}{2})\rangle-\langle\boldsymbol{H}(\phi-\frac{\pi}{2})\rangle\right].
$$


<!-- !split -->
<h2 id="rotations-again-and-again" class="anchor">Rotations again and again </h2>
<p>To see this, consider again the definition of the rotation operators.
We can write these operators as
</p>

$$
R_i(\phi)=\exp{-\imath(\phi \boldsymbol{\sigma}_i)},
$$

<p>with \( \boldsymbol{sigma}_i \), with \( \boldsymbol{\sigma}_i \) being any of the Pauli
matrices \( X \), \( Y \) and \( Z \). The latter can be generalized to other
unitary matrices as well.
The derivative with respect to \( \phi \) gives
</p>
$$
\frac{\partial R_i(\phi)}{\partial \phi}=-\frac{\imath}{2} \boldsymbol{\sigma}_i\exp{-\imath(\phi \boldsymbol{\sigma}_i)}=-\frac{\imath}{2} \boldsymbol{\sigma} R_i(\phi).
$$


<!-- !split -->
<h2 id="bloch-sphere-math" class="anchor">Bloch sphere math </h2>

<p>Our ansatz for a general one-qubit state on the Bloch sphere contains the product of a rotation around the \( x \)-axis and the \( y \)-axis. In the derivation here we focus only on one angle however. Our ansatz is then given by</p>

$$
\vert \psi \rangle = R_i(\phi)\vert 0 \rangle,
$$

<p>and the expectation value of our Hamiltonian is</p>

$$
\langle \psi \vert \hat{H}\vert \psi \rangle = \langle 0 \vert R_i(\phi)^{\dagger} \hat{H}R_i(\phi)\vert 0\rangle. 
$$


<!-- !split -->
<h2 id="derivatives" class="anchor">Derivatives </h2>

<p>Our derivative with respect to the angle \( \phi \) has a similar structure, that is</p>
$$
\frac{\partial }{\partial \phi}\left[\langle \psi(\theta,\phi) \vert \boldsymbol{H}\vert \psi(\theta,\phi)\rangle\right]=\langle \psi(\theta,\phi) \vert \boldsymbol{H}(-\frac{\imath}{2}\boldsymbol{\sigma}_y\vert \psi(\theta,\phi)\rangle+\hspace{0.1cm}\mathrm{h.c}. 
$$


<!-- !split -->
<h2 id="rewriting" class="anchor">Rewriting </h2>

<p>In order to rewrite the equation of the derivative,
the following relation is useful
</p>
$$
\langle \psi \vert \hat{A}^{\dagger}\hat{B}\hat{C}\vert \psi \rangle = \frac{1}{2}\left[
\langle \psi \vert (\hat{A}+\hat{C})^{\dagger}\hat{B}(\boldsymbol{A}+\hat{C})\vert \psi \rangle-\langle \psi \vert (\hat{A}-\hat{C})^{\dagger}\hat{B}(\boldsymbol{A}-\hat{C})\vert \psi \rangle\right],
$$

<p>where \( \hat{A} \), \( \hat{B} \) and \( \hat{C} \) are arbitrary hermitian
operators.
</p>

<!-- !split -->
<h2 id="final-manipulations" class="anchor">Final manipulations </h2>

<p>If we identify these operators as \( \hat{A}=\boldsymbol{I} \), with
\( \boldsymbol{I} \) being the unit operator, \( \hat{B}=\hat{H} \) our Hamiltonian,
and \( \hat{C}=-\imath \boldsymbol{\sigma}_i/2 \), we obtain the following
expression for the expectation value of the derivative (excluding the hermitian conjugate)
</p>

$$
\langle \psi \vert \boldsymbol{I}^{\dagger}\hat{H}(-\frac{\imath}{2}\boldsymbol{\sigma}_i\vert \psi \rangle = \frac{1}{2}\left[
\langle \psi \vert (\boldsymbol{I}-\frac{\imath}{2} \boldsymbol{\sigma}_i)^{\dagger}\hat{H}(\boldsymbol{I}-\frac{\imath}{2} \boldsymbol{\sigma}_i)\vert \psi \rangle-\langle \psi \vert (\boldsymbol{I}+\frac{\imath}{2} \boldsymbol{\sigma}_i)^{\dagger}\hat{H}(\boldsymbol{I}+\frac{\imath}{2} \boldsymbol{\sigma}_i)\vert \psi \rangle\right].
$$


<!-- !split -->
<h2 id="the-expressions-to-implement" class="anchor">The expressions to implement </h2>

<p>If we then use that the rotation matrices can be rewritten as</p>
$$
R_{i}(\phi)=\exp{-(\imath\frac{\phi}{2}\sigma_i)}=\cos{(\frac{\phi}{2})}\boldsymbol{I}-\imath\sin{(\frac{\phi}{2})}\boldsymbol{\sigma}_i,
$$

<p>we see that if we set the angle to \( \phi=\pi/2 \), we have </p>
$$
R_{i}(\frac{\pi}{2})=\cos{(\frac{\pi}{4})}\boldsymbol{I}-\imath\sin{(\frac{\pi}{4})}\boldsymbol{\sigma}_i=\frac{1}{\sqrt{2}}\left(\boldsymbol{I}-\frac{\imath}{2} \boldsymbol{\sigma}_i\right).
$$


<!-- !split -->
<h2 id="final-expression" class="anchor">Final expression </h2>

<p>This means that we can write</p>
$$
\langle \psi \vert \boldsymbol{I}^{\dagger}\hat{H}(-\frac{\imath}{2}\boldsymbol{\sigma}_i\vert \psi \rangle = \frac{1}{2}\left[
\langle \psi \vert R_i(\frac{\pi}{2})^{\dagger}\hat{H}R_i(\frac{\pi}{2})\vert \psi \rangle-\langle \psi \vert R_i(-\frac{\pi}{2})^{\dagger}\hat{H}R_i(-\frac{\pi}{2})^{\dagger}\vert \psi \rangle\right]=\frac{1}{2}(\langle\hat{H}(\phi+\frac{\pi}{2})\rangle-\langle\hat{H}(\phi-\frac{\pi}{2})\rangle).
$$


<!-- !split -->
<h2 id="basics-of-gradient-descent-and-stochastic-gradient-descent" class="anchor">Basics of gradient descent and stochastic gradient descent </h2>

<p>In order to implement the above equations, we need to remind the
reader about basic elements of various optimization approaches. Our
main focus here will be various gradient descent approaches and quasi-Newton methods like Broyden's algorithm and variations thereof.
</p>

<p>This material is covered by the lectures from <a href="https://github.com/CompPhysics/ComputationalPhysics2/blob/gh-pages/doc/pub/week6/ipynb/week6.ipynb" target="_self">FYS4411 on gradient optimization</a></p>

<!-- !split -->
<h2 id="computing-quantum-gradients" class="anchor">Computing quantum gradients  </h2>

<p>Let us implement
efficient implementations of gradient methods to the derivatives of
the Hamiltonian expectation values.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">from</span>  <span style="color: #0000FF; font-weight: bold">matplotlib</span> <span style="color: #008000; font-weight: bold">import</span> pyplot <span style="color: #008000; font-weight: bold">as</span> plt
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">scipy.optimize</span> <span style="color: #008000; font-weight: bold">import</span> minimize
dim <span style="color: #666666">=</span> <span style="color: #666666">2</span>
Hamiltonian <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((dim,dim))
e0 <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
e1 <span style="color: #666666">=</span> <span style="color: #666666">4.0</span>
Xnondiag <span style="color: #666666">=</span> <span style="color: #666666">0.20</span>
Xdiag <span style="color: #666666">=</span> <span style="color: #666666">3.0</span>
Eigenvalue <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(dim)
<span style="color: #408080; font-style: italic"># setting up the Hamiltonian</span>
Hamiltonian[<span style="color: #666666">0</span>,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> Xdiag<span style="color: #666666">+</span>e0
Hamiltonian[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>] <span style="color: #666666">=</span> Xnondiag
Hamiltonian[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> Hamiltonian[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>]
Hamiltonian[<span style="color: #666666">1</span>,<span style="color: #666666">1</span>] <span style="color: #666666">=</span> e1<span style="color: #666666">-</span>Xdiag
<span style="color: #408080; font-style: italic"># diagonalize and obtain eigenvalues, not necessarily sorted</span>
EigValues, EigVectors <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>eig(Hamiltonian)
permute <span style="color: #666666">=</span> EigValues<span style="color: #666666">.</span>argsort()
EigValues <span style="color: #666666">=</span> EigValues[permute]
<span style="color: #408080; font-style: italic"># print only the lowest eigenvalue</span>
<span style="color: #008000">print</span>(EigValues[<span style="color: #666666">0</span>])

<span style="color: #408080; font-style: italic"># Now rewrite it in terms of the identity matrix and the Pauli matrix X and Z</span>
X <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>],[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>]])
Y <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([[<span style="color: #666666">0</span>,<span style="color: #666666">-1</span>j],[<span style="color: #666666">1</span>j,<span style="color: #666666">0</span>]])
Z <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>],[<span style="color: #666666">0</span>,<span style="color: #666666">-1</span>]])
<span style="color: #408080; font-style: italic"># identity matrix</span>
I <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>],[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>]])

epsilon <span style="color: #666666">=</span> (e0<span style="color: #666666">+</span>e1)<span style="color: #666666">*0.5</span>; omega <span style="color: #666666">=</span> (e0<span style="color: #666666">-</span>e1)<span style="color: #666666">*0.5</span>
c <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>; omega_z<span style="color: #666666">=</span>Xdiag; omega_x <span style="color: #666666">=</span> Xnondiag
Hamiltonian <span style="color: #666666">=</span> (epsilon<span style="color: #666666">+</span>c)<span style="color: #666666">*</span>I<span style="color: #666666">+</span>(omega_z<span style="color: #666666">+</span>omega)<span style="color: #666666">*</span>Z<span style="color: #666666">+</span>omega_x<span style="color: #666666">*</span>X
EigValues, EigVectors <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>eig(Hamiltonian)
permute <span style="color: #666666">=</span> EigValues<span style="color: #666666">.</span>argsort()
EigValues <span style="color: #666666">=</span> EigValues[permute]
<span style="color: #408080; font-style: italic"># print only the lowest eigenvalue</span>
<span style="color: #008000">print</span>(EigValues[<span style="color: #666666">0</span>])

<span style="color: #408080; font-style: italic"># define the rotation matrices</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Rx</span>(theta):
    <span style="color: #008000; font-weight: bold">return</span> np<span style="color: #666666">.</span>cos(theta<span style="color: #666666">*0.5</span>)<span style="color: #666666">*</span>I<span style="color: #666666">-1</span>j<span style="color: #666666">*</span>np<span style="color: #666666">.</span>sin(theta<span style="color: #666666">*0.5</span>)<span style="color: #666666">*</span>X
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Ry</span>(phi):
    <span style="color: #008000; font-weight: bold">return</span> np<span style="color: #666666">.</span>cos(phi<span style="color: #666666">*0.5</span>)<span style="color: #666666">*</span>I<span style="color: #666666">-1</span>j<span style="color: #666666">*</span>np<span style="color: #666666">.</span>sin(phi<span style="color: #666666">*0.5</span>)<span style="color: #666666">*</span>Y

<span style="color: #408080; font-style: italic">#define basis states</span>
basis0 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([<span style="color: #666666">1</span>,<span style="color: #666666">0</span>])
basis1 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([<span style="color: #666666">0</span>,<span style="color: #666666">1</span>])

<span style="color: #408080; font-style: italic"># Computing the expectation value of the energy </span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Energy</span>(theta,phi):
    Basis <span style="color: #666666">=</span> Ry(phi) <span style="color: #666666">@</span> Rx(theta) <span style="color: #666666">@</span> basis0
    energy <span style="color: #666666">=</span> Basis<span style="color: #666666">.</span>conj()<span style="color: #666666">.</span>T <span style="color: #666666">@</span> Hamiltonian <span style="color: #666666">@</span> Basis
    <span style="color: #008000; font-weight: bold">return</span> energy


<span style="color: #408080; font-style: italic"># Set up iteration using gradient descent method</span>
eta <span style="color: #666666">=</span> <span style="color: #666666">0.1</span>
Niterations <span style="color: #666666">=</span> <span style="color: #666666">100</span>
<span style="color: #408080; font-style: italic"># Random angles using uniform distribution</span>
theta <span style="color: #666666">=</span> <span style="color: #666666">2*</span>np<span style="color: #666666">.</span>pi<span style="color: #666666">*</span>np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>rand()
phi <span style="color: #666666">=</span> <span style="color: #666666">2*</span>np<span style="color: #666666">.</span>pi<span style="color: #666666">*</span>np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>rand()
pi2 <span style="color: #666666">=</span> <span style="color: #666666">0.5*</span>np<span style="color: #666666">.</span>pi
<span style="color: #008000; font-weight: bold">for</span> <span style="color: #008000">iter</span> <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(Niterations):
    thetagradient <span style="color: #666666">=</span> <span style="color: #666666">0.5*</span>(Energy(theta<span style="color: #666666">+</span>pi2,phi)<span style="color: #666666">-</span>Energy(theta<span style="color: #666666">-</span>pi2,phi))
    phigradient <span style="color: #666666">=</span> <span style="color: #666666">0.5*</span>(Energy(theta,phi<span style="color: #666666">+</span>pi2)<span style="color: #666666">-</span>Energy(theta,phi<span style="color: #666666">-</span>pi2))
    theta <span style="color: #666666">-=</span> eta<span style="color: #666666">*</span>thetagradient
    phi <span style="color: #666666">-=</span> eta<span style="color: #666666">*</span>phigradient
<span style="color: #008000">print</span>(Energy(theta,phi))
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- !split -->
<h2 id="a-smarter-way-of-doing-this" class="anchor">A smarter way of doing this </h2>

<p>The above approach means that we are setting up several matrix-matrix
and matrix-vector multiplications. Although straight forward it is not
the most efficient way of doing this, in particular in case the
matrices become large (and sparse). But there are some more important
issues.
</p>

<p>In a physical realization of these systems we cannot just multiply the
state with the Hamiltonian. When performing a measurement we can only
measure in one particular direction. For the computational basis
states which we have, \( \vert 0\rangle \) and \( \vert 1\rangle \), we have
to measure along the bases of the Pauli matrices and reconstruct the
eigenvalues from these measurements.
</p>

<!-- !split -->
<h2 id="using-properties-of-pauli-matrices" class="anchor">Using properties of Pauli matrices </h2>

<p>From our earlier discussions we know that the Pauli \( Z \) matrix has the above basis states as eigen states through</p>

$$
Z\vert 0 \rangle = \boldsymbol{Z}\vert 0 \rangle=+1\vert 0 \rangle,
$$

<p>and</p>
$$
Z\vert 1 \rangle = \boldsymbol{Z}\vert 1 \rangle=-1\vert 1 \rangle,
$$

<p>with eigenvalue \( -1 \).</p>

<!-- !split -->
<h2 id="pauli-x-reminder" class="anchor">Pauli \( X \) reminder </h2>

<p>For the Pauli \( X \) matrix on the other hand we have</p>
$$
\boldsymbol{\sigma}_x\vert 0 \rangle = \boldsymbol{X}\vert 0 \rangle=+1\vert 1 \rangle,
$$

<p>and</p>
$$
\boldsymbol{\sigma}_x\vert 1 \rangle = \boldsymbol{X}\vert 1 \rangle=-1\vert 0 \rangle,
$$

<p>with eigenvalues \( 1 \) in both cases. The latter two equations tell us
that the computational basis we have chosen, and in which we will
prepare our states, is not an eigenbasis of the \( \sigma_x \) matrix.
</p>

<!-- !split -->
<h2 id="rewriting-the-pauli-x-matrix" class="anchor">Rewriting the Pauli \( X \) matrix </h2>

<p>We rewrite the Pauli \( X \) matrix in terms of a Pauli
\( Z \) matrixcusing the Hadamard matrix
twice, that is
</p>

$$
\boldsymbol{X}=\boldsymbol{\sigma}_x=\boldsymbol{H}\boldsymbol{Z}\boldsymbol{H}.
$$


<!-- !split -->
<h2 id="the-pauli-y-matrix" class="anchor">The Pauli \( Y \) matrix </h2>
<p>The Pauli \( Y \) matrix can be written as</p>

$$
\boldsymbol{Y}=\boldsymbol{\sigma}_y=\boldsymbol{H}\boldsymbol{S}^{\dagger}\boldsymbol{Z}\boldsymbol{H}\boldsymbol{S},
$$

<p>where \( S \) is the phase matrix</p>
$$
S = \begin{bmatrix} 1 & 0 \\ 0 & \imath \end{bmatrix}.
$$


<!-- !split -->
<h2 id="the-code-for-the-one-qubit-case-code-developed-by-august-gude-2023" class="anchor">The code for the one qubit case (code developed by August Gude, 2023) </h2>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">matplotlib.pyplot</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">plt</span>
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">seaborn</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">sns</span>; sns<span style="color: #666666">.</span>set_theme(font_scale<span style="color: #666666">=1.5</span>)
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">tqdm</span> <span style="color: #008000; font-weight: bold">import</span> tqdm

sigma_x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([[<span style="color: #666666">0</span>, <span style="color: #666666">1</span>], [<span style="color: #666666">1</span>, <span style="color: #666666">0</span>]])
sigma_y <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([[<span style="color: #666666">0</span>, <span style="color: #666666">-1</span>j], [<span style="color: #666666">1</span>j, <span style="color: #666666">0</span>]])
sigma_z <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([[<span style="color: #666666">1</span>, <span style="color: #666666">0</span>], [<span style="color: #666666">0</span>, <span style="color: #666666">-1</span>]])
I <span style="color: #666666">=</span> np<span style="color: #666666">.</span>eye(<span style="color: #666666">2</span>)

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">Hamiltonian</span>(lmb):
    E1 <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    E2 <span style="color: #666666">=</span> <span style="color: #666666">4</span>
    V11 <span style="color: #666666">=</span> <span style="color: #666666">3</span>
    V22 <span style="color: #666666">=</span> <span style="color: #666666">-3</span>
    V12 <span style="color: #666666">=</span> <span style="color: #666666">0.2</span>
    V21 <span style="color: #666666">=</span> <span style="color: #666666">0.2</span>

    eps <span style="color: #666666">=</span> (E1 <span style="color: #666666">+</span> E2) <span style="color: #666666">/</span> <span style="color: #666666">2</span>
    omega <span style="color: #666666">=</span> (E1 <span style="color: #666666">-</span> E2) <span style="color: #666666">/</span> <span style="color: #666666">2</span>
    c <span style="color: #666666">=</span> (V11 <span style="color: #666666">+</span> V22) <span style="color: #666666">/</span> <span style="color: #666666">2</span>
    omega_z <span style="color: #666666">=</span> (V11 <span style="color: #666666">-</span> V22) <span style="color: #666666">/</span> <span style="color: #666666">2</span>
    omega_x <span style="color: #666666">=</span> V12

    H0 <span style="color: #666666">=</span> eps <span style="color: #666666">*</span> I <span style="color: #666666">+</span> omega <span style="color: #666666">*</span> sigma_z
    H1 <span style="color: #666666">=</span> c <span style="color: #666666">*</span> I <span style="color: #666666">+</span> omega_z <span style="color: #666666">*</span> sigma_z <span style="color: #666666">+</span> omega_x <span style="color: #666666">*</span> sigma_x
    <span style="color: #008000; font-weight: bold">return</span> H0 <span style="color: #666666">+</span> lmb <span style="color: #666666">*</span> H1
    
lmbvalues_ana <span style="color: #666666">=</span> np<span style="color: #666666">.</span>arange(<span style="color: #666666">0</span>, <span style="color: #666666">1</span>, <span style="color: #666666">0.01</span>)
eigvals_ana <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((<span style="color: #008000">len</span>(lmbvalues_ana), <span style="color: #666666">2</span>))
<span style="color: #008000; font-weight: bold">for</span> index, lmb <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(lmbvalues_ana):
    H <span style="color: #666666">=</span> Hamiltonian(lmb)
    eigen, eigvecs <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>eig(H)
    permute <span style="color: #666666">=</span> eigen<span style="color: #666666">.</span>argsort()
    eigvals_ana[index] <span style="color: #666666">=</span> eigen[permute]
    eigvecs <span style="color: #666666">=</span> eigvecs[:,permute]


fig, axs <span style="color: #666666">=</span> plt<span style="color: #666666">.</span>subplots(<span style="color: #666666">1</span>, <span style="color: #666666">1</span>, figsize<span style="color: #666666">=</span>(<span style="color: #666666">10</span>, <span style="color: #666666">10</span>))
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">2</span>):
    axs<span style="color: #666666">.</span>plot(lmbvalues_ana, eigvals_ana[:,i], label<span style="color: #666666">=</span><span style="color: #BA2121">f&#39;$E_</span><span style="color: #BB6688; font-weight: bold">{</span>i<span style="color: #666666">+1</span><span style="color: #BB6688; font-weight: bold">}</span><span style="color: #BA2121">$&#39;</span>)
axs<span style="color: #666666">.</span>set_xlabel(<span style="color: #BA2121">r&#39;$\lambda$&#39;</span>)
axs<span style="color: #666666">.</span>set_ylabel(<span style="color: #BA2121">&#39;Energy&#39;</span>)
axs<span style="color: #666666">.</span>legend()
plt<span style="color: #666666">.</span>show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>This was the standard eigenvalue problem. Let us now switch to our own implementation of the VQE.</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">src.qc</span> <span style="color: #008000; font-weight: bold">import</span> <span style="color: #666666">*</span>

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">prepare_state</span>(theta, phi, target <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>):
    I <span style="color: #666666">=</span> np<span style="color: #666666">.</span>eye(<span style="color: #666666">2</span>)
    sigma_x <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([[<span style="color: #666666">0</span>, <span style="color: #666666">1</span>], [<span style="color: #666666">1</span>, <span style="color: #666666">0</span>]])
    sigma_y <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([[<span style="color: #666666">0</span>, <span style="color: #666666">-1</span>j], [<span style="color: #666666">1</span>j, <span style="color: #666666">0</span>]])
    state <span style="color: #666666">=</span> np<span style="color: #666666">.</span>array([<span style="color: #666666">1</span>, <span style="color: #666666">0</span>])
    Rx <span style="color: #666666">=</span> np<span style="color: #666666">.</span>cos(theta<span style="color: #666666">/2</span>) <span style="color: #666666">*</span> I <span style="color: #666666">-</span> <span style="color: #666666">1</span>j <span style="color: #666666">*</span> np<span style="color: #666666">.</span>sin(theta<span style="color: #666666">/2</span>) <span style="color: #666666">*</span> sigma_x
    Ry <span style="color: #666666">=</span> np<span style="color: #666666">.</span>cos(phi<span style="color: #666666">/2</span>) <span style="color: #666666">*</span> I <span style="color: #666666">-</span> <span style="color: #666666">1</span>j <span style="color: #666666">*</span> np<span style="color: #666666">.</span>sin(phi<span style="color: #666666">/2</span>) <span style="color: #666666">*</span> sigma_y
    state <span style="color: #666666">=</span> Ry <span style="color: #666666">@</span> Rx <span style="color: #666666">@</span> state
    <span style="color: #008000; font-weight: bold">if</span> target <span style="color: #AA22FF; font-weight: bold">is</span> <span style="color: #AA22FF; font-weight: bold">not</span> <span style="color: #008000; font-weight: bold">None</span>:
        state <span style="color: #666666">=</span> target
    <span style="color: #008000; font-weight: bold">return</span> state

<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">get_energy</span>(angles, lmb, number_shots, target <span style="color: #666666">=</span> <span style="color: #008000; font-weight: bold">None</span>):
    theta, phi <span style="color: #666666">=</span> angles[<span style="color: #666666">0</span>], angles[<span style="color: #666666">1</span>]
    <span style="color: #408080; font-style: italic"># print(f&#39;Theta = {theta}, Phi = {phi}&#39;)</span>
    E1 <span style="color: #666666">=</span> <span style="color: #666666">0</span>; E2 <span style="color: #666666">=</span> <span style="color: #666666">4</span>; V11 <span style="color: #666666">=</span> <span style="color: #666666">3</span>; V22 <span style="color: #666666">=</span> <span style="color: #666666">-3</span>; V12 <span style="color: #666666">=</span> <span style="color: #666666">0.2</span>; V21 <span style="color: #666666">=</span> <span style="color: #666666">0.2</span>

    eps <span style="color: #666666">=</span> (E1 <span style="color: #666666">+</span> E2) <span style="color: #666666">/</span> <span style="color: #666666">2</span>; omega <span style="color: #666666">=</span> (E1 <span style="color: #666666">-</span> E2) <span style="color: #666666">/</span> <span style="color: #666666">2</span>; c <span style="color: #666666">=</span> (V11 <span style="color: #666666">+</span> V22) <span style="color: #666666">/</span> <span style="color: #666666">2</span>; omega_z <span style="color: #666666">=</span> (V11 <span style="color: #666666">-</span> V22) <span style="color: #666666">/</span> <span style="color: #666666">2</span>; omega_x <span style="color: #666666">=</span> V12

    init_state <span style="color: #666666">=</span> prepare_state(theta, phi, target)
    qubit <span style="color: #666666">=</span> One_qubit()
    qubit<span style="color: #666666">.</span>set_state(init_state)
    measure_z <span style="color: #666666">=</span> qubit<span style="color: #666666">.</span>measure(number_shots)

    qubit<span style="color: #666666">.</span>set_state(init_state)
    qubit<span style="color: #666666">.</span>apply_hadamard()
    measure_x <span style="color: #666666">=</span> qubit<span style="color: #666666">.</span>measure(number_shots)
    
    <span style="color: #408080; font-style: italic"># expected value of Z = (number of 0 measurements - number of 1 measurements)/ number of shots</span>
    <span style="color: #408080; font-style: italic"># number of 1 measurements = sum(measure_z)</span>
    exp_val_z <span style="color: #666666">=</span> (omega <span style="color: #666666">+</span> lmb<span style="color: #666666">*</span>omega_z)<span style="color: #666666">*</span>(number_shots <span style="color: #666666">-</span> <span style="color: #666666">2*</span>np<span style="color: #666666">.</span>sum(measure_z)) <span style="color: #666666">/</span> number_shots
    exp_val_x <span style="color: #666666">=</span> lmb<span style="color: #666666">*</span>omega_x<span style="color: #666666">*</span>(number_shots <span style="color: #666666">-</span> <span style="color: #666666">2*</span>np<span style="color: #666666">.</span>sum(measure_x)) <span style="color: #666666">/</span> number_shots
    exp_val_i <span style="color: #666666">=</span> (eps <span style="color: #666666">+</span> c<span style="color: #666666">*</span>lmb) 
    exp_val <span style="color: #666666">=</span> (exp_val_z <span style="color: #666666">+</span> exp_val_x <span style="color: #666666">+</span> exp_val_i)
    <span style="color: #008000; font-weight: bold">return</span> exp_val 
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">minimize_energy</span>(lmb, number_shots, angles_0, learning_rate, max_epochs):
    <span style="color: #408080; font-style: italic"># angles = np.random.uniform(low = 0, high = np.pi, size = 2)</span>
    angles <span style="color: #666666">=</span> angles_0 <span style="color: #408080; font-style: italic">#lmb*np.array([np.pi, np.pi])</span>
    epoch <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    delta_energy <span style="color: #666666">=</span> <span style="color: #666666">1</span>
    energy <span style="color: #666666">=</span> get_energy(angles, lmb, number_shots)
    <span style="color: #008000; font-weight: bold">while</span> (epoch <span style="color: #666666">&lt;</span> max_epochs) <span style="color: #AA22FF; font-weight: bold">and</span> (delta_energy <span style="color: #666666">&gt;</span> <span style="color: #666666">1e-4</span>):
        grad <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros_like(angles)
        <span style="color: #008000; font-weight: bold">for</span> idx <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(angles<span style="color: #666666">.</span>shape[<span style="color: #666666">0</span>]):
            angles_temp <span style="color: #666666">=</span> angles<span style="color: #666666">.</span>copy()
            angles_temp[idx] <span style="color: #666666">+=</span> np<span style="color: #666666">.</span>pi<span style="color: #666666">/2</span> 
            E_plus <span style="color: #666666">=</span> get_energy(angles_temp, lmb, number_shots)
            angles_temp[idx] <span style="color: #666666">-=</span> np<span style="color: #666666">.</span>pi 
            E_minus <span style="color: #666666">=</span> get_energy(angles_temp, lmb, number_shots)
            grad[idx] <span style="color: #666666">=</span> (E_plus <span style="color: #666666">-</span> E_minus)<span style="color: #666666">/2</span> 
        angles <span style="color: #666666">-=</span> learning_rate<span style="color: #666666">*</span>grad 
        new_energy <span style="color: #666666">=</span> get_energy(angles, lmb, number_shots)
        delta_energy <span style="color: #666666">=</span> np<span style="color: #666666">.</span>abs(new_energy <span style="color: #666666">-</span> energy)
        energy <span style="color: #666666">=</span> new_energy
        epoch <span style="color: #666666">+=</span> <span style="color: #666666">1</span>
    <span style="color: #008000; font-weight: bold">return</span> angles, epoch, (epoch <span style="color: #666666">&lt;</span> max_epochs), energy, delta_energy
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">number_shots_search <span style="color: #666666">=</span> <span style="color: #666666">10_000</span>
number_shots <span style="color: #666666">=</span> <span style="color: #666666">10_000</span>
learning_rate <span style="color: #666666">=</span> <span style="color: #666666">0.3</span>
max_epochs <span style="color: #666666">=</span> <span style="color: #666666">400</span>
lmbvalues <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0.0</span>, <span style="color: #666666">1.0</span>, <span style="color: #666666">30</span>)
min_energy <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(<span style="color: #008000">len</span>(lmbvalues))
epochs <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(<span style="color: #008000">len</span>(lmbvalues))
<span style="color: #008000; font-weight: bold">for</span> index, lmb <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(tqdm(lmbvalues)):
    memory <span style="color: #666666">=</span> <span style="color: #666666">0</span>
    angles_0 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>uniform(low <span style="color: #666666">=</span> <span style="color: #666666">0</span>, high <span style="color: #666666">=</span> np<span style="color: #666666">.</span>pi, size <span style="color: #666666">=</span> <span style="color: #666666">2</span>)
    angles, epochs[index], converged, energy, delta_energy <span style="color: #666666">=</span> minimize_energy(lmb, number_shots_search, angles_0, learning_rate, max_epochs)
    <span style="color: #008000; font-weight: bold">if</span> epochs[index] <span style="color: #666666">&lt;</span> (epochs[index<span style="color: #666666">-1</span>] <span style="color: #666666">-</span> <span style="color: #666666">5</span>):
        angles_0 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>uniform(low <span style="color: #666666">=</span> <span style="color: #666666">0</span>, high <span style="color: #666666">=</span> np<span style="color: #666666">.</span>pi, size <span style="color: #666666">=</span> <span style="color: #666666">2</span>)
        angles, epochs[index], converged, energy, delta_energy <span style="color: #666666">=</span> minimize_energy(lmb, number_shots_search, angles_0, learning_rate, max_epochs)
    min_energy[index] <span style="color: #666666">=</span> get_energy(angles, lmb, number_shots)
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">scipy.optimize</span> <span style="color: #008000; font-weight: bold">import</span> minimize
number_shots <span style="color: #666666">=</span> <span style="color: #666666">10_000</span>
lmbvalues_scipy <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0.0</span>, <span style="color: #666666">1.0</span>, <span style="color: #666666">50</span>)
min_energy_scipy <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(<span style="color: #008000">len</span>(lmbvalues_scipy))
<span style="color: #008000; font-weight: bold">for</span> index, lmb <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">enumerate</span>(tqdm(lmbvalues_scipy)):
    angles_start <span style="color: #666666">=</span> np<span style="color: #666666">.</span>random<span style="color: #666666">.</span>uniform(low <span style="color: #666666">=</span> <span style="color: #666666">0</span>, high <span style="color: #666666">=</span> np<span style="color: #666666">.</span>pi, size <span style="color: #666666">=</span> <span style="color: #666666">4</span>)
    res <span style="color: #666666">=</span> minimize(get_energy, angles_start, args <span style="color: #666666">=</span> (lmb, number_shots), method <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;Powell&#39;</span>, options <span style="color: #666666">=</span> {<span style="color: #BA2121">&#39;maxiter&#39;</span>: <span style="color: #666666">1000</span>}, tol <span style="color: #666666">=</span> <span style="color: #666666">1e-5</span>)
    min_energy_scipy[index] <span style="color: #666666">=</span> res<span style="color: #666666">.</span>fun
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">fig, axs <span style="color: #666666">=</span> plt<span style="color: #666666">.</span>subplots(<span style="color: #666666">1</span>, <span style="color: #666666">1</span>, figsize<span style="color: #666666">=</span>(<span style="color: #666666">10</span>, <span style="color: #666666">10</span>))
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(<span style="color: #666666">2</span>):
    axs<span style="color: #666666">.</span>plot(lmbvalues_ana, eigvals_ana[:,i], label<span style="color: #666666">=</span><span style="color: #BA2121">f&#39;$E_</span><span style="color: #BB6688; font-weight: bold">{</span>i<span style="color: #666666">+1</span><span style="color: #BB6688; font-weight: bold">}</span><span style="color: #BA2121">$&#39;</span>, color <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;#4c72b0&#39;</span>)
axs<span style="color: #666666">.</span>scatter(lmbvalues, min_energy, label <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;VQE eigenvalues&#39;</span>, color <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;#dd8452&#39;</span>)
axs<span style="color: #666666">.</span>scatter(lmbvalues_scipy, min_energy_scipy, label <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;VQE Scipy&#39;</span>, color <span style="color: #666666">=</span> <span style="color: #BA2121">&#39;#55a868&#39;</span>)
axs<span style="color: #666666">.</span>set_xlabel(<span style="color: #BA2121">r&#39;$\lambda$&#39;</span>)
axs<span style="color: #666666">.</span>set_ylabel(<span style="color: #BA2121">&#39;Energy&#39;</span>)
plt<span style="color: #666666">.</span>legend()
plt<span style="color: #666666">.</span>show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>
<h2 id="switching-to-qiskit" class="anchor">Switching to Qiskit  </h2>

<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;">
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>


<!-- ------------------- end of main content --------------- -->
</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>
<!-- Bootstrap footer
<footer>
<a href="https://..."><img width="250" align=right src="https://..."></a>
</footer>
-->
<center style="font-size:80%">
<!-- copyright --> &copy; 1999-2024, Morten Hjorth-Jensen. Released under CC Attribution-NonCommercial 4.0 license
</center>
</body>
</html>

