<!--
HTML file automatically generated from DocOnce source
(https://github.com/doconce/doconce/)
doconce format html week3.do.txt --html_style=bootstrap --pygments_html_style=default --html_admon=bootstrap_panel --html_output=week3-bs --no_mako
-->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="DocOnce: https://github.com/doconce/doconce/" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="description" content="February 6-10,2023: Quantum Computing, Quantum Machine Learning and Quantum Information Theories">
<title>February 6-10,2023: Quantum Computing, Quantum Machine Learning and Quantum Information Theories</title>
<!-- Bootstrap style: bootstrap -->
<!-- doconce format html week3.do.txt --html_style=bootstrap --pygments_html_style=default --html_admon=bootstrap_panel --html_output=week3-bs --no_mako -->
<link href="https://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css" rel="stylesheet">
<!-- not necessary
<link href="https://netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
-->
<style type="text/css">
/* Add scrollbar to dropdown menus in bootstrap navigation bar */
.dropdown-menu {
   height: auto;
   max-height: 400px;
   overflow-x: hidden;
}
/* Adds an invisible element before each target to offset for the navigation
   bar */
.anchor::before {
  content:"";
  display:block;
  height:50px;      /* fixed header height for style bootstrap */
  margin:-50px 0 0; /* negative fixed header height */
}
</style>
</head>

<!-- tocinfo
{'highest level': 2,
 'sections': [('Overview, Density matrices, Entropy and Schmidt Decompositions',
               2,
               None,
               'overview-density-matrices-entropy-and-schmidt-decompositions'),
              ('Density matrices and entropy',
               2,
               None,
               'density-matrices-and-entropy')]}
end of tocinfo -->

<body>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: {
     equationNumbers: {  autoNumber: "AMS"  },
     extensions: ["AMSmath.js", "AMSsymbols.js", "autobold.js", "color.js"]
  }
});
</script>
<script type="text/javascript" async
 src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<!-- Bootstrap navigation bar -->
<div class="navbar navbar-default navbar-fixed-top">
  <div class="navbar-header">
    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-responsive-collapse">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
    <a class="navbar-brand" href="week3-bs.html">February 6-10,2023: Quantum Computing, Quantum Machine Learning and Quantum Information Theories</a>
  </div>
  <div class="navbar-collapse collapse navbar-responsive-collapse">
    <ul class="nav navbar-nav navbar-right">
      <li class="dropdown">
        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Contents <b class="caret"></b></a>
        <ul class="dropdown-menu">
     <!-- navigation toc: --> <li><a href="#overview-density-matrices-entropy-and-schmidt-decompositions" style="font-size: 80%;">Overview, Density matrices, Entropy and Schmidt Decompositions</a></li>
     <!-- navigation toc: --> <li><a href="#density-matrices-and-entropy" style="font-size: 80%;">Density matrices and entropy</a></li>

        </ul>
      </li>
    </ul>
  </div>
</div>
</div> <!-- end of navigation bar -->
<div class="container">
<p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p> <!-- add vertical space -->
<!-- ------------------- main content ---------------------- -->
<div class="jumbotron">
<center>
<h1>February 6-10,2023: Quantum Computing, Quantum Machine Learning and Quantum Information Theories</h1>
</center>  <!-- document title -->

<!-- author(s): Morten Hjorth-Jensen -->
<center>
<b>Morten Hjorth-Jensen</b> [1, 2]
</center>
<!-- institution(s) -->
<center>
[1] <b>Department of Physics, University of Oslo, Norway</b>
</center>
<center>
[2] <b>Department of Physics and Astronomy and Facility for Rare Isotope Beams, Michigan State University, USA</b>
</center>
<br>
<center>
<h4>Feb 3, 2023</h4>
</center> <!-- date -->
<br>


</div> <!-- end jumbotron -->
<h2 id="overview-density-matrices-entropy-and-schmidt-decompositions" class="anchor">Overview, Density matrices, Entropy and Schmidt Decompositions   </h2>

<div class="panel panel-default">
<div class="panel-body">
<!-- subsequent paragraphs come in larger fonts, so start with a paragraph -->
<ol>
 <li> Density matrices and Entropy</li>
 <li> Schmidt decomposition and entanglement</li>
</ol>
</div>
</div>


<ul>
<li> <a href="https://github.com/CompPhysics/QuantumComputingMachineLearning/tree/gh-pages/doc/pub/week3" target="_self">Teaching material in different formats</a></li>
<li> <b>Reading recommendation</b>: Scherrer, Mathematics of Quantum Computations, chapter 4</li>
</ul>
<h2 id="density-matrices-and-entropy" class="anchor">Density matrices and entropy </h2>

<p>In order to study the importance of level avoided crossings and
entanglement, we study first a simple two-level system. Thereafter we
extend our level-crossing model to a four-level system which can be
interpreted as composed of two separate (not necesseraly identical)
subsystems.
</p>

<p>We let our hamiltonian depend linearly on a strength parameter \( z \)</p>

$$
       H=H_0+\lambda H_\mathrm{I},
$$

<p>with \( \lambda \in [0,1] \), where the limits \( \lambda=0 \) and \( \lambda=1 \)
represent the non-interacting (or unperturbed) and fully interacting
system, respectively.  The model is an eigenvalue problem with only
two available states, which we label \( \vert 0\rangle \) and \( \vert
1\rangle \), respectively. Below we will let state \( \vert 0 \rangle \)
represent the lowest state (often referred to as model-space state)
eigenvalue whereas state \( \vert 1\rangle \) represents the eigenvalue of
the excluded space.  The non-interacting solutions to our problem are
</p>

$$
\begin{equation}
       H_0\vert 0 \rangle =\epsilon_0\vert 0 \rangle,
\label{_auto1}
\end{equation}
$$

<p>and</p>
$$
\begin{equation}
       H_0\vert 1\rangle =\epsilon_1\vert 1\rangle,
\label{_auto2}
\end{equation}
$$

<p>with \( \epsilon_0 < \epsilon_1 \). We label the off-diagonal matrix
elements \( X \), while \( X_0=\langle 0 \vert H_I\vert 0 \rangle \) and
\( X_1=\langle 1 \vert H_1\vert 1 \rangle \).  The exact eigenvalue
problem
</p>

$$
\begin{equation}
\left(\begin{array}{cc}\epsilon_0+\lambda X_0 &\lambda X \\
zX &\epsilon_1+\lambda X_1 \end{array}\right)
\label{_auto3}
\end{equation}
$$

<p>yields</p>
$$
\begin{eqnarray}
\label{eq:exact}
     E(\lambda)=&\frac{1}{2}\left\{\epsilon_0 +\epsilon_1 +\lambda X_0
     +\lambda X_1 \pm \left(
     \epsilon_1 -\epsilon_0 +\lambda X_1-\lambda X_0\right) \right. \\ \nonumber
     & \left. \times\sqrt{1+\frac{4\lambda^2X^2}{\left(
     \epsilon_1 -\epsilon_0 +\lambda X_1-\lambda X_0\right)^2}}
     \right\}.
\end{eqnarray}
$$

<p>In the results below we set the parameters \( \epsilon_0=0 \),
\( \epsilon_1=4 \), \( X_0=-X_1=3 \) and \( X=0.2 \).  This eigenvalue problem can
easily be rewritten in terms of the standard Pauli matrices.  The
non-interacting solutions represent our computational basis.
Pertinent to our choice of parameters, is that at \( \lambda\geq 2/3 \),
the lowest eigenstate is dominated by \( \vert 1\rangle \) while the upper
is \( \vert 0 \rangle \). At \( \lambda=1 \) the \( \vert 0 \rangle \) mixing of
the lowest eigenvalue is \( 1\% \) while for \( \lambda\leq 2/3 \) we have a
\( \vert 0 \rangle \) component of more than \( 90\% \).  The character of the
eigenvectors has therefore been interchanged when passing \( z=2/3 \). The
value of the parameter \( X \) represents the strength of the coupling
between the model space and the excluded space.  The following code
computes and plots the eigenvalues.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #666666">%</span>matplotlib inline

<span style="color: #008000; font-weight: bold">from</span>  <span style="color: #0000FF; font-weight: bold">matplotlib</span> <span style="color: #008000; font-weight: bold">import</span> pyplot <span style="color: #008000; font-weight: bold">as</span> plt
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
dim <span style="color: #666666">=</span> <span style="color: #666666">2</span>
<span style="color: #408080; font-style: italic">#Setting up a tridiagonal matrix and finding eigenvectors and eigenvalues</span>
Hamiltonian <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((dim,dim))
<span style="color: #408080; font-style: italic">#number of lambda values</span>
n <span style="color: #666666">=</span> <span style="color: #666666">100</span>
lmbd <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0.</span>,<span style="color: #666666">1.0</span>,n)
e0 <span style="color: #666666">=</span> <span style="color: #666666">0.0</span>
e1 <span style="color: #666666">=</span> <span style="color: #666666">4.0</span>
X <span style="color: #666666">=</span> <span style="color: #666666">0.20</span>
Xp <span style="color: #666666">=</span> <span style="color: #666666">3.0</span>
Eigenvalue <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((dim,n))
<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n): 
    Hamiltonian[<span style="color: #666666">0</span>,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> lmbd[i]<span style="color: #666666">*</span>Xp<span style="color: #666666">+</span>e0
    Hamiltonian[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>] <span style="color: #666666">=</span> lmbd[i]<span style="color: #666666">*</span>X
    Hamiltonian[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>] <span style="color: #666666">=</span> Hamiltonian[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>]
    Hamiltonian[<span style="color: #666666">1</span>,<span style="color: #666666">1</span>] <span style="color: #666666">=</span> e1<span style="color: #666666">+</span>lmbd[i]<span style="color: #666666">*</span>(<span style="color: #666666">-</span>Xp)
    <span style="color: #408080; font-style: italic"># diagonalize and obtain eigenvalues, not necessarily sorted</span>
    EigValues, EigVectors <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>eig(Hamiltonian)
    <span style="color: #408080; font-style: italic"># sort eigenvectors and eigenvalues</span>
    permute <span style="color: #666666">=</span> EigValues<span style="color: #666666">.</span>argsort()
    EigValues <span style="color: #666666">=</span> EigValues[permute]
    EigVectors <span style="color: #666666">=</span> EigVectors[:,permute]
    Eigenvalue[<span style="color: #666666">0</span>,i] <span style="color: #666666">=</span> EigValues[<span style="color: #666666">0</span>]
    Eigenvalue[<span style="color: #666666">1</span>,i] <span style="color: #666666">=</span> EigValues[<span style="color: #666666">1</span>]
plt<span style="color: #666666">.</span>plot(lmbd, Eigenvalue[<span style="color: #666666">0</span>,:] ,<span style="color: #BA2121">&#39;b-&#39;</span>,lmbd, Eigenvalue[<span style="color: #666666">1</span>,:],<span style="color: #BA2121">&#39;g-&#39;</span>,)
plt<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;$\lambda$&#39;</span>)
plt<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;Eigenvalues&#39;</span>)
plt<span style="color: #666666">.</span>show()
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>This simple model exhibits a simple level crossing where the
composition of the final interacting states change character as we
gradually switch on the interaction.  In order to study how
entanglement relates to level crossing and the main results of our
investigations, we extend the simple two-level system to a four level
system. This system can be thought of as composed of two subsystems
\( A \) and \( B \). Each subsystem has computational basis states
</p>

$$
\vert 0\rangle_{\mathrm{A,B}}=\begin{bmatrix} 1 & 0\end{bmatrix}^T \hspace{1cm} \vert 1\rangle_{\mathrm{A,B}}=\begin{bmatrix} 0 & 1\end{bmatrix}^T.
$$

<p>The subsystems could represent single particles or composite many-particle systems of a given symmetry.
This leads to the many-body computational basis states
</p>

$$
\vert 00\rangle = \vert 0\rangle_{\mathrm{A}}\otimes \vert 0\rangle_{\mathrm{B}}=\begin{bmatrix} 1 & 0 & 0 &0\end{bmatrix}^T,
$$

<p>and</p>
$$
\vert 10\rangle = \vert 1\rangle_{\mathrm{A}}\otimes \vert 0\rangle_{\mathrm{B}}=\begin{bmatrix} 0 & 1 & 0 &0\end{bmatrix}^T,
$$

<p>and</p>
$$
\vert 01\rangle = \vert 0\rangle_{\mathrm{A}}\otimes \vert 1\rangle_{\mathrm{B}}=\begin{bmatrix} 0 & 0 & 1 &0\end{bmatrix}^T,
$$

<p>and finally</p>
$$
\vert 11\rangle = \vert 1\rangle_{\mathrm{A}}\otimes \vert 1\rangle_{\mathrm{B}}=\begin{bmatrix} 0 & 0 & 0 &1\end{bmatrix}^T.
$$

<p>These computational basis states define also the eigenstates of the non-interacting  Hamiltonian</p>
$$
H_0\vert 00 \rangle = \epsilon_{00}\vert 00 \rangle,
$$

$$
H_0\vert 10 \rangle = \epsilon_{10}\vert 10 \rangle,
$$

$$
H_0\vert 01 \rangle = \epsilon_{01}\vert 01 \rangle,
$$

<p>and</p>
$$
H_0\vert 11 \rangle = \epsilon_{11}\vert 11 \rangle.
$$

<p>The interacting part of the Hamiltonian \( H_{\mathrm{I}} \) is given by the tensor product of two \( \sigma_x \) and \( \sigma_z \)  matrices, respectively, that is</p>
$$
H_{\mathrm{I}}=H_x\sigma_x\otimes\sigma_x+H_z\sigma_z\otimes\sigma_z,
$$

<p>where \( H_x \) and \( H_z \) are interaction strength parameters. Our final Hamiltonian matrix is given by</p>
$$
\boldsymbol{H}=\begin{bmatrix} \epsilon_{00}+H_z & 0 & 0 & H_x \\
                       0  & \epsilon_{10}-H_z & H_x & 0 \\
		       0 & H_x & \epsilon_{01}+H_z & 0 \\
		       H_x & 0 & 0 & \epsilon_{11} -H_z \end{bmatrix}.
$$

<p>The four eigenstates of the above Hamiltonian matrix can in turn be used to
define density matrices. As an example, the density matrix of the
first eigenstate (lowest energy \( E_0 \)) \( \Psi_0 \) is
</p>

$$
\rho_0=\left(\alpha_{00}\vert 00 \rangle\langle 00\vert+\alpha_{10}\vert 10 \rangle\langle 10\vert+\alpha_{01}\vert 01 \rangle\langle 01\vert+\alpha_{11}\vert 11 \rangle\langle 11\vert\right),
$$

<p>where the coefficients \( \alpha_{ij} \) are the eigenvector coefficients
resulting from the solution of the above eigenvalue problem.  We can
then in turn define the density matrix for the subsets \( A \) or \( B \) as
</p>

$$
\rho_A=\mathrm{Tr}_B(\rho_{0})=\langle 0 \vert \rho_{0} \vert 0\rangle_{B}+\langle 1 \vert \rho_{0} \vert 1\rangle_{B},
$$

<p>or</p>

$$
\rho_B=\mathrm{Tr}_A(\rho_{\Psi_0})=\langle 0 \vert \rho_{0} \vert 0\rangle_{A}+\langle 1 \vert \rho_{0} \vert 1\rangle_{A}.
$$

<p>The density matrices for these subsets can be used to compute the
so-called von Neumann entropy, which is one of the possible measures
of entanglement. A pure state has entropy equal zero while entangled
state have an entropy larger than zero. The von-Neumann entropy is
defined as
</p>

$$
S(A,B)=-\mathrm{Tr}\left(\rho_{A,B}\log_2 (\rho_{A,B})\right).
$$

<p>The example here shows the above von Neumann entropy based on the
density matrix for the lowest many-body state. We see clearly a jump
in the entropy around the point where we have a level crossing. At
interaction strenght \( \lambda=0 \) we have many-body states purely
defined by their computational basis states. As we switch on the
interaction strength, we obtain an increased degree of mixing and the
entropy increases till we reach the level crossing point where we see
an additional and sudden increase in entropy. Similar behaviors are
observed for the other states. The most important result from this
example is that entanglement is driven by the Hamiltonian itself and
the strength of the interaction matrix elements and the
non-interacting energies.
</p>


<!-- code=python (!bc pycod) typeset with pygments style "default" -->
<div class="cell border-box-sizing code_cell rendered">
  <div class="input">
    <div class="inner_cell">
      <div class="input_area">
        <div class="highlight" style="background: #f8f8f8">
  <pre style="line-height: 125%;"><span style="color: #666666">%</span>matplotlib inline
<span style="color: #008000; font-weight: bold">from</span>  <span style="color: #0000FF; font-weight: bold">matplotlib</span> <span style="color: #008000; font-weight: bold">import</span> pyplot <span style="color: #008000; font-weight: bold">as</span> plt
<span style="color: #008000; font-weight: bold">import</span> <span style="color: #0000FF; font-weight: bold">numpy</span> <span style="color: #008000; font-weight: bold">as</span> <span style="color: #0000FF; font-weight: bold">np</span>
<span style="color: #008000; font-weight: bold">from</span> <span style="color: #0000FF; font-weight: bold">scipy.linalg</span> <span style="color: #008000; font-weight: bold">import</span> logm, expm
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">log2M</span>(a): <span style="color: #408080; font-style: italic"># base 2 matrix logarithm</span>
    <span style="color: #008000; font-weight: bold">return</span> logm(a)<span style="color: #666666">/</span>np<span style="color: #666666">.</span>log(<span style="color: #666666">2.0</span>)

dim <span style="color: #666666">=</span> <span style="color: #666666">4</span>
Hamiltonian <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((dim,dim))
<span style="color: #408080; font-style: italic">#number of lambda values</span>
n <span style="color: #666666">=</span> <span style="color: #666666">40</span>
lmbd <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linspace(<span style="color: #666666">0.0</span>,<span style="color: #666666">1.0</span>,n)
Hx <span style="color: #666666">=</span> <span style="color: #666666">2.0</span>
Hz <span style="color: #666666">=</span> <span style="color: #666666">3.0</span>
<span style="color: #408080; font-style: italic"># Non-diagonal part as sigma_x tensor product with sigma_x</span>
sx <span style="color: #666666">=</span> np<span style="color: #666666">.</span>matrix([[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>],[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>]])
sx2 <span style="color: #666666">=</span> Hx<span style="color: #666666">*</span>np<span style="color: #666666">.</span>kron(sx, sx)
<span style="color: #408080; font-style: italic"># Diagonal part as sigma_z tensor product with sigma_z</span>
sz <span style="color: #666666">=</span> np<span style="color: #666666">.</span>matrix([[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>],[<span style="color: #666666">0</span>,<span style="color: #666666">-1</span>]])
sz2 <span style="color: #666666">=</span> Hz<span style="color: #666666">*</span>np<span style="color: #666666">.</span>kron(sz, sz)
noninteracting <span style="color: #666666">=</span> [<span style="color: #666666">0.0</span>, <span style="color: #666666">2.5</span>, <span style="color: #666666">6.5</span>, <span style="color: #666666">7.0</span>]
D <span style="color: #666666">=</span> np<span style="color: #666666">.</span>diag(noninteracting)
Eigenvalue <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((dim,n))
Entropy <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros(n)

<span style="color: #008000; font-weight: bold">for</span> i <span style="color: #AA22FF; font-weight: bold">in</span> <span style="color: #008000">range</span>(n): 
    Hamiltonian <span style="color: #666666">=</span> lmbd[i]<span style="color: #666666">*</span>(sx2<span style="color: #666666">+</span>sz2)<span style="color: #666666">+</span>D
    <span style="color: #408080; font-style: italic"># diagonalize and obtain eigenvalues, not necessarily sorted</span>
    EigValues, EigVectors <span style="color: #666666">=</span> np<span style="color: #666666">.</span>linalg<span style="color: #666666">.</span>eig(Hamiltonian)
    <span style="color: #408080; font-style: italic"># sort eigenvectors and eigenvalues</span>
    permute <span style="color: #666666">=</span> EigValues<span style="color: #666666">.</span>argsort()
    EigValues <span style="color: #666666">=</span> EigValues[permute]
    EigVectors <span style="color: #666666">=</span> EigVectors[:,permute]
    <span style="color: #408080; font-style: italic"># Compute density matrix for selected system state, here ground state</span>
    DensityMatrix <span style="color: #666666">=</span> np<span style="color: #666666">.</span>zeros((dim,dim))
    DensityMatrix <span style="color: #666666">=</span> np<span style="color: #666666">.</span>outer(EigVectors[:,<span style="color: #666666">0</span>],EigVectors[:,<span style="color: #666666">0</span>])
    <span style="color: #408080; font-style: italic"># Project down on substates and find density matrix for subsystem</span>
    d <span style="color: #666666">=</span> np<span style="color: #666666">.</span>matrix([[<span style="color: #666666">1</span>,<span style="color: #666666">0</span>],[<span style="color: #666666">0</span>,<span style="color: #666666">1</span>]])
    v1 <span style="color: #666666">=</span> [<span style="color: #666666">1.0</span>,<span style="color: #666666">0.0</span>]
    proj1 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>kron(v1,d)
    x1 <span style="color: #666666">=</span> proj1 <span style="color: #666666">@</span> DensityMatrix <span style="color: #666666">@</span> proj1<span style="color: #666666">.</span>T
    v2 <span style="color: #666666">=</span> [<span style="color: #666666">0.0</span>,<span style="color: #666666">1.0</span>]
    proj2 <span style="color: #666666">=</span> np<span style="color: #666666">.</span>kron(v2,d)
    x2 <span style="color: #666666">=</span> proj2 <span style="color: #666666">@</span> DensityMatrix <span style="color: #666666">@</span> proj2<span style="color: #666666">.</span>T
    <span style="color: #408080; font-style: italic"># Total density matrix for subsystem</span>
    total <span style="color: #666666">=</span> x1<span style="color: #666666">+</span>x2
    <span style="color: #408080; font-style: italic"># von Neumann Entropy for subsystem </span>
    Entropy[i] <span style="color: #666666">=</span> <span style="color: #666666">-</span>np<span style="color: #666666">.</span>matrix<span style="color: #666666">.</span>trace(total <span style="color: #666666">@</span> log2M(total))
    <span style="color: #408080; font-style: italic"># Plotting eigenvalues and entropy as functions of interaction strengths</span>
    Eigenvalue[<span style="color: #666666">0</span>,i] <span style="color: #666666">=</span> EigValues[<span style="color: #666666">0</span>]
    Eigenvalue[<span style="color: #666666">1</span>,i] <span style="color: #666666">=</span> EigValues[<span style="color: #666666">1</span>]
    Eigenvalue[<span style="color: #666666">2</span>,i] <span style="color: #666666">=</span> EigValues[<span style="color: #666666">2</span>]
    Eigenvalue[<span style="color: #666666">3</span>,i] <span style="color: #666666">=</span> EigValues[<span style="color: #666666">3</span>]
plt<span style="color: #666666">.</span>plot(lmbd, Eigenvalue[<span style="color: #666666">0</span>,:] ,<span style="color: #BA2121">&#39;b-&#39;</span>,lmbd, Eigenvalue[<span style="color: #666666">1</span>,:],<span style="color: #BA2121">&#39;g-&#39;</span>,)
plt<span style="color: #666666">.</span>plot(lmbd, Eigenvalue[<span style="color: #666666">2</span>,:] ,<span style="color: #BA2121">&#39;r-&#39;</span>,lmbd, Eigenvalue[<span style="color: #666666">3</span>,:],<span style="color: #BA2121">&#39;y-&#39;</span>,)
plt<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;$\lambda$&#39;</span>)
plt<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;Eigenvalues&#39;</span>)
plt<span style="color: #666666">.</span>show()
plt<span style="color: #666666">.</span>plot(lmbd, Entropy)
plt<span style="color: #666666">.</span>xlabel(<span style="color: #BA2121">&#39;$\lambda$&#39;</span>)
plt<span style="color: #666666">.</span>ylabel(<span style="color: #BA2121">&#39;Entropy&#39;</span>)          
plt<span style="color: #666666">.</span>show
</pre>
</div>
      </div>
    </div>
  </div>
  <div class="output_wrapper">
    <div class="output">
      <div class="output_area">
        <div class="output_subarea output_stream output_stdout output_text">          
        </div>
      </div>
    </div>
  </div>
</div>

<p>With these introductory examples, we are now in the position where we
can start to interpret and model realistic interacting many-electron
systems in terms of the strength of the Coulomb interaction and the
shapes of the potential well. Our specific system is composed of two
potential wells with one fermion (electrons in our case) trapped in
each well.  Each potential well can sustain a certain number of bound
single-particle states and defines our subsystems \( A \) and \( B \). The
non-interacting part of the Hamiltonian is given by the mere addition
of the single-particle energies from each repsective well (make figure
with labels A and B and single-particle energies).
</p>

<p>The eigenstates of the non-interacting Hamiltonian \( H_0 \) are given by
various computational basis states with the difference from the above
simple models that now we have more than two states in each
subsystem. The depths of the potential wells and their respective
distances can be tuned in an experimental set up. The theoretical
calculations presented here can thus serve as a tool which aids in
finding the optimal parameters in order to study entanglement in a
many-body environment.
</p>

<!-- ------------------- end of main content --------------- -->
</div>  <!-- end container -->
<!-- include javascript, jQuery *first* -->
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/js/bootstrap.min.js"></script>
<!-- Bootstrap footer
<footer>
<a href="https://..."><img width="250" align=right src="https://..."></a>
</footer>
-->
<center style="font-size:80%">
<!-- copyright --> &copy; 1999-2023, Morten Hjorth-Jensen. Released under CC Attribution-NonCommercial 4.0 license
</center>
</body>
</html>

