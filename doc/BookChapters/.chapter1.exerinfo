# Information about all exercises in the file chapter1.do.txt.
# The information can be loaded into a Python list of dicts by
#
# f = open('.chapter1.exerinfo', 'r')
# exer = eval(f.read())
#
[{'ans_docend': '',
  'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': None,
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': None,
  'no': 1,
  'sol_docend': '',
  'solution': '',
  'solution_file': None,
  'subex': [],
  'text': 'The first exercise here is of a mere technical art. We want you to '
          'have \n'
          '* git as a version control software and to establish a user account '
          'on a provider like GitHub. Other providers like GitLab etc are '
          'equally fine. You can also use the University of Oslo "GitHub '
          'facilities":"https://www.uio.no/tjenester/it/maskin/filer/versjonskontroll/github.html". \n'
          '* Install various Python packages\n'
          '\n'
          'We will make extensive use of Python as programming language and '
          'its\n'
          'myriad of available libraries.  You will find\n'
          'IPython/Jupyter notebooks invaluable in your work.  You can run '
          '_R_\n'
          'codes in the Jupyter/IPython notebooks, with the immediate benefit '
          'of\n'
          'visualizing your data. You can also use compiled languages like '
          'C++,\n'
          'Rust, Fortran etc if you prefer. The focus in these lectures will '
          'be\n'
          'on Python.\n'
          '\n'
          'If you have Python installed (we recommend Python3) and you feel\n'
          'pretty familiar with installing different packages, we recommend '
          'that\n'
          'you install the following Python packages via _pip_ as \n'
          '\n'
          'o pip install numpy scipy matplotlib ipython scikit-learn sympy '
          'pandas pillow \n'
          '\n'
          'For _Tensorflow_, we recommend following the instructions in the '
          'text of \n'
          '"Aurelien Geron, Hands‑On Machine Learning with Scikit‑Learn and '
          'TensorFlow, '
          'O\'Reilly":"http://shop.oreilly.com/product/0636920052289.do"\n'
          '\n'
          'We will come back to _tensorflow_ later. \n'
          '\n'
          'For Python3, replace _pip_ with _pip3_.\n'
          '\n'
          'For OSX users we recommend, after having installed Xcode, to\n'
          'install _brew_. Brew allows for a seamless installation of '
          'additional\n'
          'software via for example \n'
          '\n'
          'o brew install python3\n'
          '\n'
          'For Linux users, with its variety of distributions like for example '
          'the widely popular Ubuntu distribution,\n'
          'you can use _pip_ as well and simply install Python as \n'
          '\n'
          'o sudo apt-get install python3  (or python for Python2.7)\n'
          '\n'
          "If you don't want to perform these operations separately and "
          'venture\n'
          'into the hassle of exploring how to set up dependencies and paths, '
          'we\n'
          'recommend two widely used distrubutions which set up all relevant\n'
          'dependencies for Python, namely \n'
          '\n'
          '* "Anaconda":"https://docs.anaconda.com/", \n'
          '\n'
          'which is an open source\n'
          'distribution of the Python and R programming languages for '
          'large-scale\n'
          'data processing, predictive analytics, and scientific computing, '
          'that\n'
          'aims to simplify package management and deployment. Package '
          'versions\n'
          'are managed by the package management system _conda_. \n'
          '\n'
          '* "Enthought canopy":"https://www.enthought.com/product/canopy/" \n'
          '\n'
          'is a Python\n'
          'distribution for scientific and analytic computing distribution '
          'and\n'
          'analysis environment, available for free and under a commercial\n'
          'license.\n'
          '\n'
          'We recommend using _Anaconda_ if you are not too familiar with '
          'setting paths in a terminal environment.',
  'title': 'Setting up various Python environments',
  'type': 'Exercise',
  'type_visible': True},
 {'ans_docend': '',
  'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': None,
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': None,
  'no': 2,
  'sol_docend': '',
  'solution': 'The code here is an example of where we define our own design '
              'matrix and fit parameters $\\beta$.\n'
              '!bc pycod\n'
              'import os\n'
              'import numpy as np\n'
              'import pandas as pd\n'
              'import matplotlib.pyplot as plt\n'
              'from sklearn.model_selection import train_test_split\n'
              '\n'
              'def save_fig(fig_id):\n'
              '    plt.savefig(image_path(fig_id) + ".png", format=\'png\')\n'
              '\n'
              'def R2(y_data, y_model):\n'
              '    return 1 - np.sum((y_data - y_model) ** 2) / np.sum((y_data '
              '- np.mean(y_data)) ** 2)\n'
              'def MSE(y_data,y_model):\n'
              '    n = np.size(y_model)\n'
              '    return np.sum((y_data-y_model)**2)/n\n'
              '\n'
              'x = np.random.rand(100)\n'
              'y = 2.0+5*x*x+0.1*np.random.randn(100)\n'
              '\n'
              '\n'
              '#  The design matrix now as function of a given polynomial\n'
              'X = np.zeros((len(x),3))\n'
              'X[:,0] = 1.0\n'
              'X[:,1] = x\n'
              'X[:,2] = x**2\n'
              '# We split the data in test and training data\n'
              'X_train, X_test, y_train, y_test = train_test_split(X, y, '
              'test_size=0.2)\n'
              '# matrix inversion to find beta\n'
              'beta = np.linalg.inv(X_train.T @ X_train) @ X_train.T @ '
              'y_train\n'
              'print(beta)\n'
              '# and then make the prediction\n'
              'ytilde = X_train @ beta\n'
              'print("Training R2")\n'
              'print(R2(y_train,ytilde))\n'
              'print("Training MSE")\n'
              'print(MSE(y_train,ytilde))\n'
              'ypredict = X_test @ beta\n'
              'print("Test R2")\n'
              'print(R2(y_test,ypredict))\n'
              'print("Test MSE")\n'
              'print(MSE(y_test,ypredict))\n'
              '\n'
              '!ec',
  'solution_file': None,
  'subex': [],
  'text': 'We will generate our own dataset for a function $y(x)$ where $x '
          '\\in [0,1]$ and defined by random numbers computed with the uniform '
          'distribution. The function $y$ is a quadratic polynomial in $x$ '
          'with added stochastic noise according to the normal distribution '
          '$\\cal {N}(0,1)$.\n'
          'The following simple Python instructions define our $x$ and $y$ '
          'values (with 100 data points).\n'
          '!bc pycod\n'
          'x = np.random.rand(100,1)\n'
          'y = 2.0+5*x*x+0.1*np.random.randn(100,1)\n'
          '\n'
          '!ec\n'
          '\n'
          'o Write your own code (following the examples under the "regression '
          'notes":"https://compphysics.github.io/MachineLearning/doc/LectureNotes/_build/html/chapter1.html") '
          'for computing the parametrization of the data set fitting a '
          'second-order polynomial. \n'
          'o Use thereafter _scikit-learn_ (see again the examples in the '
          'regression slides) and compare with your own code.   When '
          'compairing with _scikit_learn_, make sure you set the option for '
          'the intercept to _FALSE_, see '
          'URL:"https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LinearRegression.html". '
          'This feature will be explained in more detail during the lectures '
          'of week 35 and week 36. You can find more in '
          'URL:"https://compphysics.github.io/MachineLearning/doc/LectureNotes/_build/html/chapter3.html#more-on-rescaling-data".\n'
          'o Using scikit-learn, compute also the mean square error, a risk '
          'metric corresponding to the expected value of the squared '
          '(quadratic) error defined as\n'
          '!bt\n'
          '\\[ MSE(\\boldsymbol{y},\\boldsymbol{\\tilde{y}}) = \\frac{1}{n}\n'
          '\\sum_{i=0}^{n-1}(y_i-\\tilde{y}_i)^2, \n'
          '\\] \n'
          '\n'
          '!et\n'
          'and the $R^2$ score function.\n'
          'If $\\tilde{\\boldsymbol{y}}_i$ is the predicted value of the '
          '$i-th$ sample and $y_i$ is the corresponding true value, then the '
          'score $R^2$ is defined as\n'
          '!bt\n'
          '\\[\n'
          'R^2(\\boldsymbol{y}, \\tilde{\\boldsymbol{y}}) = 1 - '
          '\\frac{\\sum_{i=0}^{n - 1} (y_i - \\tilde{y}_i)^2}{\\sum_{i=0}^{n - '
          '1} (y_i - \\bar{y})^2},\n'
          '\\]\n'
          '\n'
          '!et\n'
          'where we have defined the mean value  of $\\boldsymbol{y}$ as\n'
          '!bt\n'
          '\\[\n'
          '\\bar{y} =  \\frac{1}{n} \\sum_{i=0}^{n - 1} y_i.\n'
          '\\]\n'
          '\n'
          '!et\n'
          'You can use the functionality included in scikit-learn. If you feel '
          'for it, you can use your own program and define functions which '
          'compute the above two functions. \n'
          'Discuss the meaning of these results. Try also to vary the '
          'coefficient in front of the added stochastic noise term and discuss '
          'the quality of the fits.',
  'title': 'making your own data and exploring scikit-learn',
  'type': 'Exercise',
  'type_visible': True},
 {'ans_docend': '',
  'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': None,
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': None,
  'no': 3,
  'sol_docend': '',
  'solution': 'We present here the solution for the last exercise. All '
              'elements here can be used to solve exercises a) and b) as '
              'well.\n'
              'Note that in this example we have used the polynomial fitting '
              'functions of _scikit-learn_.\n'
              '!bc pycod\n'
              'import matplotlib.pyplot as plt\n'
              'import numpy as np\n'
              'from sklearn.linear_model import LinearRegression, Ridge, '
              'Lasso\n'
              'from sklearn.preprocessing import PolynomialFeatures\n'
              'from sklearn.model_selection import train_test_split\n'
              'from sklearn.pipeline import make_pipeline\n'
              '\n'
              '\n'
              'np.random.seed(2018)\n'
              'n = 30\n'
              'maxdegree = 14\n'
              '# Make data set.\n'
              'x = np.linspace(-3, 3, n).reshape(-1, 1)\n'
              'y = np.exp(-x**2) + 1.5 * np.exp(-(x-2)**2)+ '
              'np.random.normal(0, 0.1, x.shape)\n'
              'TestError = np.zeros(maxdegree)\n'
              'TrainError = np.zeros(maxdegree)\n'
              'polydegree = np.zeros(maxdegree)\n'
              'x_train, x_test, y_train, y_test = train_test_split(x, y, '
              'test_size=0.2)\n'
              '\n'
              '\n'
              'for degree in range(maxdegree):\n'
              '    model = make_pipeline(PolynomialFeatures(degree=degree), '
              'LinearRegression(fit_intercept=False))\n'
              '    clf = model.fit(x_train,y_train)\n'
              '    y_fit = clf.predict(x_train)\n'
              '    y_pred = clf.predict(x_test) \n'
              '    polydegree[degree] = degree\n'
              '    TestError[degree] = np.mean( np.mean((y_test - y_pred)**2) '
              ')\n'
              '    TrainError[degree] = np.mean( np.mean((y_train - y_fit)**2) '
              ')\n'
              '\n'
              "plt.plot(polydegree, TestError, label='Test Error')\n"
              "plt.plot(polydegree, TrainError, label='Train Error')\n"
              'plt.legend()\n'
              'plt.show()\n'
              '\n'
              '!ec',
  'solution_file': None,
  'subex': [{'ans_docend': '',
             'answer': '',
             'file': None,
             'hints': [],
             'sol_docend': '',
             'solution': '',
             'text': 'Write a first code which sets up a design matrix $X$ '
                     'defined by a fifth-order polynomial.  Scale your data '
                     'and split it in training and test data.'},
            {'ans_docend': '',
             'answer': '',
             'file': None,
             'hints': [],
             'sol_docend': '',
             'solution': '',
             'text': 'Perform an ordinary least squares and compute the means '
                     'squared error and the $R2$ factor for the training data '
                     'and the test data, with and without scaling.'},
            {'aftertext': '\n\n\n\n\n',
             'ans_docend': '',
             'answer': '',
             'file': None,
             'hints': [],
             'sol_docend': '',
             'solution': '',
             'text': 'Add now a model which allows you to make polynomials up '
                     'to degree $15$.  Perform a standard OLS fitting of the '
                     'training data and compute the MSE and $R2$ for the '
                     'training and test data and plot both test and training '
                     'data MSE and $R2$ as functions of the polynomial degree. '
                     'Compare what you see with Figure 2.11 of Hastie et al. '
                     'Comment your results. For which polynomial degree do you '
                     'find an optimal MSE (smallest value)?'}],
  'text': 'A much used approach before starting to train the data is  to '
          'preprocess our\n'
          'data. Normally the data may need a rescaling and/or may be '
          'sensitive\n'
          'to extreme values. Scaling the data renders our inputs much more\n'
          'suitable for the algorithms we want to employ.\n'
          '\n'
          '_Scikit-Learn_ has several functions which allow us to rescale the\n'
          'data, normally resulting in much better results in terms of '
          'various\n'
          'accuracy scores.  The _StandardScaler_ function in _Scikit-Learn_\n'
          'ensures that for each feature/predictor we study the mean value is\n'
          'zero and the variance is one (every column in the design/feature\n'
          'matrix).  This scaling has the drawback that it does not ensure '
          'that\n'
          'we have a particular maximum or minimum in our data set. Another\n'
          'function included in _Scikit-Learn_ is the _MinMaxScaler_ which\n'
          'ensures that all features are exactly between $0$ and $1$. The\n'
          '\n'
          '\n'
          'The _Normalizer_ scales each data\n'
          'point such that the feature vector has a euclidean length of one. '
          'In other words, it\n'
          'projects a data point on the circle (or sphere in the case of '
          'higher dimensions) with a\n'
          'radius of 1. This means every data point is scaled by a different '
          'number (by the\n'
          'inverse of it’s length).\n'
          'This normalization is often used when only the direction (or angle) '
          'of the data matters,\n'
          'not the length of the feature vector.\n'
          '\n'
          'The _RobustScaler_ works similarly to the StandardScaler in that '
          'it\n'
          'ensures statistical properties for each feature that guarantee '
          'that\n'
          'they are on the same scale. However, the RobustScaler uses the '
          'median\n'
          'and quartiles, instead of mean and variance. This makes the\n'
          'RobustScaler ignore data points that are very different from the '
          'rest\n'
          '(like measurement errors). These odd data points are also called\n'
          'outliers, and might often lead to trouble for other scaling\n'
          'techniques.\n'
          '\n'
          '\n'
          'It also common to split the data in a _training_ set and a '
          '_testing_ set. A typical split is to use $80\\%$ of the data for '
          'training and the rest\n'
          'for testing. This can be done as follows with our design matrix '
          '$\\boldsymbol{X}$ and data $\\boldsymbol{y}$ (remember to import '
          '_scikit-learn_)\n'
          '!bc pycod\n'
          '# split in training and test data\n'
          'X_train, X_test, y_train, y_test = '
          'train_test_split(X,y,test_size=0.2)\n'
          '\n'
          '!ec\n'
          'Then we can use the standard scaler to scale our data as\n'
          '!bc pycod\n'
          'scaler = StandardScaler()\n'
          'scaler.fit(X_train)\n'
          'X_train_scaled = scaler.transform(X_train)\n'
          'X_test_scaled = scaler.transform(X_test)\n'
          '\n'
          '!ec\n'
          '\n'
          '\n'
          'In this exercise we want you to to compute the MSE for the '
          'training\n'
          'data and the test data as function of the complexity of a '
          'polynomial,\n'
          'that is the degree of a given polynomial. We want you also to '
          'compute the $R2$ score as function of the complexity of the model '
          'for both training data and test data.  You should also run the '
          'calculation with and without scaling. \n'
          '\n'
          'One of \n'
          'the aims is to reproduce Figure 2.11 of "Hastie et '
          'al":"https://github.com/CompPhysics/MLErasmus/blob/master/doc/Textbooks/elementsstat.pdf".\n'
          '\n'
          '\n'
          '\n'
          'Our data is defined by $x\\in [-3,3]$ with a total of for example '
          '$100$ data points.\n'
          '!bc pycod\n'
          'np.random.seed()\n'
          'n = 100\n'
          'maxdegree = 14\n'
          '# Make data set.\n'
          'x = np.linspace(-3, 3, n).reshape(-1, 1)\n'
          'y = np.exp(-x**2) + 1.5 * np.exp(-(x-2)**2)+ np.random.normal(0, '
          '0.1, x.shape)\n'
          '\n'
          '!ec\n'
          'where $y$ is the function we want to fit with a given polynomial.',
  'title': 'Normalizing our data',
  'type': 'Exercise',
  'type_visible': True},
 {'ans_docend': '',
  'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': None,
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': None,
  'no': 4,
  'sol_docend': '',
  'solution': 'The code here allows you to perform your own Ridge calculation '
              'and\n'
              'perform calculations for various values of the regularization\n'
              'parameter $\\lambda$. This program can easily be extended '
              'upon.\n'
              '\n'
              '!bc pycod\n'
              'import os\n'
              'import numpy as np\n'
              'import pandas as pd\n'
              'import matplotlib.pyplot as plt\n'
              'from sklearn.model_selection import train_test_split\n'
              'from sklearn.preprocessing import StandardScaler\n'
              'from sklearn import linear_model\n'
              '\n'
              'def R2(y_data, y_model):\n'
              '    return 1 - np.sum((y_data - y_model) ** 2) / np.sum((y_data '
              '- np.mean(y_data)) ** 2)\n'
              'def MSE(y_data,y_model):\n'
              '    n = np.size(y_model)\n'
              '    return np.sum((y_data-y_model)**2)/n\n'
              '\n'
              '\n'
              '# A seed just to ensure that the random numbers are the same '
              'for every run.\n'
              '# Useful for eventual debugging.\n'
              'np.random.seed(3155)\n'
              '\n'
              'x = np.random.rand(100)\n'
              'y = 2.0+5*x*x+0.1*np.random.randn(100)\n'
              '\n'
              '# number of features p (here degree of polynomial\n'
              'p = 3\n'
              '#  The design matrix now as function of a given polynomial\n'
              'X = np.zeros((len(x),p))\n'
              'X[:,0] = 1.0\n'
              'X[:,1] = x\n'
              'X[:,2] = x*x\n'
              '# We split the data in test and training data\n'
              'X_train, X_test, y_train, y_test = train_test_split(X, y, '
              'test_size=0.2)\n'
              '\n'
              '# matrix inversion to find beta\n'
              'OLSbeta = np.linalg.inv(X_train.T @ X_train) @ X_train.T @ '
              'y_train\n'
              'print(OLSbeta)\n'
              '# and then make the prediction\n'
              'ytildeOLS = X_train @ OLSbeta\n'
              'print("Training R2 for OLS")\n'
              'print(R2(y_train,ytildeOLS))\n'
              'print("Training MSE for OLS")\n'
              'print(MSE(y_train,ytildeOLS))\n'
              'ypredictOLS = X_test @ OLSbeta\n'
              'print("Test R2 for OLS")\n'
              'print(R2(y_test,ypredictOLS))\n'
              'print("Test MSE OLS")\n'
              'print(MSE(y_test,ypredictOLS))\n'
              '\n'
              '\n'
              '# Repeat now for Ridge regression and various values of the '
              'regularization parameter\n'
              'I = np.eye(p,p)\n'
              '# Decide which values of lambda to use\n'
              'nlambdas = 20\n'
              'OwnMSEPredict = np.zeros(nlambdas)\n'
              'OwnMSETrain = np.zeros(nlambdas)\n'
              'MSERidgePredict =  np.zeros(nlambdas)\n'
              'lambdas = np.logspace(-4, 1, nlambdas)\n'
              'for i in range(nlambdas):\n'
              '    lmb = lambdas[i]\n'
              '    OwnRidgebeta = np.linalg.inv(X_train.T @ X_train+lmb*I) @ '
              'X_train.T @ y_train\n'
              '    # and then make the prediction\n'
              '    OwnytildeRidge = X_train @ OwnRidgebeta\n'
              '    OwnypredictRidge = X_test @ OwnRidgebeta\n'
              '    OwnMSEPredict[i] = MSE(y_test,OwnypredictRidge)\n'
              '    OwnMSETrain[i] = MSE(y_train,OwnytildeRidge)\n'
              '    # Make the fit using Ridge from Sklearn\n'
              '    RegRidge = linear_model.Ridge(lmb,fit_intercept=False)\n'
              '    RegRidge.fit(X_train,y_train)\n'
              '    # and then make the prediction\n'
              '    ypredictRidge = RegRidge.predict(X_test)\n'
              '    # Compute the MSE and print it\n'
              '    MSERidgePredict[i] = MSE(y_test,ypredictRidge)\n'
              '\n'
              '# Now plot the results\n'
              'plt.figure()\n'
              "plt.plot(np.log10(lambdas), OwnMSETrain, label = 'MSE Ridge "
              "train, Own code')\n"
              "plt.plot(np.log10(lambdas), OwnMSEPredict, 'r--', label = 'MSE "
              "Ridge Test, Own code')\n"
              "plt.plot(np.log10(lambdas), MSERidgePredict, 'g--', label = "
              "'MSE Ridge Test, Sklearn code')\n"
              "plt.xlabel('log10(lambda)')\n"
              "plt.ylabel('MSE')\n"
              'plt.legend()\n'
              'plt.show()\n'
              '\n'
              '!ec',
  'solution_file': None,
  'subex': [],
  'text': 'This exercise is a continuation of exercise 2. We will use the same '
          'function to\n'
          'generate our data set, still staying with a simple function $y(x)$\n'
          'which we want to fit using linear regression, but now extending '
          'the\n'
          'analysis to include the Ridge regression method.\n'
          '\n'
          'We will thus again generate our own dataset for a function $y(x)$ '
          'where \n'
          '$x \\in [0,1]$ and defined by random numbers computed with the '
          'uniform\n'
          'distribution. The function $y$ is a quadratic polynomial in $x$ '
          'with\n'
          'added stochastic noise according to the normal distribution '
          '$\\cal{N}(0,1)$.\n'
          '\n'
          'The following simple Python instructions define our $x$ and $y$ '
          'values (with 100 data points).\n'
          '!bc pycod\n'
          'x = np.random.rand(100)\n'
          'y = 2.0+5*x*x+0.1*np.random.randn(100)\n'
          '\n'
          '!ec\n'
          '\n'
          '\n'
          'Write your own code for the Ridge method (see chapter 3.4 of Hastie '
          '*et al.*, equations (3.43) and (3.44)) and compute the '
          'parametrization for different values of $\\lambda$. Compare and '
          'analyze your results with those from exercise 3. Study the '
          'dependence on $\\lambda$ while also varying the strength of the '
          'noise in your expression for $y(x)$. \n'
          '\n'
          '\n'
          'Repeat the above but using the functionality of\n'
          '_Scikit-Learn_. Compare your code with the results from\n'
          '_Scikit-Learn_. Remember to run with the same random numbers for\n'
          'generating $x$ and $y$.  Observe also that when you compare with '
          '_Scikit-Learn_, you need to pay attention to how the intercept is '
          'dealt with.\n'
          '\n'
          '\n'
          '\n'
          'Finally, using _Scikit-Learn_ or your own code, compute also the '
          'mean square error, a risk metric corresponding to the expected '
          'value of the squared (quadratic) error defined as\n'
          '!bt\n'
          '\\[ MSE(\\hat{y},\\hat{\\tilde{y}}) = \\frac{1}{n}\n'
          '\\sum_{i=0}^{n-1}(y_i-\\tilde{y}_i)^2, \n'
          '\\] \n'
          '\n'
          '!et\n'
          'and the $R^2$ score function.\n'
          'If $\\tilde{\\hat{y}}_i$ is the predicted value of the $i-th$ '
          'sample and $y_i$ is the corresponding true value, then the score '
          '$R^2$ is defined as\n'
          '!bt\n'
          '\\[\n'
          'R^2(\\hat{y}, \\tilde{\\hat{y}}) = 1 - \\frac{\\sum_{i=0}^{n - 1} '
          '(y_i - \\tilde{y}_i)^2}{\\sum_{i=0}^{n - 1} (y_i - \\bar{y})^2},\n'
          '\\]\n'
          '\n'
          '!et\n'
          'where we have defined the mean value  of $\\hat{y}$ as\n'
          '!bt\n'
          '\\[\n'
          '\\bar{y} =  \\frac{1}{n} \\sum_{i=0}^{n - 1} y_i.\n'
          '\\]\n'
          '\n'
          '!et\n'
          'Discuss these quantities as functions of the variable $\\lambda$ in '
          'Ridge regression.',
  'title': 'Adding Ridge Regression',
  'type': 'Exercise',
  'type_visible': True},
 {'ans_docend': '',
  'answer': '',
  'chapter_exercise': None,
  'chapter_no': None,
  'chapter_title': None,
  'chapter_type': None,
  'closing_remarks': '',
  'file': None,
  'heading': '=====',
  'hints': [],
  'keywords': None,
  'label': None,
  'no': 5,
  'sol_docend': '',
  'solution': 'In these exercises it is always useful to write out with '
              'summation indices the various quantities.\n'
              'As an example, consider the function\n'
              '\n'
              '!bt\n'
              '\\[\n'
              'f(\\boldsymbol{x}) =\\boldsymbol{A}\\boldsymbol{x},\n'
              '\\]\n'
              '\n'
              '!et\n'
              'which reads for a specific component $f_i$ (we define the '
              'matrix $\\boldsymbol{A}$ to have dimension $n\\times n$ and the '
              'vector $\\boldsymbol{x}$ to have length $n$)\n'
              '\n'
              '!bt\n'
              '\\[\n'
              'f_i =\\sum_{j=0}^{n-1}a_{ij}x_j, \n'
              '\\]\n'
              '\n'
              '!et\n'
              'which leads to\n'
              '!bt\n'
              '\\[\n'
              '\\frac{\\partial f_i}{\\partial x_j}= a_{ij},\n'
              '\\]\n'
              '\n'
              '!et\n'
              'and written out in terms of the vector $\\boldsymbol{x}$ we '
              'have\n'
              '!bt\n'
              '\\[\n'
              '\\frac{\\partial f(\\boldsymbol{x})}{\\partial '
              '\\boldsymbol{x}}= \\boldsymbol{A}.\n'
              '\\]\n'
              '\n'
              '!et\n'
              '\n'
              'For the first derivative\n'
              '!bt\n'
              '\\[\n'
              '\\frac{\\partial (\\boldsymbol{b}^T\\boldsymbol{a})}{\\partial '
              '\\boldsymbol{a}} = \\boldsymbol{b},\n'
              '\\]\n'
              '\n'
              '!et\n'
              'we can write out the inner product as (assuming all elements '
              'are real)\n'
              '!bt\n'
              '\\[\n'
              '\\boldsymbol{b}^T\\boldsymbol{a}=\\sum_i b_ia_i, \n'
              '\\]\n'
              '\n'
              '!et\n'
              'taking the derivative\n'
              '!bt\n'
              '\\[\n'
              '\\frac{\\partial \\left( \\sum_i b_ia_i\\right)}{\\partial '
              'a_k}= b_k, \n'
              '\\]\n'
              '\n'
              '!et\n'
              'leading to \n'
              '!bt\n'
              '\\[\n'
              '\\frac{\\partial \\boldsymbol{b}^T\\boldsymbol{a}}{\\partial '
              '\\boldsymbol{a}}= \\begin{bmatrix} b_0 \\\\ b_1 \\\\ b_2 \\\\ '
              '\\dots \\\\ \\dots \\\\ b_{n-1}\\end{bmatrix} = '
              '\\boldsymbol{b}. \n'
              '\\]\n'
              '\n'
              '!et\n'
              '\n'
              'For the second exercise we have \n'
              '!bt\n'
              '\\[\n'
              '\\frac{\\partial '
              '(\\boldsymbol{a}^T\\boldsymbol{A}\\boldsymbol{a})}{\\partial '
              '\\boldsymbol{a}}.\n'
              '\\]\n'
              '\n'
              '!et\n'
              'Defining a vector '
              '$\\boldsymbol{f}=\\boldsymbol{A}\\boldsymbol{a}$ with '
              'components $f_i=\\sum_ja_{ij}a_i$  we have\n'
              '!bt\n'
              '\\[\n'
              '\\frac{\\partial (\\boldsymbol{a}^T\\boldsymbol{f})}{\\partial '
              '\\boldsymbol{a}}=\\boldsymbol{a}^T\\boldsymbol{A}+\\boldsymbol{f}^T=\\boldsymbol{a}^T\\left(\\boldsymbol{A}+\\boldsymbol{A}^T\\right),\n'
              '\\]\n'
              '\n'
              '!et\n'
              'since $f$ depends on $a$ and we have used the chain rule for '
              'derivatives on the derivative of $f$ with respect to $a$.',
  'solution_file': None,
  'subex': [],
  'text': 'In this exercise we derive the expressions for various derivatives '
          'of\n'
          'products of vectors and matrices. Such derivatives are central to '
          'the\n'
          'optimization of various cost functions. Although we will often use\n'
          'automatic differentiation in actual calculations, to be able to '
          'have\n'
          'analytical expressions is extremely helpful in case we have '
          'simpler\n'
          'derivatives as well as when we analyze various properties (like '
          'second\n'
          'derivatives) of the chosen cost functions.  Vectors are always '
          'written\n'
          'as boldfaced lower case letters and matrices as upper case '
          'boldfaced\n'
          'letters.\n'
          '\n'
          'Show that\n'
          '!bt\n'
          '\\[\n'
          '\\frac{\\partial (\\boldsymbol{b}^T\\boldsymbol{a})}{\\partial '
          '\\boldsymbol{a}} = \\boldsymbol{b},\n'
          '\\]\n'
          '\n'
          '!et\n'
          'and\n'
          '!bt\n'
          '\\[\n'
          '\\frac{\\partial '
          '(\\boldsymbol{a}^T\\boldsymbol{A}\\boldsymbol{a})}{\\partial '
          '\\boldsymbol{a}} = '
          '\\boldsymbol{a}^T(\\boldsymbol{A}+\\boldsymbol{A}^T),\n'
          '\\]\n'
          '\n'
          '!et\n'
          'and\n'
          '!bt\n'
          '\\[\n'
          '\\frac{\\partial '
          '\\left(\\boldsymbol{x}-\\boldsymbol{A}\\boldsymbol{s}\\right)^T\\left(\\boldsymbol{x}-\\boldsymbol{A}\\boldsymbol{s}\\right)}{\\partial '
          '\\boldsymbol{s}} = '
          '-2\\left(\\boldsymbol{x}-\\boldsymbol{A}\\boldsymbol{s}\\right)^T\\boldsymbol{A},\n'
          '\\]\n'
          '\n'
          '!et\n'
          'and finally find the second derivative of this function with '
          'respect to the vector $\\boldsymbol{s}$.',
  'title': 'Analytical exercises',
  'type': 'Exercise',
  'type_visible': True}]